! Do not modify this file automatically generated by cfwrapper.py using:
! gtk-fortran 3.24.31, GTK 3.24.31, GLib 2.72.1, Fedora 36 x86_64
! This file is part of the gtk-fortran library, distributed under
! GNU General Public License version 3.

module g
use, intrinsic :: iso_c_binding
implicit none
interface

!--------------------------------------------------
! /usr/include/glib-2.0/glib.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib-object.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib-unix.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_30
!GQuark g_unix_error_quark (void);
function g_unix_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_unix_error_quark
end function

! GLIB_AVAILABLE_IN_2_30
!gboolean g_unix_open_pipe (gint *fds, gint flags, GError **error);
function g_unix_open_pipe(fds, flags, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_open_pipe
  type(c_ptr), value :: fds
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!gboolean g_unix_set_fd_nonblocking (gint fd, gboolean nonblock, GError **error);
function g_unix_set_fd_nonblocking(fd, nonblock, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_set_fd_nonblocking
  integer(c_int), value :: fd
  integer(c_int), value :: nonblock
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!GSource *g_unix_signal_source_new (gint signum);
function g_unix_signal_source_new(signum) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_unix_signal_source_new
  integer(c_int), value :: signum
end function

! GLIB_AVAILABLE_IN_2_30
!guint g_unix_signal_add_full (gint priority, gint signum, GSourceFunc handler, gpointer user_data, GDestroyNotify notify);
function g_unix_signal_add_full(priority, signum, handler, user_data, notify)&
& bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_unix_signal_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: signum
  type(c_funptr), value :: handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_2_30
!guint g_unix_signal_add (gint signum, GSourceFunc handler, gpointer user_data);
function g_unix_signal_add(signum, handler, user_data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_unix_signal_add
  integer(c_int), value :: signum
  type(c_funptr), value :: handler
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_36
!GSource *g_unix_fd_source_new (gint fd, GIOCondition condition);
function g_unix_fd_source_new(fd, condition) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_unix_fd_source_new
  integer(c_int), value :: fd
  integer(c_int), value :: condition
end function

! GLIB_AVAILABLE_IN_2_36
!guint g_unix_fd_add_full (gint priority, gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data, GDestroyNotify notify);
function g_unix_fd_add_full(priority, fd, condition, function, user_data,&
& notify) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_unix_fd_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: fd
  integer(c_int), value :: condition
  type(c_funptr), value :: function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_2_36
!guint g_unix_fd_add (gint fd, GIOCondition condition, GUnixFDSourceFunc function, gpointer user_data);
function g_unix_fd_add(fd, condition, function, user_data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_unix_fd_add
  integer(c_int), value :: fd
  integer(c_int), value :: condition
  type(c_funptr), value :: function
  type(c_ptr), value :: user_data
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gmodule.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_70
!GQuark g_module_error_quark (void);
function g_module_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_module_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_module_supported (void) G_GNUC_CONST;
function g_module_supported() bind(c)
  import :: c_int
  integer(c_int) :: g_module_supported
end function

! GLIB_AVAILABLE_IN_ALL
!GModule* g_module_open (const gchar *file_name, GModuleFlags flags);
function g_module_open(file_name, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_module_open
  character(kind=c_char), dimension(*) :: file_name
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_70
!GModule *g_module_open_full (const gchar *file_name, GModuleFlags flags, GError **error);
function g_module_open_full(file_name, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_module_open_full
  character(kind=c_char), dimension(*) :: file_name
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_module_close (GModule *module);
function g_module_close(module) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_module_close
  type(c_ptr), value :: module
end function

! GLIB_AVAILABLE_IN_ALL
!void g_module_make_resident (GModule *module);
subroutine g_module_make_resident(module) bind(c)
  import :: c_ptr
  type(c_ptr), value :: module
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_module_error (void);
function g_module_error() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_module_error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol);
function g_module_symbol(module, symbol_name, symbol) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_module_symbol
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: symbol_name
  type(c_ptr), value :: symbol
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_module_name (GModule *module);
function g_module_name(module) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_module_name
  type(c_ptr), value :: module
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_module_build_path (const gchar *directory, const gchar *module_name);
function g_module_build_path(directory, module_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_module_build_path
  character(kind=c_char), dimension(*) :: directory
  character(kind=c_char), dimension(*) :: module_name
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/galloca.h
!--------------------------------------------------
! 
!char *alloca ();
function alloca() bind(c)
  import :: c_ptr
  type(c_ptr) :: alloca
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtimer.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GTimer* g_timer_new (void);
function g_timer_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_timer_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_timer_destroy (GTimer *timer);
subroutine g_timer_destroy(timer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: timer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_timer_start (GTimer *timer);
subroutine g_timer_start(timer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: timer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_timer_stop (GTimer *timer);
subroutine g_timer_stop(timer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: timer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_timer_reset (GTimer *timer);
subroutine g_timer_reset(timer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: timer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_timer_continue (GTimer *timer);
subroutine g_timer_continue(timer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: timer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gdouble g_timer_elapsed (GTimer *timer, gulong *microseconds);
function g_timer_elapsed(timer, microseconds) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_timer_elapsed
  type(c_ptr), value :: timer
  type(c_ptr), value :: microseconds
end function

! GLIB_AVAILABLE_IN_2_62
!gboolean g_timer_is_active (GTimer *timer);
function g_timer_is_active(timer) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_timer_is_active
  type(c_ptr), value :: timer
end function

! GLIB_AVAILABLE_IN_ALL
!void g_usleep (gulong microseconds);
subroutine g_usleep(microseconds) bind(c)
  import :: c_long
  integer(c_long), value :: microseconds
end subroutine

! GLIB_DEPRECATED_IN_2_62
!void g_time_val_add (GTimeVal *time_, glong microseconds);
subroutine g_time_val_add(time_, microseconds) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: time_
  integer(c_long), value :: microseconds
end subroutine

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_iso8601)
!gboolean g_time_val_from_iso8601 (const gchar *iso_date, GTimeVal *time_);
function g_time_val_from_iso8601(iso_date, time_) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_time_val_from_iso8601
  character(kind=c_char), dimension(*) :: iso_date
  type(c_ptr), value :: time_
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_format)
!gchar* g_time_val_to_iso8601 (GTimeVal *time_) G_GNUC_MALLOC;
function g_time_val_to_iso8601(time_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_time_val_to_iso8601
  type(c_ptr), value :: time_
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gkeyfile.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_key_file_error_quark (void);
function g_key_file_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_key_file_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GKeyFile *g_key_file_new (void);
function g_key_file_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_key_file_new
end function

! GLIB_AVAILABLE_IN_ALL
!GKeyFile *g_key_file_ref (GKeyFile *key_file);
function g_key_file_ref(key_file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_key_file_ref
  type(c_ptr), value :: key_file
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_unref (GKeyFile *key_file);
subroutine g_key_file_unref(key_file) bind(c)
  import :: c_ptr
  type(c_ptr), value :: key_file
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_free (GKeyFile *key_file);
subroutine g_key_file_free(key_file) bind(c)
  import :: c_ptr
  type(c_ptr), value :: key_file
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_list_separator (GKeyFile *key_file, gchar separator);
subroutine g_key_file_set_list_separator(key_file, separator) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr), value :: key_file
  integer(kind=c_int8_t), value :: separator
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_load_from_file (GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_file(key_file, file, flags, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_load_from_data (GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data(key_file, data, length, flags, error)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_key_file_load_from_data
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_key_file_load_from_bytes (GKeyFile *key_file, GBytes *bytes, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_bytes(key_file, bytes, flags, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_key_file_load_from_bytes
  type(c_ptr), value :: key_file
  type(c_ptr), value :: bytes
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_load_from_dirs (GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_dirs(key_file, file, search_dirs, full_path,&
& flags, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: search_dirs
  type(c_ptr), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data_dirs(key_file, file, full_path, flags,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_data_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_to_data (GKeyFile *key_file, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_to_data(key_file, length, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_key_file_to_data
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_key_file_save_to_file (GKeyFile *key_file, const gchar *filename, GError **error);
function g_key_file_save_to_file(key_file, filename, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_save_to_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_get_start_group (GKeyFile *key_file) G_GNUC_MALLOC;
function g_key_file_get_start_group(key_file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_key_file_get_start_group
  type(c_ptr), value :: key_file
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_key_file_get_groups (GKeyFile *key_file, gsize *length);
function g_key_file_get_groups(key_file, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_key_file_get_groups
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_key_file_get_keys (GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error);
function g_key_file_get_keys(key_file, group_name, length, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_keys
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_has_group (GKeyFile *key_file, const gchar *group_name);
function g_key_file_has_group(key_file, group_name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_has_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_has_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_has_key(key_file, group_name, key, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_has_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_get_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_value(key_file, group_name, key, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_value
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value);
subroutine g_key_file_set_value(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_get_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_string(key_file, group_name, key, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string);
subroutine g_key_file_set_string(key_file, group_name, key, string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: string
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_get_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error) G_GNUC_MALLOC;
function g_key_file_get_locale_string(key_file, group_name, key, locale, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_56
!gchar *g_key_file_get_locale_for_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale) G_GNUC_MALLOC;
function g_key_file_get_locale_for_key(key_file, group_name, key, locale)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_for_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string);
subroutine g_key_file_set_locale_string(key_file, group_name, key, locale,&
& string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: string
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_get_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_boolean(key_file, group_name, key, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_get_boolean
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value);
subroutine g_key_file_set_boolean(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_key_file_get_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_integer(key_file, group_name, key, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_get_integer
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value);
subroutine g_key_file_set_integer(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint64 g_key_file_get_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_int64(key_file, group_name, key, error) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_int64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value);
subroutine g_key_file_set_int64(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint64 g_key_file_get_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_uint64(key_file, group_name, key, error) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_uint64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value);
subroutine g_key_file_set_uint64(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gdouble g_key_file_get_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_double(key_file, group_name, key, error) bind(c)
  import :: c_double, c_ptr, c_char
  real(c_double) :: g_key_file_get_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value);
subroutine g_key_file_set_double(key_file, group_name, key, value) bind(c)
  import :: c_ptr, c_char, c_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar **g_key_file_get_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error);
function g_key_file_get_string_list(key_file, group_name, key, length, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length);
subroutine g_key_file_set_string_list(key_file, group_name, key, list, length)&
& bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar **g_key_file_get_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error);
function g_key_file_get_locale_string_list(key_file, group_name, key, locale,&
& length, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length);
subroutine g_key_file_set_locale_string_list(key_file, group_name, key, locale,&
& list, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean *g_key_file_get_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_boolean_list(key_file, group_name, key, length, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_boolean_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length);
subroutine g_key_file_set_boolean_list(key_file, group_name, key, list, length)&
& bind(c)
  import :: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint *g_key_file_get_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_integer_list(key_file, group_name, key, length, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_integer_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length);
subroutine g_key_file_set_double_list(key_file, group_name, key, list, length)&
& bind(c)
  import :: c_ptr, c_char, c_double, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gdouble *g_key_file_get_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_double_list(key_file, group_name, key, length, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_double_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_key_file_set_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length);
subroutine g_key_file_set_integer_list(key_file, group_name, key, list, length)&
& bind(c)
  import :: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_set_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error);
function g_key_file_set_comment(key_file, group_name, key, comment, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_set_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: comment
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_key_file_get_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_comment(key_file, group_name, key, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_remove_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_comment(key_file, group_name, key, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_remove_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_key(key_file, group_name, key, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_key_file_remove_group (GKeyFile *key_file, const gchar *group_name, GError **error);
function g_key_file_remove_group(key_file, group_name, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gatomic.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gint g_atomic_int_get (const volatile gint *atomic);
function g_atomic_int_get(atomic) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_get
  type(c_ptr), value :: atomic
end function

! GLIB_AVAILABLE_IN_ALL
!void g_atomic_int_set (volatile gint *atomic, gint newval);
subroutine g_atomic_int_set(atomic, newval) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: atomic
  integer(c_int), value :: newval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_atomic_int_inc (volatile gint *atomic);
subroutine g_atomic_int_inc(atomic) bind(c)
  import :: c_ptr
  type(c_ptr), value :: atomic
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_atomic_int_dec_and_test (volatile gint *atomic);
function g_atomic_int_dec_and_test(atomic) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_dec_and_test
  type(c_ptr), value :: atomic
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_atomic_int_compare_and_exchange (volatile gint *atomic, gint oldval, gint newval);
function g_atomic_int_compare_and_exchange(atomic, oldval, newval) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_compare_and_exchange
  type(c_ptr), value :: atomic
  integer(c_int), value :: oldval
  integer(c_int), value :: newval
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_atomic_int_add (volatile gint *atomic, gint val);
function g_atomic_int_add(atomic, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_add
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! GLIB_AVAILABLE_IN_2_30
!guint g_atomic_int_and (volatile guint *atomic, guint val);
function g_atomic_int_and(atomic, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_and
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! GLIB_AVAILABLE_IN_2_30
!guint g_atomic_int_or (volatile guint *atomic, guint val);
function g_atomic_int_or(atomic, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_or
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_atomic_int_xor (volatile guint *atomic, guint val);
function g_atomic_int_xor(atomic, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_xor
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_atomic_pointer_get (const volatile void *atomic);
function g_atomic_pointer_get(atomic) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_atomic_pointer_get
  type(c_ptr), value :: atomic
end function

! GLIB_AVAILABLE_IN_ALL
!void g_atomic_pointer_set (volatile void *atomic, gpointer newval);
subroutine g_atomic_pointer_set(atomic, newval) bind(c)
  import :: c_ptr
  type(c_ptr), value :: atomic
  type(c_ptr), value :: newval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_atomic_pointer_compare_and_exchange (volatile void *atomic, gpointer oldval, gpointer newval);
function g_atomic_pointer_compare_and_exchange(atomic, oldval, newval) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_pointer_compare_and_exchange
  type(c_ptr), value :: atomic
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_atomic_pointer_add (volatile void *atomic, gssize val);
function g_atomic_pointer_add(atomic, val) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_atomic_pointer_add
  type(c_ptr), value :: atomic
  integer(c_size_t), value :: val
end function

! GLIB_AVAILABLE_IN_2_30
!gsize g_atomic_pointer_and (volatile void *atomic, gsize val);
function g_atomic_pointer_and(atomic, val) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_atomic_pointer_and
  type(c_ptr), value :: atomic
  integer(c_size_t), value :: val
end function

! GLIB_AVAILABLE_IN_2_30
!gsize g_atomic_pointer_or (volatile void *atomic, gsize val);
function g_atomic_pointer_or(atomic, val) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_atomic_pointer_or
  type(c_ptr), value :: atomic
  integer(c_size_t), value :: val
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_atomic_pointer_xor (volatile void *atomic, gsize val);
function g_atomic_pointer_xor(atomic, val) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_atomic_pointer_xor
  type(c_ptr), value :: atomic
  integer(c_size_t), value :: val
end function

! GLIB_DEPRECATED_IN_2_30_FOR(g_atomic_int_add)
!gint g_atomic_int_exchange_and_add (volatile gint *atomic, gint val);
function g_atomic_int_exchange_and_add(atomic, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_int_exchange_and_add
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtimezone.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_68_FOR (g_time_zone_new_identifier)
!GTimeZone * g_time_zone_new (const gchar *identifier);
function g_time_zone_new(identifier) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_time_zone_new
  character(kind=c_char), dimension(*) :: identifier
end function

! GLIB_AVAILABLE_IN_2_68
!GTimeZone * g_time_zone_new_identifier (const gchar *identifier);
function g_time_zone_new_identifier(identifier) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_time_zone_new_identifier
  character(kind=c_char), dimension(*) :: identifier
end function

! GLIB_AVAILABLE_IN_ALL
!GTimeZone * g_time_zone_new_utc (void);
function g_time_zone_new_utc() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_time_zone_new_utc
end function

! GLIB_AVAILABLE_IN_ALL
!GTimeZone * g_time_zone_new_local (void);
function g_time_zone_new_local() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_time_zone_new_local
end function

! GLIB_AVAILABLE_IN_2_58
!GTimeZone * g_time_zone_new_offset (gint32 seconds);
function g_time_zone_new_offset(seconds) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_time_zone_new_offset
  integer(c_int32_t), value :: seconds
end function

! GLIB_AVAILABLE_IN_ALL
!GTimeZone * g_time_zone_ref (GTimeZone *tz);
function g_time_zone_ref(tz) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_time_zone_ref
  type(c_ptr), value :: tz
end function

! GLIB_AVAILABLE_IN_ALL
!void g_time_zone_unref (GTimeZone *tz);
subroutine g_time_zone_unref(tz) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tz
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_time_zone_find_interval (GTimeZone *tz, GTimeType type, gint64 time_);
function g_time_zone_find_interval(tz, type, time_) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_time_zone_find_interval
  type(c_ptr), value :: tz
  integer(c_int), value :: type
  integer(c_int64_t), value :: time_
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_time_zone_adjust_time (GTimeZone *tz, GTimeType type, gint64 *time_);
function g_time_zone_adjust_time(tz, type, time_) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_time_zone_adjust_time
  type(c_ptr), value :: tz
  integer(c_int), value :: type
  type(c_ptr), value :: time_
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_time_zone_get_abbreviation (GTimeZone *tz, gint interval);
function g_time_zone_get_abbreviation(tz, interval) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_time_zone_get_abbreviation
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_time_zone_get_offset (GTimeZone *tz, gint interval);
function g_time_zone_get_offset(tz, interval) bind(c)
  import :: c_int32_t, c_ptr, c_int
  integer(c_int32_t) :: g_time_zone_get_offset
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_time_zone_is_dst (GTimeZone *tz, gint interval);
function g_time_zone_is_dst(tz, interval) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_time_zone_is_dst
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

! GLIB_AVAILABLE_IN_2_58
!const gchar * g_time_zone_get_identifier (GTimeZone *tz);
function g_time_zone_get_identifier(tz) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_time_zone_get_identifier
  type(c_ptr), value :: tz
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/guuid.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_52
!gboolean g_uuid_string_is_valid (const gchar *str);
function g_uuid_string_is_valid(str) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_uuid_string_is_valid
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_2_52
!gchar * g_uuid_string_random (void);
function g_uuid_string_random() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uuid_string_random
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/grand.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GRand* g_rand_new_with_seed (guint32 seed);
function g_rand_new_with_seed(seed) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_rand_new_with_seed
  integer(c_int32_t), value :: seed
end function

! GLIB_AVAILABLE_IN_ALL
!GRand* g_rand_new_with_seed_array (const guint32 *seed, guint seed_length);
function g_rand_new_with_seed_array(seed, seed_length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_rand_new_with_seed_array
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end function

! GLIB_AVAILABLE_IN_ALL
!GRand* g_rand_new (void);
function g_rand_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_rand_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_rand_free (GRand *rand_);
subroutine g_rand_free(rand_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rand_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GRand* g_rand_copy (GRand *rand_);
function g_rand_copy(rand_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_rand_copy
  type(c_ptr), value :: rand_
end function

! GLIB_AVAILABLE_IN_ALL
!void g_rand_set_seed (GRand *rand_, guint32 seed);
subroutine g_rand_set_seed(rand_, seed) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: seed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_rand_set_seed_array (GRand *rand_, const guint32 *seed, guint seed_length);
subroutine g_rand_set_seed_array(rand_, seed, seed_length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: rand_
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint32 g_rand_int (GRand *rand_);
function g_rand_int(rand_) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int
  type(c_ptr), value :: rand_
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_rand_int_range (GRand *rand_, gint32 begin, gint32 end);
function g_rand_int_range(rand_, begin, end) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int_range
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_rand_double (GRand *rand_);
function g_rand_double(rand_) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_rand_double
  type(c_ptr), value :: rand_
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_rand_double_range (GRand *rand_, gdouble begin, gdouble end);
function g_rand_double_range(rand_, begin, end) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_rand_double_range
  type(c_ptr), value :: rand_
  real(c_double), value :: begin
  real(c_double), value :: end
end function

! GLIB_AVAILABLE_IN_ALL
!void g_random_set_seed (guint32 seed);
subroutine g_random_set_seed(seed) bind(c)
  import :: c_int32_t
  integer(c_int32_t), value :: seed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint32 g_random_int (void);
function g_random_int() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_random_int
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_random_int_range (gint32 begin, gint32 end);
function g_random_int_range(begin, end) bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_random_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_random_double (void);
function g_random_double() bind(c)
  import :: c_double
  real(c_double) :: g_random_double
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_random_double_range (gdouble begin, gdouble end);
function g_random_double_range(begin, end) bind(c)
  import :: c_double
  real(c_double) :: g_random_double_range
  real(c_double), value :: begin
  real(c_double), value :: end
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gstdio.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!FILE *g_fopen (const gchar *filename, const gchar *mode);
function g_fopen(filename, mode) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_fopen
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!FILE *g_freopen (const gchar *filename, const gchar *mode, FILE *stream);
function g_freopen(filename, mode, stream) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_freopen
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: mode
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_close (gint fd, GError **error);
function g_close(fd, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_close
  integer(c_int), value :: fd
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_64
!gint g_fsync (gint fd);
function g_fsync(fd) bind(c)
  import :: c_int
  integer(c_int) :: g_fsync
  integer(c_int), value :: fd
end function

! GLIB_AVAILABLE_IN_ALL
!int g_access (const gchar *filename, int mode);
function g_access(filename, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_access
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!int g_chdir (const gchar *path);
function g_chdir(path) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_chdir
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_ALL
!int g_chmod (const gchar *filename, int mode);
function g_chmod(filename, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_chmod
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!int g_creat (const gchar *filename, int mode);
function g_creat(filename, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_creat
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!int g_lstat (const gchar *filename, GStatBuf *buf);
function g_lstat(filename, buf) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_lstat
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: buf
end function

! GLIB_AVAILABLE_IN_ALL
!int g_mkdir (const gchar *filename, int mode);
function g_mkdir(filename, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_mkdir
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!int g_open (const gchar *filename, int flags, int mode);
function g_open(filename, flags, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_open
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: flags
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!int g_remove (const gchar *filename);
function g_remove(filename) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_remove
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!int g_rename (const gchar *oldfilename, const gchar *newfilename);
function g_rename(oldfilename, newfilename) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_rename
  character(kind=c_char), dimension(*) :: oldfilename
  character(kind=c_char), dimension(*) :: newfilename
end function

! GLIB_AVAILABLE_IN_ALL
!int g_rmdir (const gchar *filename);
function g_rmdir(filename) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_rmdir
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!int g_stat (const gchar *filename, GStatBuf *buf);
function g_stat(filename, buf) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_stat
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: buf
end function

! GLIB_AVAILABLE_IN_ALL
!int g_unlink (const gchar *filename);
function g_unlink(filename) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_unlink
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!int g_utime (const gchar *filename, struct utimbuf *utb);
function g_utime(filename, utb) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_utime
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: utb
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/goption.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_option_error_quark (void);
function g_option_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_option_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GOptionContext *g_option_context_new (const gchar *parameter_string);
function g_option_context_new(parameter_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_option_context_new
  character(kind=c_char), dimension(*) :: parameter_string
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_summary (GOptionContext *context, const gchar *summary);
subroutine g_option_context_set_summary(context, summary) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: summary
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_option_context_get_summary (GOptionContext *context);
function g_option_context_get_summary(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_option_context_get_summary
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_description (GOptionContext *context, const gchar *description);
subroutine g_option_context_set_description(context, description) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: description
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_option_context_get_description (GOptionContext *context);
function g_option_context_get_description(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_option_context_get_description
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_free (GOptionContext *context);
subroutine g_option_context_free(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_help_enabled (GOptionContext *context, gboolean help_enabled);
subroutine g_option_context_set_help_enabled(context, help_enabled) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: help_enabled
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_option_context_get_help_enabled (GOptionContext *context);
function g_option_context_get_help_enabled(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_option_context_get_help_enabled
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_ignore_unknown_options (GOptionContext *context, gboolean ignore_unknown);
subroutine g_option_context_set_ignore_unknown_options(context, ignore_unknown)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: ignore_unknown
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);
function g_option_context_get_ignore_unknown_options(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_option_context_get_ignore_unknown_options
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_2_44
!void g_option_context_set_strict_posix (GOptionContext *context, gboolean strict_posix);
subroutine g_option_context_set_strict_posix(context, strict_posix) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: strict_posix
end subroutine

! GLIB_AVAILABLE_IN_2_44
!gboolean g_option_context_get_strict_posix (GOptionContext *context);
function g_option_context_get_strict_posix(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_option_context_get_strict_posix
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_add_main_entries (GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain);
subroutine g_option_context_add_main_entries(context, entries,&
& translation_domain) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  type(c_ptr), value :: entries
  character(kind=c_char), dimension(*) :: translation_domain
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_option_context_parse (GOptionContext *context, gint *argc, gchar ***argv, GError **error);
function g_option_context_parse(context, argc, argv, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_option_context_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: argc
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_option_context_parse_strv (GOptionContext *context, gchar ***arguments, GError **error);
function g_option_context_parse_strv(context, arguments, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_option_context_parse_strv
  type(c_ptr), value :: context
  type(c_ptr), dimension(*) :: arguments
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_translate_func (GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_context_set_translate_func(context, func, data,&
& destroy_notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_translation_domain (GOptionContext *context, const gchar *domain);
subroutine g_option_context_set_translation_domain(context, domain) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: domain
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_add_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_add_group(context, group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_context_set_main_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_set_main_group(context, group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
function g_option_context_get_main_group(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_option_context_get_main_group
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_option_context_get_help (GOptionContext *context, gboolean main_help, GOptionGroup *group);
function g_option_context_get_help(context, main_help, group) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_option_context_get_help
  type(c_ptr), value :: context
  integer(c_int), value :: main_help
  type(c_ptr), value :: group
end function

! GLIB_AVAILABLE_IN_ALL
!GOptionGroup *g_option_group_new (const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy);
function g_option_group_new(name, description, help_description, user_data,&
& destroy) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_option_group_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: description
  character(kind=c_char), dimension(*) :: help_description
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_option_group_set_parse_hooks (GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
subroutine g_option_group_set_parse_hooks(group, pre_parse_func,&
& post_parse_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: pre_parse_func
  type(c_funptr), value :: post_parse_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_group_set_error_hook (GOptionGroup *group, GOptionErrorFunc error_func);
subroutine g_option_group_set_error_hook(group, error_func) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: group
  integer(c_int), value :: error_func
end subroutine

! GLIB_DEPRECATED_IN_2_44
!void g_option_group_free (GOptionGroup *group);
subroutine g_option_group_free(group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: group
end subroutine

! GLIB_AVAILABLE_IN_2_44
!GOptionGroup *g_option_group_ref (GOptionGroup *group);
function g_option_group_ref(group) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_option_group_ref
  type(c_ptr), value :: group
end function

! GLIB_AVAILABLE_IN_2_44
!void g_option_group_unref (GOptionGroup *group);
subroutine g_option_group_unref(group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: group
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_group_add_entries (GOptionGroup *group, const GOptionEntry *entries);
subroutine g_option_group_add_entries(group, entries) bind(c)
  import :: c_ptr
  type(c_ptr), value :: group
  type(c_ptr), value :: entries
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_group_set_translate_func (GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_group_set_translate_func(group, func, data, destroy_notify)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_option_group_set_translation_domain (GOptionGroup *group, const gchar *domain);
subroutine g_option_group_set_translation_domain(group, domain) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: domain
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/glib-autocleanups.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gvariant.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_variant_unref (GVariant *value);
subroutine g_variant_unref(value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_ref (GVariant *value);
function g_variant_ref(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_ref
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_ref_sink (GVariant *value);
function g_variant_ref_sink(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_ref_sink
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_floating (GVariant *value);
function g_variant_is_floating(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_is_floating
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_take_ref (GVariant *value);
function g_variant_take_ref(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_take_ref
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_get_type (GVariant *value);
function g_variant_get_type(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_type
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_variant_get_type_string (GVariant *value);
function g_variant_get_type_string(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_type_string
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_of_type (GVariant *value, const GVariantType *type);
function g_variant_is_of_type(value, type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_is_of_type
  type(c_ptr), value :: value
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_container (GVariant *value);
function g_variant_is_container(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_is_container
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantClass g_variant_classify (GVariant *value);
function g_variant_classify(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_classify
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_boolean (gboolean value);
function g_variant_new_boolean(value) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_variant_new_boolean
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_byte (guint8 value);
function g_variant_new_byte(value) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr) :: g_variant_new_byte
  integer(c_int8_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_int16 (gint16 value);
function g_variant_new_int16(value) bind(c)
  import :: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_int16
  integer(c_int16_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_uint16 (guint16 value);
function g_variant_new_uint16(value) bind(c)
  import :: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_uint16
  integer(c_int16_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_int32 (gint32 value);
function g_variant_new_int32(value) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_int32
  integer(c_int32_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_uint32 (guint32 value);
function g_variant_new_uint32(value) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_uint32
  integer(c_int32_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_int64 (gint64 value);
function g_variant_new_int64(value) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_int64
  integer(c_int64_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_uint64 (guint64 value);
function g_variant_new_uint64(value) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_uint64
  integer(c_int64_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_handle (gint32 value);
function g_variant_new_handle(value) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_handle
  integer(c_int32_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_double (gdouble value);
function g_variant_new_double(value) bind(c)
  import :: c_ptr, c_double
  type(c_ptr) :: g_variant_new_double
  real(c_double), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_string (const gchar *string);
function g_variant_new_string(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_2_38
!GVariant * g_variant_new_take_string (gchar *string);
function g_variant_new_take_string(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_take_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_object_path (const gchar *object_path);
function g_variant_new_object_path(object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_object_path
  character(kind=c_char), dimension(*) :: object_path
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_object_path (const gchar *string);
function g_variant_is_object_path(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_variant_is_object_path
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_signature (const gchar *signature);
function g_variant_new_signature(signature) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_signature
  character(kind=c_char), dimension(*) :: signature
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_signature (const gchar *string);
function g_variant_is_signature(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_variant_is_signature
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_variant (GVariant *value);
function g_variant_new_variant(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_new_variant
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_strv (const gchar * const *strv, gssize length);
function g_variant_new_strv(strv, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_strv
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_2_30
!GVariant * g_variant_new_objv (const gchar * const *strv, gssize length);
function g_variant_new_objv(strv, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_objv
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_bytestring (const gchar *string);
function g_variant_new_bytestring(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_bytestring
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_bytestring_array (const gchar * const *strv, gssize length);
function g_variant_new_bytestring_array(strv, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_bytestring_array
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_fixed_array (const GVariantType *element_type, gconstpointer elements, gsize n_elements, gsize element_size);
function g_variant_new_fixed_array(element_type, elements, n_elements,&
& element_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_fixed_array
  type(c_ptr), value :: element_type
  type(c_ptr), value :: elements
  integer(c_size_t), value :: n_elements
  integer(c_size_t), value :: element_size
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_get_boolean (GVariant *value);
function g_variant_get_boolean(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_get_boolean
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!guint8 g_variant_get_byte (GVariant *value);
function g_variant_get_byte(value) bind(c)
  import :: c_int8_t, c_ptr
  integer(c_int8_t) :: g_variant_get_byte
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gint16 g_variant_get_int16 (GVariant *value);
function g_variant_get_int16(value) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_int16
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_variant_get_uint16 (GVariant *value);
function g_variant_get_uint16(value) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_uint16
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_variant_get_int32 (GVariant *value);
function g_variant_get_int32(value) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_int32
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!guint32 g_variant_get_uint32 (GVariant *value);
function g_variant_get_uint32(value) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_uint32
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_variant_get_int64 (GVariant *value);
function g_variant_get_int64(value) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_int64
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!guint64 g_variant_get_uint64 (GVariant *value);
function g_variant_get_uint64(value) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_uint64
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_variant_get_handle (GVariant *value);
function g_variant_get_handle(value) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_handle
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_variant_get_double (GVariant *value);
function g_variant_get_double(value) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_variant_get_double
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_get_variant (GVariant *value);
function g_variant_get_variant(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_variant
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_variant_get_string (GVariant *value, gsize *length);
function g_variant_get_string(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_variant_dup_string (GVariant *value, gsize *length);
function g_variant_dup_string(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dup_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar ** g_variant_get_strv (GVariant *value, gsize *length);
function g_variant_get_strv(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_variant_dup_strv (GVariant *value, gsize *length);
function g_variant_dup_strv(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dup_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_2_30
!const gchar ** g_variant_get_objv (GVariant *value, gsize *length);
function g_variant_get_objv(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_objv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_variant_dup_objv (GVariant *value, gsize *length);
function g_variant_dup_objv(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dup_objv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_variant_get_bytestring (GVariant *value);
function g_variant_get_bytestring(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_bytestring
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_variant_dup_bytestring (GVariant *value, gsize *length);
function g_variant_dup_bytestring(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar ** g_variant_get_bytestring_array (GVariant *value, gsize *length);
function g_variant_get_bytestring_array(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_variant_dup_bytestring_array (GVariant *value, gsize *length);
function g_variant_dup_bytestring_array(value, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_maybe (const GVariantType *child_type, GVariant *child);
function g_variant_new_maybe(child_type, child) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_new_maybe
  type(c_ptr), value :: child_type
  type(c_ptr), value :: child
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_array (const GVariantType *child_type, GVariant * const *children, gsize n_children);
function g_variant_new_array(child_type, children, n_children) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_array
  type(c_ptr), value :: child_type
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_tuple (GVariant * const *children, gsize n_children);
function g_variant_new_tuple(children, n_children) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_tuple
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_dict_entry (GVariant *key, GVariant *value);
function g_variant_new_dict_entry(key, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_get_maybe (GVariant *value);
function g_variant_get_maybe(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_maybe
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_n_children (GVariant *value);
function g_variant_n_children(value) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_n_children
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_get_child_value (GVariant *value, gsize index_);
function g_variant_get_child_value(value, index_) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_child_value
  type(c_ptr), value :: value
  integer(c_size_t), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_lookup_value (GVariant *dictionary, const gchar *key, const GVariantType *expected_type);
function g_variant_lookup_value(dictionary, key, expected_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_lookup_value
  type(c_ptr), value :: dictionary
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: expected_type
end function

! GLIB_AVAILABLE_IN_ALL
!gconstpointer g_variant_get_fixed_array (GVariant *value, gsize *n_elements, gsize element_size);
function g_variant_get_fixed_array(value, n_elements, element_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_fixed_array
  type(c_ptr), value :: value
  type(c_ptr), value :: n_elements
  integer(c_size_t), value :: element_size
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_get_size (GVariant *value);
function g_variant_get_size(value) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_get_size
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gconstpointer g_variant_get_data (GVariant *value);
function g_variant_get_data(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_data
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_2_36
!GBytes * g_variant_get_data_as_bytes (GVariant *value);
function g_variant_get_data_as_bytes(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_data_as_bytes
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_store (GVariant *value, gpointer data);
subroutine g_variant_store(value, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar * g_variant_print (GVariant *value, gboolean type_annotate);
function g_variant_print(value, type_annotate) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_variant_print
  type(c_ptr), value :: value
  integer(c_int), value :: type_annotate
end function

! GLIB_AVAILABLE_IN_ALL
!GString * g_variant_print_string (GVariant *value, GString *string, gboolean type_annotate);
function g_variant_print_string(value, string, type_annotate) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_variant_print_string
  type(c_ptr), value :: value
  type(c_ptr), value :: string
  integer(c_int), value :: type_annotate
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_variant_hash (gconstpointer value);
function g_variant_hash(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_hash
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_equal (gconstpointer one, gconstpointer two);
function g_variant_equal(one, two) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_equal
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_get_normal_form (GVariant *value);
function g_variant_get_normal_form(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_get_normal_form
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_is_normal_form (GVariant *value);
function g_variant_is_normal_form(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_is_normal_form
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_byteswap (GVariant *value);
function g_variant_byteswap(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_byteswap
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_2_36
!GVariant * g_variant_new_from_bytes (const GVariantType *type, GBytes *bytes, gboolean trusted);
function g_variant_new_from_bytes(type, bytes, trusted) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_variant_new_from_bytes
  type(c_ptr), value :: type
  type(c_ptr), value :: bytes
  integer(c_int), value :: trusted
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_from_data (const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
function g_variant_new_from_data(type, data, size, trusted, notify, user_data)&
& bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr) :: g_variant_new_from_data
  type(c_ptr), value :: type
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  integer(c_int), value :: trusted
  type(c_funptr), value :: notify
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantIter * g_variant_iter_new (GVariant *value);
function g_variant_iter_new(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_iter_new
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_iter_init (GVariantIter *iter, GVariant *value);
function g_variant_iter_init(iter, value) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_init
  type(c_ptr), value :: iter
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantIter * g_variant_iter_copy (GVariantIter *iter);
function g_variant_iter_copy(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_iter_copy
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_iter_n_children (GVariantIter *iter);
function g_variant_iter_n_children(iter) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_n_children
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_iter_free (GVariantIter *iter);
subroutine g_variant_iter_free(iter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_iter_next_value (GVariantIter *iter);
function g_variant_iter_next_value(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_iter_next_value
  type(c_ptr), value :: iter
end function

! GLIB_DEPRECATED_IN_2_38_FOR(g_variant_parse_error_quark)
!GQuark g_variant_parser_get_error_quark (void);
function g_variant_parser_get_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_variant_parser_get_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_variant_parse_error_quark (void);
function g_variant_parse_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_variant_parse_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantBuilder * g_variant_builder_new (const GVariantType *type);
function g_variant_builder_new(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_builder_new
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_unref (GVariantBuilder *builder);
subroutine g_variant_builder_unref(builder) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariantBuilder * g_variant_builder_ref (GVariantBuilder *builder);
function g_variant_builder_ref(builder) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_builder_ref
  type(c_ptr), value :: builder
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_init (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_init(builder, type) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_builder_end (GVariantBuilder *builder);
function g_variant_builder_end(builder) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_builder_end
  type(c_ptr), value :: builder
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_clear (GVariantBuilder *builder);
subroutine g_variant_builder_clear(builder) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_open (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_open(builder, type) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_close (GVariantBuilder *builder);
subroutine g_variant_builder_close(builder) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_variant_builder_add_value (GVariantBuilder *builder, GVariant *value);
subroutine g_variant_builder_add_value(builder, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_va (const gchar *format_string, const gchar **endptr, va_list *app);
function g_variant_new_va(format_string, endptr, app) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_va
  character(kind=c_char), dimension(*) :: format_string
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: app
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_get_va (GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app);
subroutine g_variant_get_va(value, format_string, endptr, app) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: format_string
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: app
end subroutine

! GLIB_AVAILABLE_IN_2_34
!gboolean g_variant_check_format_string (GVariant *value, const gchar *format_string, gboolean copy_only);
function g_variant_check_format_string(value, format_string, copy_only) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_variant_check_format_string
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: format_string
  integer(c_int), value :: copy_only
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_parse (const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error);
function g_variant_parse(type, text, limit, endptr, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_parse
  type(c_ptr), value :: type
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: limit
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_variant_new_parsed_va (const gchar *format, va_list *app);
function g_variant_new_parsed_va(format, app) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_new_parsed_va
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: app
end function

! GLIB_AVAILABLE_IN_2_40
!gchar * g_variant_parse_error_print_context (GError *error, const gchar *source_str);
function g_variant_parse_error_print_context(error, source_str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_parse_error_print_context
  type(c_ptr), value :: error
  character(kind=c_char), dimension(*) :: source_str
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_variant_compare (gconstpointer one, gconstpointer two);
function g_variant_compare(one, two) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_compare
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

! GLIB_AVAILABLE_IN_2_40
!GVariantDict * g_variant_dict_new (GVariant *from_asv);
function g_variant_dict_new(from_asv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dict_new
  type(c_ptr), value :: from_asv
end function

! GLIB_AVAILABLE_IN_2_40
!void g_variant_dict_init (GVariantDict *dict, GVariant *from_asv);
subroutine g_variant_dict_init(dict, from_asv) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dict
  type(c_ptr), value :: from_asv
end subroutine

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_variant_dict_lookup_value (GVariantDict *dict, const gchar *key, const GVariantType *expected_type);
function g_variant_dict_lookup_value(dict, key, expected_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_dict_lookup_value
  type(c_ptr), value :: dict
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: expected_type
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_variant_dict_contains (GVariantDict *dict, const gchar *key);
function g_variant_dict_contains(dict, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_variant_dict_contains
  type(c_ptr), value :: dict
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_40
!void g_variant_dict_insert_value (GVariantDict *dict, const gchar *key, GVariant *value);
subroutine g_variant_dict_insert_value(dict, key, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: dict
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_variant_dict_remove (GVariantDict *dict, const gchar *key);
function g_variant_dict_remove(dict, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_variant_dict_remove
  type(c_ptr), value :: dict
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_40
!void g_variant_dict_clear (GVariantDict *dict);
subroutine g_variant_dict_clear(dict) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dict
end subroutine

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_variant_dict_end (GVariantDict *dict);
function g_variant_dict_end(dict) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dict_end
  type(c_ptr), value :: dict
end function

! GLIB_AVAILABLE_IN_2_40
!GVariantDict * g_variant_dict_ref (GVariantDict *dict);
function g_variant_dict_ref(dict) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_dict_ref
  type(c_ptr), value :: dict
end function

! GLIB_AVAILABLE_IN_2_40
!void g_variant_dict_unref (GVariantDict *dict);
subroutine g_variant_dict_unref(dict) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dict
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gsequence.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GSequence * g_sequence_new (GDestroyNotify data_destroy);
function g_sequence_new(data_destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_new
  type(c_funptr), value :: data_destroy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_free (GSequence *seq);
subroutine g_sequence_free(seq) bind(c)
  import :: c_ptr
  type(c_ptr), value :: seq
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_sequence_get_length (GSequence *seq);
function g_sequence_get_length(seq) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_get_length
  type(c_ptr), value :: seq
end function

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_foreach (GSequence *seq, GFunc func, gpointer user_data);
subroutine g_sequence_foreach(seq, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_foreach_range (GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data);
subroutine g_sequence_foreach_range(begin, end, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_sort (GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort(seq, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_sort_iter (GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_iter(seq, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! GLIB_AVAILABLE_IN_2_48
!gboolean g_sequence_is_empty (GSequence *seq);
function g_sequence_is_empty(seq) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_is_empty
  type(c_ptr), value :: seq
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
function g_sequence_get_begin_iter(seq) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_get_begin_iter
  type(c_ptr), value :: seq
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
function g_sequence_get_end_iter(seq) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_get_end_iter
  type(c_ptr), value :: seq
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq, gint pos);
function g_sequence_get_iter_at_pos(seq, pos) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_sequence_get_iter_at_pos
  type(c_ptr), value :: seq
  integer(c_int), value :: pos
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_append (GSequence *seq, gpointer data);
function g_sequence_append(seq, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_append
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_prepend (GSequence *seq, gpointer data);
function g_sequence_prepend(seq, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_prepend
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_insert_before (GSequenceIter *iter, gpointer data);
function g_sequence_insert_before(iter, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_insert_before
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_move (GSequenceIter *src, GSequenceIter *dest);
subroutine g_sequence_move(src, dest) bind(c)
  import :: c_ptr
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_swap (GSequenceIter *a, GSequenceIter *b);
subroutine g_sequence_swap(a, b) bind(c)
  import :: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_insert_sorted (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_insert_sorted(seq, data, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_sort_changed (GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_changed(iter, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_sort_changed_iter (GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
subroutine g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_remove (GSequenceIter *iter);
subroutine g_sequence_remove(iter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_remove_range (GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_remove_range(begin, end) bind(c)
  import :: c_ptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_move_range (GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_move_range(dest, begin, end) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_search (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_search(seq, data, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_search_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_search_iter(seq, data, iter_cmp, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_lookup (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_lookup(seq, data, cmp_func, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_lookup
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_lookup_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_lookup_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_sequence_get (GSequenceIter *iter);
function g_sequence_get(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_get
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!void g_sequence_set (GSequenceIter *iter, gpointer data);
subroutine g_sequence_set(iter, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
function g_sequence_iter_is_begin(iter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_is_begin
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_sequence_iter_is_end (GSequenceIter *iter);
function g_sequence_iter_is_end(iter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_is_end
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
function g_sequence_iter_next(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_iter_next
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
function g_sequence_iter_prev(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_iter_prev
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_sequence_iter_get_position (GSequenceIter *iter);
function g_sequence_iter_get_position(iter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_get_position
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_iter_move (GSequenceIter *iter, gint delta);
function g_sequence_iter_move(iter, delta) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_sequence_iter_move
  type(c_ptr), value :: iter
  integer(c_int), value :: delta
end function

! GLIB_AVAILABLE_IN_ALL
!GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);
function g_sequence_iter_get_sequence(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_iter_get_sequence
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_sequence_iter_compare (GSequenceIter *a, GSequenceIter *b);
function g_sequence_iter_compare(a, b) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_compare
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GLIB_AVAILABLE_IN_ALL
!GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin, GSequenceIter *end);
function g_sequence_range_get_midpoint(begin, end) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_sequence_range_get_midpoint
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtestutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!int g_strcmp0 (const char *str1, const char *str2);
function g_strcmp0(str1, str2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_strcmp0
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

! GLIB_AVAILABLE_IN_2_38
!gboolean g_test_subprocess (void);
function g_test_subprocess() bind(c)
  import :: c_int
  integer(c_int) :: g_test_subprocess
end function

! GLIB_AVAILABLE_IN_ALL
!int g_test_run (void);
function g_test_run() bind(c)
  import :: c_int
  integer(c_int) :: g_test_run
end function

! GLIB_AVAILABLE_IN_ALL
!void g_test_add_func (const char *testpath, GTestFunc test_func);
subroutine g_test_add_func(testpath, test_func) bind(c)
  import :: c_char, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_funptr), value :: test_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_add_data_func (const char *testpath, gconstpointer test_data, GTestDataFunc test_func);
subroutine g_test_add_data_func(testpath, test_data, test_func) bind(c)
  import :: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_ptr), value :: test_data
  type(c_funptr), value :: test_func
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_add_data_func_full (const char *testpath, gpointer test_data, GTestDataFunc test_func, GDestroyNotify data_free_func);
subroutine g_test_add_data_func_full(testpath, test_data, test_func,&
& data_free_func) bind(c)
  import :: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_ptr), value :: test_data
  type(c_funptr), value :: test_func
  type(c_funptr), value :: data_free_func
end subroutine

! GLIB_AVAILABLE_IN_2_68
!const char * g_test_get_path (void);
function g_test_get_path() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_test_get_path
end function

! GLIB_AVAILABLE_IN_2_30
!void g_test_fail (void);
subroutine g_test_fail() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_test_incomplete (const gchar *msg);
subroutine g_test_incomplete(msg) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: msg
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_test_skip (const gchar *msg);
subroutine g_test_skip(msg) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: msg
end subroutine

! GLIB_AVAILABLE_IN_2_38
!gboolean g_test_failed (void);
function g_test_failed() bind(c)
  import :: c_int
  integer(c_int) :: g_test_failed
end function

! GLIB_AVAILABLE_IN_2_38
!void g_test_set_nonfatal_assertions (void);
subroutine g_test_set_nonfatal_assertions() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_bug_base (const char *uri_pattern);
subroutine g_test_bug_base(uri_pattern) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: uri_pattern
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_bug (const char *bug_uri_snippet);
subroutine g_test_bug(bug_uri_snippet) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: bug_uri_snippet
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_test_summary (const char *summary);
subroutine g_test_summary(summary) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: summary
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_timer_start (void);
subroutine g_test_timer_start() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!double g_test_timer_elapsed (void);
function g_test_timer_elapsed() bind(c)
  import :: c_double
  real(c_double) :: g_test_timer_elapsed
end function

! GLIB_AVAILABLE_IN_ALL
!double g_test_timer_last (void);
function g_test_timer_last() bind(c)
  import :: c_double
  real(c_double) :: g_test_timer_last
end function

! GLIB_AVAILABLE_IN_ALL
!void g_test_queue_free (gpointer gfree_pointer);
subroutine g_test_queue_free(gfree_pointer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: gfree_pointer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_queue_destroy (GDestroyNotify destroy_func, gpointer destroy_data);
subroutine g_test_queue_destroy(destroy_func, destroy_data) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr), value :: destroy_func
  type(c_ptr), value :: destroy_data
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_test_trap_subprocess (const char *test_path, guint64 usec_timeout, GTestSubprocessFlags test_flags);
subroutine g_test_trap_subprocess(test_path, usec_timeout, test_flags) bind(c)
  import :: c_char, c_int64_t, c_int
  character(kind=c_char), dimension(*) :: test_path
  integer(c_int64_t), value :: usec_timeout
  integer(c_int), value :: test_flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_test_trap_has_passed (void);
function g_test_trap_has_passed() bind(c)
  import :: c_int
  integer(c_int) :: g_test_trap_has_passed
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_test_trap_reached_timeout (void);
function g_test_trap_reached_timeout() bind(c)
  import :: c_int
  integer(c_int) :: g_test_trap_reached_timeout
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_test_rand_int (void);
function g_test_rand_int() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_test_rand_int
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_test_rand_int_range (gint32 begin, gint32 end);
function g_test_rand_int_range(begin, end) bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_test_rand_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! GLIB_AVAILABLE_IN_ALL
!double g_test_rand_double (void);
function g_test_rand_double() bind(c)
  import :: c_double
  real(c_double) :: g_test_rand_double
end function

! GLIB_AVAILABLE_IN_ALL
!double g_test_rand_double_range (double range_start, double range_end);
function g_test_rand_double_range(range_start, range_end) bind(c)
  import :: c_double
  real(c_double) :: g_test_rand_double_range
  real(c_double), value :: range_start
  real(c_double), value :: range_end
end function

! GLIB_AVAILABLE_IN_ALL
!GTestCase* g_test_create_case (const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
function g_test_create_case(test_name, data_size, test_data, data_setup,&
& data_test, data_teardown) bind(c)
  import :: c_ptr, c_char, c_size_t, c_funptr
  type(c_ptr) :: g_test_create_case
  character(kind=c_char), dimension(*) :: test_name
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end function

! GLIB_AVAILABLE_IN_ALL
!GTestSuite* g_test_create_suite (const char *suite_name);
function g_test_create_suite(suite_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_test_create_suite
  character(kind=c_char), dimension(*) :: suite_name
end function

! GLIB_AVAILABLE_IN_ALL
!GTestSuite* g_test_get_root (void);
function g_test_get_root() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_test_get_root
end function

! GLIB_AVAILABLE_IN_ALL
!void g_test_suite_add (GTestSuite *suite, GTestCase *test_case);
subroutine g_test_suite_add(suite, test_case) bind(c)
  import :: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: test_case
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_suite_add_suite (GTestSuite *suite, GTestSuite *nestedsuite);
subroutine g_test_suite_add_suite(suite, nestedsuite) bind(c)
  import :: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: nestedsuite
end subroutine

! GLIB_AVAILABLE_IN_ALL
!int g_test_run_suite (GTestSuite *suite);
function g_test_run_suite(suite) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_test_run_suite
  type(c_ptr), value :: suite
end function

! GLIB_AVAILABLE_IN_2_70
!void g_test_case_free (GTestCase *test_case);
subroutine g_test_case_free(test_case) bind(c)
  import :: c_ptr
  type(c_ptr), value :: test_case
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_test_suite_free (GTestSuite *suite);
subroutine g_test_suite_free(suite) bind(c)
  import :: c_ptr
  type(c_ptr), value :: suite
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_trap_assertions (const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern);
subroutine g_test_trap_assertions(domain, file, line, func, assertion_flags,&
& pattern) bind(c)
  import :: c_char, c_int, c_int64_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  integer(c_int64_t), value :: assertion_flags
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_assertion_message (const char *domain, const char *file, int line, const char *func, const char *message) G_ANALYZER_NORETURN;
subroutine g_assertion_message(domain, file, line, func, message) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: message
end subroutine

! 
!G_NORETURN void g_assertion_message_expr (const char *domain, const char *file, int line, const char *func, const char *expr);
subroutine g_assertion_message_expr(domain, file, line, func, expr) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_assertion_message_cmpstr (const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2) G_ANALYZER_NORETURN;
subroutine g_assertion_message_cmpstr(domain, file, line, func, expr, arg1,&
& cmp, arg2) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  character(kind=c_char), dimension(*) :: arg1
  character(kind=c_char), dimension(*) :: cmp
  character(kind=c_char), dimension(*) :: arg2
end subroutine

! GLIB_AVAILABLE_IN_2_68
!void g_assertion_message_cmpstrv (const char *domain, const char *file, int line, const char *func, const char *expr, const char * const *arg1, const char * const *arg2, gsize first_wrong_idx) G_ANALYZER_NORETURN;
subroutine g_assertion_message_cmpstrv(domain, file, line, func, expr, arg1,&
& arg2, first_wrong_idx) bind(c)
  import :: c_char, c_int, c_size_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  character(kind=c_char), dimension(*) :: arg1
  character(kind=c_char), dimension(*) :: arg2
  integer(c_size_t), value :: first_wrong_idx
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_assertion_message_cmpnum (const char *domain, const char *file, int line, const char *func, const char *expr, long double arg1, const char *cmp, long double arg2, char numtype) G_ANALYZER_NORETURN;
subroutine g_assertion_message_cmpnum(domain, file, line, func, expr, arg1,&
& cmp, arg2, numtype) bind(c)
  import :: c_char, c_int, c_long_double
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  real(c_long_double), value :: arg1
  character(kind=c_char), dimension(*) :: cmp
  real(c_long_double), value :: arg2
  character(kind=c_char), value :: numtype
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_assertion_message_error (const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code) G_ANALYZER_NORETURN;
subroutine g_assertion_message_error(domain, file, line, func, expr, error,&
& error_domain, error_code) bind(c)
  import :: c_char, c_int, c_ptr, c_int32_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  type(c_ptr), value :: error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_add_vtable (const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
subroutine g_test_add_vtable(testpath, data_size, test_data, data_setup,&
& data_test, data_teardown) bind(c)
  import :: c_char, c_size_t, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const char* g_test_log_type_name (GTestLogType log_type);
function g_test_log_type_name(log_type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_test_log_type_name
  integer(c_int), value :: log_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTestLogBuffer* g_test_log_buffer_new (void);
function g_test_log_buffer_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_test_log_buffer_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_test_log_buffer_free (GTestLogBuffer *tbuffer);
subroutine g_test_log_buffer_free(tbuffer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tbuffer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_test_log_buffer_push (GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes);
subroutine g_test_log_buffer_push(tbuffer, n_bytes, bytes) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: tbuffer
  integer(c_int), value :: n_bytes
  type(c_ptr), value :: bytes
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTestLogMsg* g_test_log_buffer_pop (GTestLogBuffer *tbuffer);
function g_test_log_buffer_pop(tbuffer) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_test_log_buffer_pop
  type(c_ptr), value :: tbuffer
end function

! GLIB_AVAILABLE_IN_ALL
!void g_test_log_msg_free (GTestLogMsg *tmsg);
subroutine g_test_log_msg_free(tmsg) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tmsg
end subroutine

! 
!void g_test_log_set_fatal_handler (GTestLogFatalFunc log_func, gpointer user_data);
subroutine g_test_log_set_fatal_handler(log_func, user_data) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_expect_message (const gchar *log_domain, GLogLevelFlags log_level, const gchar *pattern);
subroutine g_test_expect_message(log_domain, log_level, pattern) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_assert_expected_messages_internal (const char *domain, const char *file, int line, const char *func);
subroutine g_test_assert_expected_messages_internal(domain, file, line, func)&
& bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
end subroutine

! GLIB_AVAILABLE_IN_2_38
!const gchar *g_test_get_dir (GTestFileType file_type);
function g_test_get_dir(file_type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_test_get_dir
  integer(c_int), value :: file_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gversion.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!const gchar * glib_check_version (guint required_major, guint required_minor, guint required_micro);
function glib_check_version(required_major, required_minor, required_micro)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: glib_check_version
  integer(c_int), value :: required_major
  integer(c_int), value :: required_minor
  integer(c_int), value :: required_micro
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gqueue.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQueue* g_queue_new (void);
function g_queue_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_free (GQueue *queue);
subroutine g_queue_free(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_free_full (GQueue *queue, GDestroyNotify free_func);
subroutine g_queue_free_full(queue, free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: free_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_init (GQueue *queue);
subroutine g_queue_init(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_clear (GQueue *queue);
subroutine g_queue_clear(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_queue_is_empty (GQueue *queue);
function g_queue_is_empty(queue) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_is_empty
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_2_60
!void g_queue_clear_full (GQueue *queue, GDestroyNotify free_func);
subroutine g_queue_clear_full(queue, free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: free_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_queue_get_length (GQueue *queue);
function g_queue_get_length(queue) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_get_length
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_reverse (GQueue *queue);
subroutine g_queue_reverse(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GQueue * g_queue_copy (GQueue *queue);
function g_queue_copy(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_copy
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_foreach (GQueue *queue, GFunc func, gpointer user_data);
subroutine g_queue_foreach(queue, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList * g_queue_find (GQueue *queue, gconstpointer data);
function g_queue_find(queue, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_find
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_queue_find_custom (GQueue *queue, gconstpointer data, GCompareFunc func);
function g_queue_find_custom(queue, data, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_queue_find_custom
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_sort (GQueue *queue, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_queue_sort(queue, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_head (GQueue *queue, gpointer data);
subroutine g_queue_push_head(queue, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_tail (GQueue *queue, gpointer data);
subroutine g_queue_push_tail(queue, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_nth (GQueue *queue, gpointer data, gint n);
subroutine g_queue_push_nth(queue, data, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  integer(c_int), value :: n
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_pop_head (GQueue *queue);
function g_queue_pop_head(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_pop_head
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_pop_tail (GQueue *queue);
function g_queue_pop_tail(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_pop_tail
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_pop_nth (GQueue *queue, guint n);
function g_queue_pop_nth(queue, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_peek_head (GQueue *queue);
function g_queue_peek_head(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_peek_head
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_peek_tail (GQueue *queue);
function g_queue_peek_tail(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_peek_tail
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_queue_peek_nth (GQueue *queue, guint n);
function g_queue_peek_nth(queue, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_queue_index (GQueue *queue, gconstpointer data);
function g_queue_index(queue, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_queue_remove (GQueue *queue, gconstpointer data);
function g_queue_remove(queue, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_remove
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_queue_remove_all (GQueue *queue, gconstpointer data);
function g_queue_remove_all(queue, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_remove_all
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_insert_before (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_before(queue, sibling, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_queue_insert_before_link (GQueue *queue, GList *sibling, GList *link_);
subroutine g_queue_insert_before_link(queue, sibling, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_insert_after (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_after(queue, sibling, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_queue_insert_after_link (GQueue *queue, GList *sibling, GList *link_);
subroutine g_queue_insert_after_link(queue, sibling, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_insert_sorted (GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_queue_insert_sorted(queue, data, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_head_link (GQueue *queue, GList *link_);
subroutine g_queue_push_head_link(queue, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_tail_link (GQueue *queue, GList *link_);
subroutine g_queue_push_tail_link(queue, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_push_nth_link (GQueue *queue, gint n, GList *link_);
subroutine g_queue_push_nth_link(queue, n, link_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: queue
  integer(c_int), value :: n
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_pop_head_link (GQueue *queue);
function g_queue_pop_head_link(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_pop_head_link
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_pop_tail_link (GQueue *queue);
function g_queue_pop_tail_link(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_pop_tail_link
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_pop_nth_link (GQueue *queue, guint n);
function g_queue_pop_nth_link(queue, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_peek_head_link (GQueue *queue);
function g_queue_peek_head_link(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_peek_head_link
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_peek_tail_link (GQueue *queue);
function g_queue_peek_tail_link(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_queue_peek_tail_link
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_queue_peek_nth_link (GQueue *queue, guint n);
function g_queue_peek_nth_link(queue, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_queue_link_index (GQueue *queue, GList *link_);
function g_queue_link_index(queue, link_) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_queue_link_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end function

! GLIB_AVAILABLE_IN_ALL
!void g_queue_unlink (GQueue *queue, GList *link_);
subroutine g_queue_unlink(queue, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_queue_delete_link (GQueue *queue, GList *link_);
subroutine g_queue_delete_link(queue, link_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gdataset.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_datalist_init (GData **datalist);
subroutine g_datalist_init(datalist) bind(c)
  import :: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_datalist_clear (GData **datalist);
subroutine g_datalist_clear(datalist) bind(c)
  import :: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_datalist_id_get_data (GData **datalist, GQuark key_id);
function g_datalist_id_get_data(datalist, key_id) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_get_data
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_datalist_id_set_data_full (GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_datalist_id_set_data_full(datalist, key_id, data, destroy_func)&
& bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! GLIB_AVAILABLE_IN_2_34
!gpointer g_datalist_id_dup_data (GData **datalist, GQuark key_id, GDuplicateFunc dup_func, gpointer user_data);
function g_datalist_id_dup_data(datalist, key_id, dup_func, user_data) bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr) :: g_datalist_id_dup_data
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
  type(c_funptr), value :: dup_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_datalist_id_replace_data (GData **datalist, GQuark key_id, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
function g_datalist_id_replace_data(datalist, key_id, oldval, newval, destroy,&
& old_destroy) bind(c)
  import :: c_int, c_ptr, c_int32_t, c_funptr
  integer(c_int) :: g_datalist_id_replace_data
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
  type(c_funptr), value :: destroy
  type(c_funptr), value :: old_destroy
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_datalist_id_remove_no_notify (GData **datalist, GQuark key_id);
function g_datalist_id_remove_no_notify(datalist, key_id) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_remove_no_notify
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_datalist_foreach (GData **datalist, GDataForeachFunc func, gpointer user_data);
subroutine g_datalist_foreach(datalist, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: datalist
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_datalist_set_flags (GData **datalist, guint flags);
subroutine g_datalist_set_flags(datalist, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_datalist_unset_flags (GData **datalist, guint flags);
subroutine g_datalist_unset_flags(datalist, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_datalist_get_flags (GData **datalist);
function g_datalist_get_flags(datalist) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_datalist_get_flags
  type(c_ptr), value :: datalist
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dataset_destroy (gconstpointer dataset_location);
subroutine g_dataset_destroy(dataset_location) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dataset_location
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_dataset_id_get_data (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_get_data(dataset_location, key_id) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_get_data
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_datalist_get_data (GData **datalist, const gchar *key);
function g_datalist_get_data(datalist, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_datalist_get_data
  type(c_ptr), value :: datalist
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dataset_id_set_data_full (gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_dataset_id_set_data_full(dataset_location, key_id, data,&
& destroy_func) bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_remove_no_notify(dataset_location, key_id) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_remove_no_notify
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dataset_foreach (gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
subroutine g_dataset_foreach(dataset_location, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: dataset_location
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gbytes.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_new (gconstpointer data, gsize size);
function g_bytes_new(data, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_bytes_new
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_new_take (gpointer data, gsize size);
function g_bytes_new_take(data, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_bytes_new_take
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_new_static (gconstpointer data, gsize size);
function g_bytes_new_static(data, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_bytes_new_static
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_new_with_free_func (gconstpointer data, gsize size, GDestroyNotify free_func, gpointer user_data);
function g_bytes_new_with_free_func(data, size, free_func, user_data) bind(c)
  import :: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_bytes_new_with_free_func
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  type(c_funptr), value :: free_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_new_from_bytes (GBytes *bytes, gsize offset, gsize length);
function g_bytes_new_from_bytes(bytes, offset, length) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_bytes_new_from_bytes
  type(c_ptr), value :: bytes
  integer(c_size_t), value :: offset
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gconstpointer g_bytes_get_data (GBytes *bytes, gsize *size);
function g_bytes_get_data(bytes, size) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_get_data
  type(c_ptr), value :: bytes
  type(c_ptr), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_bytes_get_size (GBytes *bytes);
function g_bytes_get_size(bytes) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_bytes_get_size
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes * g_bytes_ref (GBytes *bytes);
function g_bytes_ref(bytes) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_ref
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bytes_unref (GBytes *bytes);
subroutine g_bytes_unref(bytes) bind(c)
  import :: c_ptr
  type(c_ptr), value :: bytes
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_bytes_unref_to_data (GBytes *bytes, gsize *size);
function g_bytes_unref_to_data(bytes, size) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_unref_to_data
  type(c_ptr), value :: bytes
  type(c_ptr), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray * g_bytes_unref_to_array (GBytes *bytes);
function g_bytes_unref_to_array(bytes) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_unref_to_array
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bytes_hash (gconstpointer bytes);
function g_bytes_hash(bytes) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_bytes_hash
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bytes_equal (gconstpointer bytes1, gconstpointer bytes2);
function g_bytes_equal(bytes1, bytes2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_bytes_equal
  type(c_ptr), value :: bytes1
  type(c_ptr), value :: bytes2
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_bytes_compare (gconstpointer bytes1, gconstpointer bytes2);
function g_bytes_compare(bytes1, bytes2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_bytes_compare
  type(c_ptr), value :: bytes1
  type(c_ptr), value :: bytes2
end function

! GLIB_AVAILABLE_IN_2_70
!gconstpointer g_bytes_get_region (GBytes *bytes, gsize element_size, gsize offset, gsize n_elements);
function g_bytes_get_region(bytes, element_size, offset, n_elements) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_bytes_get_region
  type(c_ptr), value :: bytes
  integer(c_size_t), value :: element_size
  integer(c_size_t), value :: offset
  integer(c_size_t), value :: n_elements
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gscanner.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GScanner* g_scanner_new (const GScannerConfig *config_templ);
function g_scanner_new(config_templ) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_scanner_new
  type(c_ptr), value :: config_templ
end function

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_destroy (GScanner *scanner);
subroutine g_scanner_destroy(scanner) bind(c)
  import :: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_input_file (GScanner *scanner, gint input_fd);
subroutine g_scanner_input_file(scanner, input_fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: scanner
  integer(c_int), value :: input_fd
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_sync_file_offset (GScanner *scanner);
subroutine g_scanner_sync_file_offset(scanner) bind(c)
  import :: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_input_text (GScanner *scanner, const gchar *text, guint text_len);
subroutine g_scanner_input_text(scanner, text, text_len) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_len
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTokenType g_scanner_get_next_token (GScanner *scanner);
function g_scanner_get_next_token(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_get_next_token
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!GTokenType g_scanner_peek_next_token (GScanner *scanner);
function g_scanner_peek_next_token(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_peek_next_token
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!GTokenType g_scanner_cur_token (GScanner *scanner);
function g_scanner_cur_token(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_token
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_scanner_cur_line (GScanner *scanner);
function g_scanner_cur_line(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_line
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_scanner_cur_position (GScanner *scanner);
function g_scanner_cur_position(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_position
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_scanner_eof (GScanner *scanner);
function g_scanner_eof(scanner) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_eof
  type(c_ptr), value :: scanner
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_scanner_set_scope (GScanner *scanner, guint scope_id);
function g_scanner_set_scope(scanner, scope_id) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_scanner_set_scope
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_scope_add_symbol (GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value);
subroutine g_scanner_scope_add_symbol(scanner, scope_id, symbol, value) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_scope_remove_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
subroutine g_scanner_scope_remove_symbol(scanner, scope_id, symbol) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_scanner_scope_lookup_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
function g_scanner_scope_lookup_symbol(scanner, scope_id, symbol) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_scanner_scope_lookup_symbol
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end function

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_scope_foreach_symbol (GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data);
subroutine g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_scanner_lookup_symbol (GScanner *scanner, const gchar *symbol);
function g_scanner_lookup_symbol(scanner, symbol) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_scanner_lookup_symbol
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: symbol
end function

! GLIB_AVAILABLE_IN_ALL
!void g_scanner_unexp_token (GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error);
subroutine g_scanner_unexp_token(scanner, expected_token, identifier_spec,&
& symbol_spec, symbol_name, message, is_error) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: expected_token
  character(kind=c_char), dimension(*) :: identifier_spec
  character(kind=c_char), dimension(*) :: symbol_spec
  character(kind=c_char), dimension(*) :: symbol_name
  character(kind=c_char), dimension(*) :: message
  integer(c_int), value :: is_error
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gvarianttype.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_string_is_valid (const gchar *type_string);
function g_variant_type_string_is_valid(type_string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_variant_type_string_is_valid
  character(kind=c_char), dimension(*) :: type_string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_string_scan (const gchar *string, const gchar *limit, const gchar **endptr);
function g_variant_type_string_scan(string, limit, endptr) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_variant_type_string_scan
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: limit
  type(c_ptr), dimension(*) :: endptr
end function

! GLIB_AVAILABLE_IN_ALL
!void g_variant_type_free (GVariantType *type);
subroutine g_variant_type_free(type) bind(c)
  import :: c_ptr
  type(c_ptr), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_copy (const GVariantType *type);
function g_variant_type_copy(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_copy
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_new (const gchar *type_string);
function g_variant_type_new(type_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_type_new
  character(kind=c_char), dimension(*) :: type_string
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_type_get_string_length (const GVariantType *type);
function g_variant_type_get_string_length(type) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_get_string_length
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_variant_type_peek_string (const GVariantType *type);
function g_variant_type_peek_string(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_peek_string
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_variant_type_dup_string (const GVariantType *type);
function g_variant_type_dup_string(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_dup_string
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_definite (const GVariantType *type);
function g_variant_type_is_definite(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_definite
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_container (const GVariantType *type);
function g_variant_type_is_container(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_container
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_basic (const GVariantType *type);
function g_variant_type_is_basic(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_basic
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_maybe (const GVariantType *type);
function g_variant_type_is_maybe(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_maybe
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_array (const GVariantType *type);
function g_variant_type_is_array(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_array
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_tuple (const GVariantType *type);
function g_variant_type_is_tuple(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_tuple
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_dict_entry (const GVariantType *type);
function g_variant_type_is_dict_entry(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_dict_entry
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_variant (const GVariantType *type);
function g_variant_type_is_variant(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_variant
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_variant_type_hash (gconstpointer type);
function g_variant_type_hash(type) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_hash
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_equal (gconstpointer type1, gconstpointer type2);
function g_variant_type_equal(type1, type2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_equal
  type(c_ptr), value :: type1
  type(c_ptr), value :: type2
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_variant_type_is_subtype_of (const GVariantType *type, const GVariantType *supertype);
function g_variant_type_is_subtype_of(type, supertype) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_subtype_of
  type(c_ptr), value :: type
  type(c_ptr), value :: supertype
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_element (const GVariantType *type);
function g_variant_type_element(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_element
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_first (const GVariantType *type);
function g_variant_type_first(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_first
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_next (const GVariantType *type);
function g_variant_type_next(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_next
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_variant_type_n_items (const GVariantType *type);
function g_variant_type_n_items(type) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_n_items
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_key (const GVariantType *type);
function g_variant_type_key(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_key
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_value (const GVariantType *type);
function g_variant_type_value(type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_value
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_new_array (const GVariantType *element);
function g_variant_type_new_array(element) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_new_array
  type(c_ptr), value :: element
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_new_maybe (const GVariantType *element);
function g_variant_type_new_maybe(element) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_new_maybe
  type(c_ptr), value :: element
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_new_tuple (const GVariantType * const *items, gint length);
function g_variant_type_new_tuple(items, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_variant_type_new_tuple
  type(c_ptr), value :: items
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GVariantType * g_variant_type_new_dict_entry (const GVariantType *key, const GVariantType *value);
function g_variant_type_new_dict_entry(key, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_variant_type_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_variant_type_checked_ (const gchar *);
function g_variant_type_checked_() bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_variant_type_checked_
end function

! GLIB_AVAILABLE_IN_2_60
!gsize g_variant_type_string_get_depth_ (const gchar *type_string);
function g_variant_type_string_get_depth_(type_string) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_variant_type_string_get_depth_
  character(kind=c_char), dimension(*) :: type_string
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gchecksum.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gssize g_checksum_type_get_length (GChecksumType checksum_type);
function g_checksum_type_get_length(checksum_type) bind(c)
  import :: c_size_t, c_int
  integer(c_size_t) :: g_checksum_type_get_length
  integer(c_int), value :: checksum_type
end function

! GLIB_AVAILABLE_IN_ALL
!GChecksum * g_checksum_new (GChecksumType checksum_type);
function g_checksum_new(checksum_type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_checksum_new
  integer(c_int), value :: checksum_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_checksum_reset (GChecksum *checksum);
subroutine g_checksum_reset(checksum) bind(c)
  import :: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GChecksum * g_checksum_copy (const GChecksum *checksum);
function g_checksum_copy(checksum) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_checksum_copy
  type(c_ptr), value :: checksum
end function

! GLIB_AVAILABLE_IN_ALL
!void g_checksum_free (GChecksum *checksum);
subroutine g_checksum_free(checksum) bind(c)
  import :: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_checksum_update (GChecksum *checksum, const guchar *data, gssize length);
subroutine g_checksum_update(checksum, data, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: checksum
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_checksum_get_string (GChecksum *checksum);
function g_checksum_get_string(checksum) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_checksum_get_string
  type(c_ptr), value :: checksum
end function

! GLIB_AVAILABLE_IN_ALL
!void g_checksum_get_digest (GChecksum *checksum, guint8 *buffer, gsize *digest_len);
subroutine g_checksum_get_digest(checksum, buffer, digest_len) bind(c)
  import :: c_ptr
  type(c_ptr), value :: checksum
  type(c_ptr), value :: buffer
  type(c_ptr), value :: digest_len
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_compute_checksum_for_data (GChecksumType checksum_type, const guchar *data, gsize length);
function g_compute_checksum_for_data(checksum_type, data, length) bind(c)
  import :: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_data
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_compute_checksum_for_string (GChecksumType checksum_type, const gchar *str, gssize length);
function g_compute_checksum_for_string(checksum_type, str, length) bind(c)
  import :: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_string
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_2_34
!gchar *g_compute_checksum_for_bytes (GChecksumType checksum_type, GBytes *data);
function g_compute_checksum_for_bytes(checksum_type, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_compute_checksum_for_bytes
  integer(c_int), value :: checksum_type
  type(c_ptr), value :: data
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gqsort.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_qsort_with_data (gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_qsort_with_data(pbase, total_elems, size, compare_func, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_size_t, c_funptr
  type(c_ptr), value :: pbase
  integer(c_int), value :: total_elems
  integer(c_size_t), value :: size
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gversionmacros.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gprintf.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gint g_vprintf (gchar const *format, va_list args) G_GNUC_PRINTF(1, 0);
function g_vprintf(format, args) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_vfprintf (FILE *file, gchar const *format, va_list args) G_GNUC_PRINTF(2, 0);
function g_vfprintf(file, format, args) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_vfprintf
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_vsprintf (gchar *string, gchar const *format, va_list args) G_GNUC_PRINTF(2, 0);
function g_vsprintf(string, format, args) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_vsprintf
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_vasprintf (gchar **string, gchar const *format, va_list args) G_GNUC_PRINTF(2, 0);
function g_vasprintf(string, format, args) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_vasprintf
  type(c_ptr), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gstrfuncs.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gchar g_ascii_tolower (gchar c) G_GNUC_CONST;
function g_ascii_tolower(c) bind(c)
  import :: c_int8_t
  integer(kind=c_int8_t) :: g_ascii_tolower
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gchar g_ascii_toupper (gchar c) G_GNUC_CONST;
function g_ascii_toupper(c) bind(c)
  import :: c_int8_t
  integer(kind=c_int8_t) :: g_ascii_toupper
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_ascii_digit_value (gchar c) G_GNUC_CONST;
function g_ascii_digit_value(c) bind(c)
  import :: c_int, c_int8_t
  integer(c_int) :: g_ascii_digit_value
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_ascii_xdigit_value (gchar c) G_GNUC_CONST;
function g_ascii_xdigit_value(c) bind(c)
  import :: c_int, c_int8_t
  integer(c_int) :: g_ascii_xdigit_value
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strdelimit (gchar *string, const gchar *delimiters, gchar new_delimiter);
function g_strdelimit(string, delimiters, new_delimiter) bind(c)
  import :: c_ptr, c_char, c_int8_t
  type(c_ptr) :: g_strdelimit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  integer(kind=c_int8_t), value :: new_delimiter
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strcanon (gchar *string, const gchar *valid_chars, gchar substitutor);
function g_strcanon(string, valid_chars, substitutor) bind(c)
  import :: c_ptr, c_char, c_int8_t
  type(c_ptr) :: g_strcanon
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: valid_chars
  integer(kind=c_int8_t), value :: substitutor
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_strerror (gint errnum) G_GNUC_CONST;
function g_strerror(errnum) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_strerror
  integer(c_int), value :: errnum
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_strsignal (gint signum) G_GNUC_CONST;
function g_strsignal(signum) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_strsignal
  integer(c_int), value :: signum
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_strreverse (gchar *string);
function g_strreverse(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strreverse
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_strlcpy (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcpy(dest, src, dest_size) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_strlcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_strlcat (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcat(dest, src, dest_size) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_strlcat
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_strstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strstr_len(haystack, haystack_len, needle) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_strrstr (const gchar *haystack, const gchar *needle);
function g_strrstr(haystack, needle) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strrstr
  character(kind=c_char), dimension(*) :: haystack
  character(kind=c_char), dimension(*) :: needle
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_strrstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strrstr_len(haystack, haystack_len, needle) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strrstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_str_has_suffix (const gchar *str, const gchar *suffix);
function g_str_has_suffix(str, suffix) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_str_has_suffix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: suffix
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_str_has_prefix (const gchar *str, const gchar *prefix);
function g_str_has_prefix(str, prefix) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_str_has_prefix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: prefix
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_strtod (const gchar *nptr, gchar **endptr);
function g_strtod(nptr, endptr) bind(c)
  import :: c_double, c_char, c_ptr
  real(c_double) :: g_strtod
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_ascii_strtod (const gchar *nptr, gchar **endptr);
function g_ascii_strtod(nptr, endptr) bind(c)
  import :: c_double, c_char, c_ptr
  real(c_double) :: g_ascii_strtod
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
end function

! GLIB_AVAILABLE_IN_ALL
!guint64 g_ascii_strtoull (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoull(nptr, endptr, base) bind(c)
  import :: c_int64_t, c_char, c_ptr, c_int
  integer(c_int64_t) :: g_ascii_strtoull
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
  integer(c_int), value :: base
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_ascii_strtoll (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoll(nptr, endptr, base) bind(c)
  import :: c_int64_t, c_char, c_ptr, c_int
  integer(c_int64_t) :: g_ascii_strtoll
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
  integer(c_int), value :: base
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_ascii_dtostr (gchar *buffer, gint buf_len, gdouble d);
function g_ascii_dtostr(buffer, buf_len, d) bind(c)
  import :: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_dtostr
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  real(c_double), value :: d
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_ascii_formatd (gchar *buffer, gint buf_len, const gchar *format, gdouble d);
function g_ascii_formatd(buffer, buf_len, format, d) bind(c)
  import :: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_formatd
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  character(kind=c_char), dimension(*) :: format
  real(c_double), value :: d
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strchug (gchar *string);
function g_strchug(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strchug
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strchomp (gchar *string);
function g_strchomp(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strchomp
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_ascii_strcasecmp (const gchar *s1, const gchar *s2);
function g_ascii_strcasecmp(s1, s2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_ascii_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_ascii_strncasecmp (const gchar *s1, const gchar *s2, gsize n);
function g_ascii_strncasecmp(s1, s2, n) bind(c)
  import :: c_int, c_char, c_size_t
  integer(c_int) :: g_ascii_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_size_t), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_ascii_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strdown(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_ascii_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strup(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_str_is_ascii (const gchar *str);
function g_str_is_ascii(str) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_str_is_ascii
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_DEPRECATED
!gint g_strcasecmp (const gchar *s1, const gchar *s2);
function g_strcasecmp(s1, s2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! GLIB_DEPRECATED
!gint g_strncasecmp (const gchar *s1, const gchar *s2, guint n);
function g_strncasecmp(s1, s2, n) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_int), value :: n
end function

! GLIB_DEPRECATED
!gchar* g_strdown (gchar *string);
function g_strdown(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strdown
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_DEPRECATED
!gchar* g_strup (gchar *string);
function g_strup(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strup
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strdup (const gchar *str) G_GNUC_MALLOC;
function g_strdup(str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strdup
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strdup_vprintf (const gchar *format, va_list args) G_GNUC_PRINTF(1, 0) G_GNUC_MALLOC;
function g_strdup_vprintf(format, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strdup_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strndup (const gchar *str, gsize n) G_GNUC_MALLOC;
function g_strndup(str, n) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strndup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strnfill (gsize length, gchar fill_char) G_GNUC_MALLOC;
function g_strnfill(length, fill_char) bind(c)
  import :: c_ptr, c_size_t, c_int8_t
  type(c_ptr) :: g_strnfill
  integer(c_size_t), value :: length
  integer(kind=c_int8_t), value :: fill_char
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strcompress (const gchar *source) G_GNUC_MALLOC;
function g_strcompress(source) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strcompress
  character(kind=c_char), dimension(*) :: source
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strescape (const gchar *source, const gchar *exceptions) G_GNUC_MALLOC;
function g_strescape(source, exceptions) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strescape
  character(kind=c_char), dimension(*) :: source
  character(kind=c_char), dimension(*) :: exceptions
end function

! GLIB_DEPRECATED_IN_2_68_FOR (g_memdup2)
!gpointer g_memdup (gconstpointer mem, guint byte_size) G_GNUC_ALLOC_SIZE(2);
function g_memdup(mem, byte_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_memdup
  type(c_ptr), value :: mem
  integer(c_int), value :: byte_size
end function

! GLIB_AVAILABLE_IN_2_68
!gpointer g_memdup2 (gconstpointer mem, gsize byte_size) G_GNUC_ALLOC_SIZE(2);
function g_memdup2(mem, byte_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_memdup2
  type(c_ptr), value :: mem
  integer(c_size_t), value :: byte_size
end function

! GLIB_AVAILABLE_IN_ALL
!gchar** g_strsplit (const gchar *string, const gchar *delimiter, gint max_tokens);
function g_strsplit(string, delimiter, max_tokens) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiter
  integer(c_int), value :: max_tokens
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_strsplit_set (const gchar *string, const gchar *delimiters, gint max_tokens);
function g_strsplit_set(string, delimiters, max_tokens) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit_set
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  integer(c_int), value :: max_tokens
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strjoinv (const gchar *separator, gchar **str_array) G_GNUC_MALLOC;
function g_strjoinv(separator, str_array) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strjoinv
  character(kind=c_char), dimension(*) :: separator
  type(c_ptr), dimension(*) :: str_array
end function

! GLIB_AVAILABLE_IN_ALL
!void g_strfreev (gchar **str_array);
subroutine g_strfreev(str_array) bind(c)
  import :: c_ptr
  type(c_ptr), dimension(*) :: str_array
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar** g_strdupv (gchar **str_array);
function g_strdupv(str_array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_strdupv
  type(c_ptr), dimension(*) :: str_array
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_strv_length (gchar **str_array);
function g_strv_length(str_array) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_strv_length
  type(c_ptr), dimension(*) :: str_array
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_stpcpy (gchar *dest, const char *src);
function g_stpcpy(dest, src) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_stpcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
end function

! GLIB_AVAILABLE_IN_2_40
!gchar * g_str_to_ascii (const gchar *str, const gchar *from_locale);
function g_str_to_ascii(str, from_locale) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_str_to_ascii
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: from_locale
end function

! GLIB_AVAILABLE_IN_2_40
!gchar ** g_str_tokenize_and_fold (const gchar *string, const gchar *translit_locale, gchar ***ascii_alternates);
function g_str_tokenize_and_fold(string, translit_locale, ascii_alternates)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_str_tokenize_and_fold
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: translit_locale
  type(c_ptr), dimension(*) :: ascii_alternates
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_str_match_string (const gchar *search_term, const gchar *potential_hit, gboolean accept_alternates);
function g_str_match_string(search_term, potential_hit, accept_alternates)&
& bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_str_match_string
  character(kind=c_char), dimension(*) :: search_term
  character(kind=c_char), dimension(*) :: potential_hit
  integer(c_int), value :: accept_alternates
end function

! GLIB_AVAILABLE_IN_2_44
!gboolean g_strv_contains (const gchar * const *strv, const gchar *str);
function g_strv_contains(strv, str) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_strv_contains
  character(kind=c_char), dimension(*) :: strv
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_2_60
!gboolean g_strv_equal (const gchar * const *strv1, const gchar * const *strv2);
function g_strv_equal(strv1, strv2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_strv_equal
  character(kind=c_char), dimension(*) :: strv1
  character(kind=c_char), dimension(*) :: strv2
end function

! GLIB_AVAILABLE_IN_2_54
!GQuark g_number_parser_error_quark (void);
function g_number_parser_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_number_parser_error_quark
end function

! GLIB_AVAILABLE_IN_2_54
!gboolean g_ascii_string_to_signed (const gchar *str, guint base, gint64 min, gint64 max, gint64 *out_num, GError **error);
function g_ascii_string_to_signed(str, base, min, max, out_num, error) bind(c)
  import :: c_int, c_char, c_int64_t, c_ptr
  integer(c_int) :: g_ascii_string_to_signed
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: base
  integer(c_int64_t), value :: min
  integer(c_int64_t), value :: max
  type(c_ptr), value :: out_num
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_54
!gboolean g_ascii_string_to_unsigned (const gchar *str, guint base, guint64 min, guint64 max, guint64 *out_num, GError **error);
function g_ascii_string_to_unsigned(str, base, min, max, out_num, error)&
& bind(c)
  import :: c_int, c_char, c_int64_t, c_ptr
  integer(c_int) :: g_ascii_string_to_unsigned
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: base
  integer(c_int64_t), value :: min
  integer(c_int64_t), value :: max
  type(c_ptr), value :: out_num
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gspawn.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_spawn_error_quark (void);
function g_spawn_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_spawn_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_spawn_exit_error_quark (void);
function g_spawn_exit_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_spawn_exit_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_spawn_async (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error);
function g_spawn_async(working_directory, argv, envp, flags, child_setup,&
& user_data, child_pid, error) bind(c)
  import :: c_int, c_char, c_ptr, c_funptr
  integer(c_int) :: g_spawn_async
  character(kind=c_char), dimension(*) :: working_directory
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_spawn_async_with_pipes (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error);
function g_spawn_async_with_pipes(working_directory, argv, envp, flags,&
& child_setup, user_data, child_pid, standard_input, standard_output,&
& standard_error, error) bind(c)
  import :: c_int, c_char, c_ptr, c_funptr
  integer(c_int) :: g_spawn_async_with_pipes
  character(kind=c_char), dimension(*) :: working_directory
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: standard_input
  type(c_ptr), value :: standard_output
  type(c_ptr), value :: standard_error
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_68
!gboolean g_spawn_async_with_pipes_and_fds (const gchar *working_directory, const gchar * const *argv, const gchar * const *envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint stdin_fd, gint stdout_fd, gint stderr_fd, const gint *source_fds, const gint *target_fds, gsize n_fds, GPid *child_pid_out, gint *stdin_pipe_out, gint *stdout_pipe_out, gint *stderr_pipe_out, GError **error);
function g_spawn_async_with_pipes_and_fds(working_directory, argv, envp, flags,&
& child_setup, user_data, stdin_fd, stdout_fd, stderr_fd, source_fds,&
& target_fds, n_fds, child_pid_out, stdin_pipe_out, stdout_pipe_out,&
& stderr_pipe_out, error) bind(c)
  import :: c_int, c_char, c_funptr, c_ptr, c_size_t
  integer(c_int) :: g_spawn_async_with_pipes_and_fds
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  integer(c_int), value :: stdin_fd
  integer(c_int), value :: stdout_fd
  integer(c_int), value :: stderr_fd
  type(c_ptr), value :: source_fds
  type(c_ptr), value :: target_fds
  integer(c_size_t), value :: n_fds
  type(c_ptr), value :: child_pid_out
  type(c_ptr), value :: stdin_pipe_out
  type(c_ptr), value :: stdout_pipe_out
  type(c_ptr), value :: stderr_pipe_out
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_58
!gboolean g_spawn_async_with_fds (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint stdin_fd, gint stdout_fd, gint stderr_fd, GError **error);
function g_spawn_async_with_fds(working_directory, argv, envp, flags,&
& child_setup, user_data, child_pid, stdin_fd, stdout_fd, stderr_fd, error)&
& bind(c)
  import :: c_int, c_char, c_ptr, c_funptr
  integer(c_int) :: g_spawn_async_with_fds
  character(kind=c_char), dimension(*) :: working_directory
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  integer(c_int), value :: stdin_fd
  integer(c_int), value :: stdout_fd
  integer(c_int), value :: stderr_fd
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_spawn_sync (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
function g_spawn_sync(working_directory, argv, envp, flags, child_setup,&
& user_data, standard_output, standard_error, wait_status, error) bind(c)
  import :: c_int, c_char, c_ptr, c_funptr
  integer(c_int) :: g_spawn_sync
  character(kind=c_char), dimension(*) :: working_directory
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), dimension(*) :: standard_output
  type(c_ptr), dimension(*) :: standard_error
  type(c_ptr), value :: wait_status
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_spawn_command_line_sync (const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *wait_status, GError **error);
function g_spawn_command_line_sync(command_line, standard_output,&
& standard_error, wait_status, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_spawn_command_line_sync
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), dimension(*) :: standard_output
  type(c_ptr), dimension(*) :: standard_error
  type(c_ptr), value :: wait_status
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_spawn_command_line_async (const gchar *command_line, GError **error);
function g_spawn_command_line_async(command_line, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_spawn_command_line_async
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_70
!gboolean g_spawn_check_wait_status (gint wait_status, GError **error);
function g_spawn_check_wait_status(wait_status, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_spawn_check_wait_status
  integer(c_int), value :: wait_status
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_70_FOR(g_spawn_check_wait_status)
!gboolean g_spawn_check_exit_status (gint wait_status, GError **error);
function g_spawn_check_exit_status(wait_status, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_spawn_check_exit_status
  integer(c_int), value :: wait_status
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_spawn_close_pid (GPid pid);
subroutine g_spawn_close_pid(pid) bind(c)
  import :: c_int
  integer(c_int), value :: pid
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gfileutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_file_error_quark (void);
function g_file_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_file_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GFileError g_file_error_from_errno (gint err_no);
function g_file_error_from_errno(err_no) bind(c)
  import :: c_int
  integer(c_int) :: g_file_error_from_errno
  integer(c_int), value :: err_no
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_test (const gchar *filename, GFileTest test);
function g_file_test(filename, test) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_file_test
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: test
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_get_contents (const gchar *filename, gchar **contents, gsize *length, GError **error);
function g_file_get_contents(filename, contents, length, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_file_get_contents
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_contents (const gchar *filename, const gchar *contents, gssize length, GError **error);
function g_file_set_contents(filename, contents, length, error) bind(c)
  import :: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_file_set_contents
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_file_read_link (const gchar *filename, GError **error);
function g_file_read_link(filename, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_read_link
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_mkdtemp (gchar *tmpl);
function g_mkdtemp(tmpl) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_mkdtemp
  character(kind=c_char), dimension(*) :: tmpl
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_mkdtemp_full (gchar *tmpl, gint mode);
function g_mkdtemp_full(tmpl, mode) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_mkdtemp_full
  character(kind=c_char), dimension(*) :: tmpl
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_mkstemp (gchar *tmpl);
function g_mkstemp(tmpl) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_mkstemp
  character(kind=c_char), dimension(*) :: tmpl
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_mkstemp_full (gchar *tmpl, gint flags, gint mode);
function g_mkstemp_full(tmpl, flags, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_mkstemp_full
  character(kind=c_char), dimension(*) :: tmpl
  integer(c_int), value :: flags
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_file_open_tmp (const gchar *tmpl, gchar **name_used, GError **error);
function g_file_open_tmp(tmpl, name_used, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_file_open_tmp
  character(kind=c_char), dimension(*) :: tmpl
  type(c_ptr), dimension(*) :: name_used
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_dir_make_tmp (const gchar *tmpl, GError **error);
function g_dir_make_tmp(tmpl, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dir_make_tmp
  character(kind=c_char), dimension(*) :: tmpl
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_build_pathv (const gchar *separator, gchar **args) G_GNUC_MALLOC;
function g_build_pathv(separator, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_build_pathv
  character(kind=c_char), dimension(*) :: separator
  type(c_ptr), dimension(*) :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_build_filenamev (gchar **args) G_GNUC_MALLOC;
function g_build_filenamev(args) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_build_filenamev
  type(c_ptr), dimension(*) :: args
end function

! GLIB_AVAILABLE_IN_2_56
!gchar *g_build_filename_valist (const gchar *first_element, va_list *args) G_GNUC_MALLOC;
function g_build_filename_valist(first_element, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_build_filename_valist
  character(kind=c_char), dimension(*) :: first_element
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_mkdir_with_parents (const gchar *pathname, gint mode);
function g_mkdir_with_parents(pathname, mode) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_mkdir_with_parents
  character(kind=c_char), dimension(*) :: pathname
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_path_is_absolute (const gchar *file_name);
function g_path_is_absolute(file_name) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_path_is_absolute
  character(kind=c_char), dimension(*) :: file_name
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_path_skip_root (const gchar *file_name);
function g_path_skip_root(file_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_path_skip_root
  character(kind=c_char), dimension(*) :: file_name
end function

! GLIB_DEPRECATED_FOR(g_path_get_basename)
!const gchar *g_basename (const gchar *file_name);
function g_basename(file_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_basename
  character(kind=c_char), dimension(*) :: file_name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_get_current_dir (void);
function g_get_current_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_current_dir
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_path_get_basename (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_basename(file_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_path_get_basename
  character(kind=c_char), dimension(*) :: file_name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_path_get_dirname (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_dirname(file_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_path_get_dirname
  character(kind=c_char), dimension(*) :: file_name
end function

! GLIB_AVAILABLE_IN_2_58
!gchar *g_canonicalize_filename (const gchar *filename, const gchar *relative_to) G_GNUC_MALLOC;
function g_canonicalize_filename(filename, relative_to) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_canonicalize_filename
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: relative_to
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gi18n.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmem.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_free (gpointer mem);
subroutine g_free(mem) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_clear_pointer (gpointer *pp, GDestroyNotify destroy);
subroutine g_clear_pointer(pp, destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: pp
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc(n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_malloc
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc0(n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc(mem, n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc(n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc0(n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc(mem, n_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc_n(n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc0_n(n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc_n(mem, n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc_n(n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc0_n(n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_try_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc_n(mem, n_blocks, n_block_bytes) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! GLIB_AVAILABLE_IN_2_72
!gpointer g_aligned_alloc (gsize n_blocks, gsize n_block_bytes, gsize alignment) G_GNUC_WARN_UNUSED_RESULT G_GNUC_ALLOC_SIZE2(1,2);
function g_aligned_alloc(n_blocks, n_block_bytes, alignment) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_aligned_alloc
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
  integer(c_size_t), value :: alignment
end function

! GLIB_AVAILABLE_IN_2_72
!gpointer g_aligned_alloc0 (gsize n_blocks, gsize n_block_bytes, gsize alignment) G_GNUC_WARN_UNUSED_RESULT G_GNUC_ALLOC_SIZE2(1,2);
function g_aligned_alloc0(n_blocks, n_block_bytes, alignment) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_aligned_alloc0
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
  integer(c_size_t), value :: alignment
end function

! GLIB_AVAILABLE_IN_2_72
!void g_aligned_free (gpointer mem);
subroutine g_aligned_free(mem) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem
end subroutine

! GLIB_DEPRECATED_IN_2_46
!GLIB_AVAILABLE_STATIC_INLINE_IN_2_44 void g_mem_set_vtable (GMemVTable *vtable);
subroutine g_mem_set_vtable(vtable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: vtable
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gboolean g_mem_is_system_malloc (void);
function g_mem_is_system_malloc() bind(c)
  import :: c_int
  integer(c_int) :: g_mem_is_system_malloc
end function

! GLIB_DEPRECATED_IN_2_46
!void g_mem_profile (void);
subroutine g_mem_profile() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtypes.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gslice.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gpointer g_slice_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_slice_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc0(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc0
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_slice_copy (gsize block_size, gconstpointer mem_block) G_GNUC_ALLOC_SIZE(1);
function g_slice_copy(block_size, mem_block) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_slice_copy
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_ALL
!void g_slice_free1 (gsize block_size, gpointer mem_block);
subroutine g_slice_free1(block_size, mem_block) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_slice_free_chain_with_offset (gsize block_size, gpointer mem_chain, gsize next_offset);
subroutine g_slice_free_chain_with_offset(block_size, mem_chain, next_offset)&
& bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_chain
  integer(c_size_t), value :: next_offset
end subroutine

! GLIB_DEPRECATED_IN_2_34
!void g_slice_set_config (GSliceConfig ckey, gint64 value);
subroutine g_slice_set_config(ckey, value) bind(c)
  import :: c_int, c_int64_t
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: value
end subroutine

! GLIB_DEPRECATED_IN_2_34
!gint64 g_slice_get_config (GSliceConfig ckey);
function g_slice_get_config(ckey) bind(c)
  import :: c_int64_t, c_int
  integer(c_int64_t) :: g_slice_get_config
  integer(c_int), value :: ckey
end function

! GLIB_DEPRECATED_IN_2_34
!gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);
function g_slice_get_config_state(ckey, address, n_values) bind(c)
  import :: c_ptr, c_int, c_int64_t
  type(c_ptr) :: g_slice_get_config_state
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: address
  type(c_ptr), value :: n_values
end function

! GLIB_AVAILABLE_IN_ALL
!void g_slice_debug_tree_statistics (void);
subroutine g_slice_debug_tree_statistics() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/ghash.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GHashTable* g_hash_table_new (GHashFunc hash_func, GEqualFunc key_equal_func);
function g_hash_table_new(hash_func, key_equal_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end function

! GLIB_AVAILABLE_IN_ALL
!GHashTable* g_hash_table_new_full (GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func,&
& value_destroy_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new_full
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! GLIB_AVAILABLE_IN_2_72
!GHashTable *g_hash_table_new_similar (GHashTable *other_hash_table);
function g_hash_table_new_similar(other_hash_table) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_new_similar
  type(c_ptr), value :: other_hash_table
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_destroy (GHashTable *hash_table);
subroutine g_hash_table_destroy(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_insert (GHashTable *hash_table, gpointer key, gpointer value);
function g_hash_table_insert(hash_table, key, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_insert
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_replace (GHashTable *hash_table, gpointer key, gpointer value);
function g_hash_table_replace(hash_table, key, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_replace
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_add (GHashTable *hash_table, gpointer key);
function g_hash_table_add(hash_table, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_add
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_remove (GHashTable *hash_table, gconstpointer key);
function g_hash_table_remove(hash_table, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_remove
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_remove_all (GHashTable *hash_table);
subroutine g_hash_table_remove_all(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_steal (GHashTable *hash_table, gconstpointer key);
function g_hash_table_steal(hash_table, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_steal
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_58
!gboolean g_hash_table_steal_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *stolen_key, gpointer *stolen_value);
function g_hash_table_steal_extended(hash_table, lookup_key, stolen_key,&
& stolen_value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_steal_extended
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: stolen_key
  type(c_ptr), value :: stolen_value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_steal_all (GHashTable *hash_table);
subroutine g_hash_table_steal_all(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_hash_table_lookup (GHashTable *hash_table, gconstpointer key);
function g_hash_table_lookup(hash_table, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_lookup
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_contains (GHashTable *hash_table, gconstpointer key);
function g_hash_table_contains(hash_table, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_contains
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_lookup_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_lookup_extended
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_foreach (GHashTable *hash_table, GHFunc func, gpointer user_data);
subroutine g_hash_table_foreach(hash_table, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_hash_table_find (GHashTable *hash_table, GHRFunc predicate, gpointer user_data);
function g_hash_table_find(hash_table, predicate, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_find
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: predicate
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_hash_table_foreach_remove (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_remove(hash_table, func, user_data) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_remove
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_hash_table_foreach_steal (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_steal(hash_table, func, user_data) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_steal
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_hash_table_size (GHashTable *hash_table);
function g_hash_table_size(hash_table) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_size
  type(c_ptr), value :: hash_table
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_hash_table_get_keys (GHashTable *hash_table);
function g_hash_table_get_keys(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_get_keys
  type(c_ptr), value :: hash_table
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_hash_table_get_values (GHashTable *hash_table);
function g_hash_table_get_values(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_get_values
  type(c_ptr), value :: hash_table
end function

! GLIB_AVAILABLE_IN_2_40
!gpointer * g_hash_table_get_keys_as_array (GHashTable *hash_table, guint *length);
function g_hash_table_get_keys_as_array(hash_table, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_get_keys_as_array
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_iter_init (GHashTableIter *iter, GHashTable *hash_table);
subroutine g_hash_table_iter_init(iter, hash_table) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: hash_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hash_table_iter_next (GHashTableIter *iter, gpointer *key, gpointer *value);
function g_hash_table_iter_next(iter, key, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hash_table_iter_next
  type(c_ptr), value :: iter
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
function g_hash_table_iter_get_hash_table(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_iter_get_hash_table
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_iter_remove (GHashTableIter *iter);
subroutine g_hash_table_iter_remove(iter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GLIB_AVAILABLE_IN_2_30
!void g_hash_table_iter_replace (GHashTableIter *iter, gpointer value);
subroutine g_hash_table_iter_replace(iter, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_iter_steal (GHashTableIter *iter);
subroutine g_hash_table_iter_steal(iter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GHashTable* g_hash_table_ref (GHashTable *hash_table);
function g_hash_table_ref(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hash_table_ref
  type(c_ptr), value :: hash_table
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hash_table_unref (GHashTable *hash_table);
subroutine g_hash_table_unref(hash_table) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_str_equal (gconstpointer v1, gconstpointer v2);
function g_str_equal(v1, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_str_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_str_hash (gconstpointer v);
function g_str_hash(v) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_str_hash
  type(c_ptr), value :: v
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_int_equal (gconstpointer v1, gconstpointer v2);
function g_int_equal(v1, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_int_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_int_hash (gconstpointer v);
function g_int_hash(v) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_int_hash
  type(c_ptr), value :: v
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_int64_equal (gconstpointer v1, gconstpointer v2);
function g_int64_equal(v1, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_int64_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_int64_hash (gconstpointer v);
function g_int64_hash(v) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_int64_hash
  type(c_ptr), value :: v
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_double_equal (gconstpointer v1, gconstpointer v2);
function g_double_equal(v1, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_double_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_double_hash (gconstpointer v);
function g_double_hash(v) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_double_hash
  type(c_ptr), value :: v
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_direct_hash (gconstpointer v) G_GNUC_CONST;
function g_direct_hash(v) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_direct_hash
  type(c_ptr), value :: v
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_direct_equal (gconstpointer v1, gconstpointer v2) G_GNUC_CONST;
function g_direct_equal(v1, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_direct_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gdatetime.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_date_time_unref (GDateTime *datetime);
subroutine g_date_time_unref(datetime) bind(c)
  import :: c_ptr
  type(c_ptr), value :: datetime
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_ref (GDateTime *datetime);
function g_date_time_ref(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_ref
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_now (GTimeZone *tz);
function g_date_time_new_now(tz) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_new_now
  type(c_ptr), value :: tz
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_now_local (void);
function g_date_time_new_now_local() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_new_now_local
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_now_utc (void);
function g_date_time_new_now_utc() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_new_now_utc
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_from_unix_local (gint64 t);
function g_date_time_new_from_unix_local(t) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_local
  integer(c_int64_t), value :: t
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_from_unix_utc (gint64 t);
function g_date_time_new_from_unix_utc(t) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_utc
  integer(c_int64_t), value :: t
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_unix_local)
!GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
function g_date_time_new_from_timeval_local(tv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_local
  type(c_ptr), value :: tv
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_new_from_unix_utc)
!GDateTime * g_date_time_new_from_timeval_utc (const GTimeVal *tv);
function g_date_time_new_from_timeval_utc(tv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_utc
  type(c_ptr), value :: tv
end function

! GLIB_AVAILABLE_IN_2_56
!GDateTime * g_date_time_new_from_iso8601 (const gchar *text, GTimeZone *default_tz);
function g_date_time_new_from_iso8601(text, default_tz) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_date_time_new_from_iso8601
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: default_tz
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new (GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new(tz, year, month, day, hour, minute, seconds) bind(c)
  import :: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new
  type(c_ptr), value :: tz
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_local (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_local(year, month, day, hour, minute, seconds) bind(c)
  import :: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_local
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_new_utc (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_utc(year, month, day, hour, minute, seconds) bind(c)
  import :: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_utc
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! 
!GDateTime * g_date_time_add (GDateTime *datetime, GTimeSpan timespan);
function g_date_time_add(datetime, timespan) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_add
  type(c_ptr), value :: datetime
  integer(c_int64_t), value :: timespan
end function

! 
!GDateTime * g_date_time_add_years (GDateTime *datetime, gint years);
function g_date_time_add_years(datetime, years) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_years
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
end function

! 
!GDateTime * g_date_time_add_months (GDateTime *datetime, gint months);
function g_date_time_add_months(datetime, months) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_months
  type(c_ptr), value :: datetime
  integer(c_int), value :: months
end function

! 
!GDateTime * g_date_time_add_weeks (GDateTime *datetime, gint weeks);
function g_date_time_add_weeks(datetime, weeks) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_weeks
  type(c_ptr), value :: datetime
  integer(c_int), value :: weeks
end function

! 
!GDateTime * g_date_time_add_days (GDateTime *datetime, gint days);
function g_date_time_add_days(datetime, days) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_days
  type(c_ptr), value :: datetime
  integer(c_int), value :: days
end function

! 
!GDateTime * g_date_time_add_hours (GDateTime *datetime, gint hours);
function g_date_time_add_hours(datetime, hours) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_hours
  type(c_ptr), value :: datetime
  integer(c_int), value :: hours
end function

! 
!GDateTime * g_date_time_add_minutes (GDateTime *datetime, gint minutes);
function g_date_time_add_minutes(datetime, minutes) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_minutes
  type(c_ptr), value :: datetime
  integer(c_int), value :: minutes
end function

! 
!GDateTime * g_date_time_add_seconds (GDateTime *datetime, gdouble seconds);
function g_date_time_add_seconds(datetime, seconds) bind(c)
  import :: c_ptr, c_double
  type(c_ptr) :: g_date_time_add_seconds
  type(c_ptr), value :: datetime
  real(c_double), value :: seconds
end function

! 
!GDateTime * g_date_time_add_full (GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
function g_date_time_add_full(datetime, years, months, days, hours, minutes,&
& seconds) bind(c)
  import :: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_add_full
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
  integer(c_int), value :: months
  integer(c_int), value :: days
  integer(c_int), value :: hours
  integer(c_int), value :: minutes
  real(c_double), value :: seconds
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_compare (gconstpointer dt1, gconstpointer dt2);
function g_date_time_compare(dt1, dt2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_compare
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

! GLIB_AVAILABLE_IN_ALL
!GTimeSpan g_date_time_difference (GDateTime *end, GDateTime *begin);
function g_date_time_difference(end, begin) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_difference
  type(c_ptr), value :: end
  type(c_ptr), value :: begin
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_date_time_hash (gconstpointer datetime);
function g_date_time_hash(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_hash
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_time_equal (gconstpointer dt1, gconstpointer dt2);
function g_date_time_equal(dt1, dt2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_equal
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

! GLIB_AVAILABLE_IN_ALL
!void g_date_time_get_ymd (GDateTime *datetime, gint *year, gint *month, gint *day);
subroutine g_date_time_get_ymd(datetime, year, month, day) bind(c)
  import :: c_ptr
  type(c_ptr), value :: datetime
  type(c_ptr), value :: year
  type(c_ptr), value :: month
  type(c_ptr), value :: day
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_year (GDateTime *datetime);
function g_date_time_get_year(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_year
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_month (GDateTime *datetime);
function g_date_time_get_month(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_month
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_day_of_month (GDateTime *datetime);
function g_date_time_get_day_of_month(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_month
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_week_numbering_year (GDateTime *datetime);
function g_date_time_get_week_numbering_year(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_numbering_year
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_week_of_year (GDateTime *datetime);
function g_date_time_get_week_of_year(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_of_year
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_day_of_week (GDateTime *datetime);
function g_date_time_get_day_of_week(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_week
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_day_of_year (GDateTime *datetime);
function g_date_time_get_day_of_year(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_year
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_hour (GDateTime *datetime);
function g_date_time_get_hour(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_hour
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_minute (GDateTime *datetime);
function g_date_time_get_minute(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_minute
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_second (GDateTime *datetime);
function g_date_time_get_second(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_second
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_time_get_microsecond (GDateTime *datetime);
function g_date_time_get_microsecond(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_get_microsecond
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_date_time_get_seconds (GDateTime *datetime);
function g_date_time_get_seconds(datetime) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_date_time_get_seconds
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_date_time_to_unix (GDateTime *datetime);
function g_date_time_to_unix(datetime) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_to_unix
  type(c_ptr), value :: datetime
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_time_to_unix)
!gboolean g_date_time_to_timeval (GDateTime *datetime, GTimeVal *tv);
function g_date_time_to_timeval(datetime, tv) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_to_timeval
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tv
end function

! GLIB_AVAILABLE_IN_ALL
!GTimeSpan g_date_time_get_utc_offset (GDateTime *datetime);
function g_date_time_get_utc_offset(datetime) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_get_utc_offset
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_2_58
!GTimeZone * g_date_time_get_timezone (GDateTime *datetime);
function g_date_time_get_timezone(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_get_timezone
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_date_time_get_timezone_abbreviation (GDateTime *datetime);
function g_date_time_get_timezone_abbreviation(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_get_timezone_abbreviation
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_time_is_daylight_savings (GDateTime *datetime);
function g_date_time_is_daylight_savings(datetime) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_time_is_daylight_savings
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_to_timezone (GDateTime *datetime, GTimeZone *tz);
function g_date_time_to_timezone(datetime, tz) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_to_timezone
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tz
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_to_local (GDateTime *datetime);
function g_date_time_to_local(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_to_local
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!GDateTime * g_date_time_to_utc (GDateTime *datetime);
function g_date_time_to_utc(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_to_utc
  type(c_ptr), value :: datetime
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_date_time_format (GDateTime *datetime, const gchar *format) G_GNUC_MALLOC;
function g_date_time_format(datetime, format) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_date_time_format
  type(c_ptr), value :: datetime
  character(kind=c_char), dimension(*) :: format
end function

! GLIB_AVAILABLE_IN_2_62
!gchar * g_date_time_format_iso8601 (GDateTime *datetime) G_GNUC_MALLOC;
function g_date_time_format_iso8601(datetime) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_time_format_iso8601
  type(c_ptr), value :: datetime
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/ggettext.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!const gchar *g_strip_context (const gchar *msgid, const gchar *msgval) G_GNUC_FORMAT(1);
function g_strip_context(msgid, msgval) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_strip_context
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgval
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dgettext (const gchar *domain, const gchar *msgid) G_GNUC_FORMAT(2);
function g_dgettext(domain, msgid) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dcgettext (const gchar *domain, const gchar *msgid, gint category) G_GNUC_FORMAT(2);
function g_dcgettext(domain, msgid, category) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dcgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  integer(c_int), value :: category
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dngettext (const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n) G_GNUC_FORMAT(3);
function g_dngettext(domain, msgid, msgid_plural, n) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_dngettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgid_plural
  integer(c_long), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dpgettext (const gchar *domain, const gchar *msgctxtid, gsize msgidoffset) G_GNUC_FORMAT(2);
function g_dpgettext(domain, msgctxtid, msgidoffset) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_dpgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgctxtid
  integer(c_size_t), value :: msgidoffset
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dpgettext2 (const gchar *domain, const gchar *context, const gchar *msgid) G_GNUC_FORMAT(3);
function g_dpgettext2(domain, context, msgid) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dpgettext2
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: context
  character(kind=c_char), dimension(*) :: msgid
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gwin32.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gint g_win32_ftruncate (gint f, guint size);
function g_win32_ftruncate(f, size) bind(c)
  import :: c_int
  integer(c_int) :: g_win32_ftruncate
  integer(c_int), value :: f
  integer(c_int), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_win32_getlocale (void);
function g_win32_getlocale() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_win32_getlocale
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_win32_error_message (gint error);
function g_win32_error_message(error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_win32_error_message
  integer(c_int), value :: error
end function

! GLIB_DEPRECATED
!gchar* g_win32_get_package_installation_directory (const gchar *package, const gchar *dll_name);
function g_win32_get_package_installation_directory(package, dll_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_win32_get_package_installation_directory
  character(kind=c_char), dimension(*) :: package
  character(kind=c_char), dimension(*) :: dll_name
end function

! GLIB_DEPRECATED
!gchar* g_win32_get_package_installation_subdirectory (const gchar *package, const gchar *dll_name, const gchar *subdir);
function g_win32_get_package_installation_subdirectory(package, dll_name,&
& subdir) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_win32_get_package_installation_subdirectory
  character(kind=c_char), dimension(*) :: package
  character(kind=c_char), dimension(*) :: dll_name
  character(kind=c_char), dimension(*) :: subdir
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_win32_get_package_installation_directory_of_module (gpointer hmodule);
function g_win32_get_package_installation_directory_of_module(hmodule) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_win32_get_package_installation_directory_of_module
  type(c_ptr), value :: hmodule
end function

! GLIB_DEPRECATED_IN_2_44_FOR(g_win32_check_windows_version)
!guint g_win32_get_windows_version (void);
function g_win32_get_windows_version() bind(c)
  import :: c_int
  integer(c_int) :: g_win32_get_windows_version
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_win32_locale_filename_from_utf8 (const gchar *utf8filename);
function g_win32_locale_filename_from_utf8(utf8filename) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_win32_locale_filename_from_utf8
  character(kind=c_char), dimension(*) :: utf8filename
end function

! GLIB_AVAILABLE_IN_2_40
!gchar ** g_win32_get_command_line (void);
function g_win32_get_command_line() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_win32_get_command_line
end function

! GLIB_AVAILABLE_IN_2_44
!gboolean g_win32_check_windows_version (const gint major, const gint minor, const gint spver, const GWin32OSType os_type);
function g_win32_check_windows_version(major, minor, spver, os_type) bind(c)
  import :: c_int
  integer(c_int) :: g_win32_check_windows_version
  integer(c_int), value :: major
  integer(c_int), value :: minor
  integer(c_int), value :: spver
  integer(c_int), value :: os_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gbookmarkfile.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_bookmark_file_error_quark (void);
function g_bookmark_file_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_bookmark_file_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GBookmarkFile *g_bookmark_file_new (void);
function g_bookmark_file_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bookmark_file_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_free (GBookmarkFile *bookmark);
subroutine g_bookmark_file_free(bookmark) bind(c)
  import :: c_ptr
  type(c_ptr), value :: bookmark
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_load_from_file(bookmark, filename, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_load_from_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error);
function g_bookmark_file_load_from_data(bookmark, data, length, error) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_bookmark_file_load_from_data
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error);
function g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_load_from_data_dirs
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: full_path
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_to_data(bookmark, length, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bookmark_file_to_data
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_to_file(bookmark, filename, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_to_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_title (GBookmarkFile *bookmark, const gchar *uri, const gchar *title);
subroutine g_bookmark_file_set_title(bookmark, uri, title) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: title
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_title(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_title
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_description (GBookmarkFile *bookmark, const gchar *uri, const gchar *description);
subroutine g_bookmark_file_set_description(bookmark, uri, description) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: description
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_description(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_description
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type);
subroutine g_bookmark_file_set_mime_type(bookmark, uri, mime_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_mime_type(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_mime_type
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_groups (GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length);
subroutine g_bookmark_file_set_groups(bookmark, uri, groups, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), dimension(*) :: groups
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_add_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group);
subroutine g_bookmark_file_add_group(bookmark, uri, group) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_has_group(bookmark, uri, group, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
function g_bookmark_file_get_groups(bookmark, uri, length, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_groups
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_add_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec);
subroutine g_bookmark_file_add_application(bookmark, uri, name, exec) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_has_application(bookmark, uri, name, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error);
function g_bookmark_file_get_applications(bookmark, uri, length, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_applications
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_application_info)
!gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error);
function g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp,&
& error) bind(c)
  import :: c_int, c_ptr, c_char, c_long
  integer(c_int) :: g_bookmark_file_set_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
  integer(c_int), value :: count
  integer(c_long), value :: stamp
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_bookmark_file_set_application_info (GBookmarkFile *bookmark, const char *uri, const char *name, const char *exec, int count, GDateTime *stamp, GError **error);
function g_bookmark_file_set_application_info(bookmark, uri, name, exec, count,&
& stamp, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_set_application_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
  integer(c_int), value :: count
  type(c_ptr), value :: stamp
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_application_info)
!gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error);
function g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), dimension(*) :: exec
  type(c_ptr), value :: count
  type(c_ptr), value :: stamp
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_bookmark_file_get_application_info (GBookmarkFile *bookmark, const char *uri, const char *name, char **exec, unsigned int *count, GDateTime **stamp, GError **error);
function g_bookmark_file_get_application_info(bookmark, uri, name, exec, count,&
& stamp, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_application_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), dimension(*) :: exec
  type(c_ptr), value :: count
  type(c_ptr), value :: stamp
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_is_private (GBookmarkFile *bookmark, const gchar *uri, gboolean is_private);
subroutine g_bookmark_file_set_is_private(bookmark, uri, is_private) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_int), value :: is_private
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_is_private(bookmark, uri, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_is_private
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bookmark_file_set_icon (GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type);
subroutine g_bookmark_file_set_icon(bookmark, uri, href, mime_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: href
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error);
function g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_icon
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), dimension(*) :: href
  type(c_ptr), dimension(*) :: mime_type
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_added_date_time)
!void g_bookmark_file_set_added (GBookmarkFile *bookmark, const gchar *uri, time_t added);
subroutine g_bookmark_file_set_added(bookmark, uri, added) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: added
end subroutine

! GLIB_AVAILABLE_IN_2_66
!void g_bookmark_file_set_added_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *added);
subroutine g_bookmark_file_set_added_date_time(bookmark, uri, added) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: added
end subroutine

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_added_date_time)
!time_t g_bookmark_file_get_added (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_added(bookmark, uri, error) bind(c)
  import :: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_added
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GDateTime *g_bookmark_file_get_added_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
function g_bookmark_file_get_added_date_time(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_added_date_time
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_modified_date_time)
!void g_bookmark_file_set_modified (GBookmarkFile *bookmark, const gchar *uri, time_t modified);
subroutine g_bookmark_file_set_modified(bookmark, uri, modified) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: modified
end subroutine

! GLIB_AVAILABLE_IN_2_66
!void g_bookmark_file_set_modified_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *modified);
subroutine g_bookmark_file_set_modified_date_time(bookmark, uri, modified)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: modified
end subroutine

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_modified_date_time)
!time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_modified(bookmark, uri, error) bind(c)
  import :: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_modified
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GDateTime *g_bookmark_file_get_modified_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
function g_bookmark_file_get_modified_date_time(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_modified_date_time
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_set_visited_date_time)
!void g_bookmark_file_set_visited (GBookmarkFile *bookmark, const gchar *uri, time_t visited);
subroutine g_bookmark_file_set_visited(bookmark, uri, visited) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: visited
end subroutine

! GLIB_AVAILABLE_IN_2_66
!void g_bookmark_file_set_visited_date_time (GBookmarkFile *bookmark, const char *uri, GDateTime *visited);
subroutine g_bookmark_file_set_visited_date_time(bookmark, uri, visited)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: visited
end subroutine

! GLIB_DEPRECATED_IN_2_66_FOR(g_bookmark_file_get_visited_date_time)
!time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_visited(bookmark, uri, error) bind(c)
  import :: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_visited
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GDateTime *g_bookmark_file_get_visited_date_time (GBookmarkFile *bookmark, const char *uri, GError **error);
function g_bookmark_file_get_visited_date_time(bookmark, uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_visited_date_time
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark, const gchar *uri);
function g_bookmark_file_has_item(bookmark, uri) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
function g_bookmark_file_get_size(bookmark) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_bookmark_file_get_size
  type(c_ptr), value :: bookmark
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark, gsize *length);
function g_bookmark_file_get_uris(bookmark, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bookmark_file_get_uris
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_remove_group(bookmark, uri, group, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_remove_application(bookmark, uri, name, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_remove_item(bookmark, uri, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error);
function g_bookmark_file_move_item(bookmark, old_uri, new_uri, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_move_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: old_uri
  character(kind=c_char), dimension(*) :: new_uri
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gbase64.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gsize g_base64_encode_step (const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_step(in, len, break_lines, out, state, save) bind(c)
  import :: c_size_t, c_char, c_int, c_ptr
  integer(c_size_t) :: g_base64_encode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  integer(c_int), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_base64_encode_close (gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_close(break_lines, out, state, save) bind(c)
  import :: c_size_t, c_int, c_char, c_ptr
  integer(c_size_t) :: g_base64_encode_close
  integer(c_int), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_base64_encode (const guchar *data, gsize len) G_GNUC_MALLOC;
function g_base64_encode(data, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_base64_encode
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_base64_decode_step (const gchar *in, gsize len, guchar *out, gint *state, guint *save);
function g_base64_decode_step(in, len, out, state, save) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_base64_decode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! GLIB_AVAILABLE_IN_ALL
!guchar *g_base64_decode (const gchar *text, gsize *out_len) G_GNUC_MALLOC;
function g_base64_decode(text, out_len) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_base64_decode
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

! GLIB_AVAILABLE_IN_ALL
!guchar *g_base64_decode_inplace (gchar *text, gsize *out_len);
function g_base64_decode_inplace(text, out_len) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_base64_decode_inplace
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmain.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GLIB_AVAILABLE_TYPE_IN_2_72 GLIB_AVAILABLE_TYPE_IN_2_64 GMainContext *g_main_context_new (void);
function g_main_context_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_new
end function

! GLIB_AVAILABLE_IN_2_72
!GMainContext *g_main_context_new_with_flags (GMainContextFlags flags);
function g_main_context_new_with_flags(flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_main_context_new_with_flags
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_main_context_ref (GMainContext *context);
function g_main_context_ref(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_ref
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_unref (GMainContext *context);
subroutine g_main_context_unref(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_main_context_default (void);
function g_main_context_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_default
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_iteration (GMainContext *context, gboolean may_block);
function g_main_context_iteration(context, may_block) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_iteration
  type(c_ptr), value :: context
  integer(c_int), value :: may_block
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_pending (GMainContext *context);
function g_main_context_pending(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_pending
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_main_context_find_source_by_id (GMainContext *context, guint source_id);
function g_main_context_find_source_by_id(context, source_id) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_main_context_find_source_by_id
  type(c_ptr), value :: context
  integer(c_int), value :: source_id
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_main_context_find_source_by_user_data (GMainContext *context, gpointer user_data);
function g_main_context_find_source_by_user_data(context, user_data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_find_source_by_user_data
  type(c_ptr), value :: context
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context, GSourceFuncs *funcs, gpointer user_data);
function g_main_context_find_source_by_funcs_user_data(context, funcs,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_main_context_find_source_by_funcs_user_data
  type(c_ptr), value :: context
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_wakeup (GMainContext *context);
subroutine g_main_context_wakeup(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_acquire (GMainContext *context);
function g_main_context_acquire(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_acquire
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_release (GMainContext *context);
subroutine g_main_context_release(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_is_owner (GMainContext *context);
function g_main_context_is_owner(context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_is_owner
  type(c_ptr), value :: context
end function

! GLIB_DEPRECATED_IN_2_58_FOR(g_main_context_is_owner)
!gboolean g_main_context_wait (GMainContext *context, GCond *cond, GMutex *mutex);
function g_main_context_wait(context, cond, mutex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_wait
  type(c_ptr), value :: context
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_prepare (GMainContext *context, gint *priority);
function g_main_context_prepare(context, priority) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_prepare
  type(c_ptr), value :: context
  type(c_ptr), value :: priority
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_main_context_query (GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds);
function g_main_context_query(context, max_priority, timeout_, fds, n_fds)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_query
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: timeout_
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_context_check (GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds);
function g_main_context_check(context, max_priority, fds, n_fds) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_context_check
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_dispatch (GMainContext *context);
subroutine g_main_context_dispatch(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_set_poll_func (GMainContext *context, GPollFunc func);
subroutine g_main_context_set_poll_func(context, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GPollFunc g_main_context_get_poll_func (GMainContext *context);
function g_main_context_get_poll_func(context) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr) :: g_main_context_get_poll_func
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_add_poll (GMainContext *context, GPollFD *fd, gint priority);
subroutine g_main_context_add_poll(context, fd, priority) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
  integer(c_int), value :: priority
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_remove_poll (GMainContext *context, GPollFD *fd);
subroutine g_main_context_remove_poll(context, fd) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_main_depth (void);
function g_main_depth() bind(c)
  import :: c_int
  integer(c_int) :: g_main_depth
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_main_current_source (void);
function g_main_current_source() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_current_source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_push_thread_default (GMainContext *context);
subroutine g_main_context_push_thread_default(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_pop_thread_default (GMainContext *context);
subroutine g_main_context_pop_thread_default(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_main_context_get_thread_default (void);
function g_main_context_get_thread_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_get_thread_default
end function

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_main_context_ref_thread_default (void);
function g_main_context_ref_thread_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_context_ref_thread_default
end function

! GLIB_AVAILABLE_IN_ALL
!GLIB_AVAILABLE_STATIC_INLINE_IN_2_64 GLIB_AVAILABLE_STATIC_INLINE_IN_2_64 GMainLoop *g_main_loop_new (GMainContext *context, gboolean is_running);
function g_main_loop_new(context, is_running) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_main_loop_new
  type(c_ptr), value :: context
  integer(c_int), value :: is_running
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_loop_run (GMainLoop *loop);
subroutine g_main_loop_run(loop) bind(c)
  import :: c_ptr
  type(c_ptr), value :: loop
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_main_loop_quit (GMainLoop *loop);
subroutine g_main_loop_quit(loop) bind(c)
  import :: c_ptr
  type(c_ptr), value :: loop
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GMainLoop *g_main_loop_ref (GMainLoop *loop);
function g_main_loop_ref(loop) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_loop_ref
  type(c_ptr), value :: loop
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_loop_unref (GMainLoop *loop);
subroutine g_main_loop_unref(loop) bind(c)
  import :: c_ptr
  type(c_ptr), value :: loop
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_main_loop_is_running (GMainLoop *loop);
function g_main_loop_is_running(loop) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_main_loop_is_running
  type(c_ptr), value :: loop
end function

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_main_loop_get_context (GMainLoop *loop);
function g_main_loop_get_context(loop) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_main_loop_get_context
  type(c_ptr), value :: loop
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_source_new (GSourceFuncs *source_funcs, guint struct_size);
function g_source_new(source_funcs, struct_size) bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_source_new
  type(c_funptr), value :: source_funcs
  integer(c_int), value :: struct_size
end function

! GLIB_AVAILABLE_IN_2_64
!void g_source_set_dispose_function (GSource *source, GSourceDisposeFunc dispose);
subroutine g_source_set_dispose_function(source, dispose) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: dispose
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSource *g_source_ref (GSource *source);
function g_source_ref(source) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_source_ref
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_unref (GSource *source);
subroutine g_source_unref(source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_source_attach (GSource *source, GMainContext *context);
function g_source_attach(source, context) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_attach
  type(c_ptr), value :: source
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_destroy (GSource *source);
subroutine g_source_destroy(source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_priority (GSource *source, gint priority);
subroutine g_source_set_priority(source, priority) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: priority
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_source_get_priority (GSource *source);
function g_source_get_priority(source) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_get_priority
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_can_recurse (GSource *source, gboolean can_recurse);
subroutine g_source_set_can_recurse(source, can_recurse) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: can_recurse
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_source_get_can_recurse (GSource *source);
function g_source_get_can_recurse(source) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_get_can_recurse
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_source_get_id (GSource *source);
function g_source_get_id(source) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_get_id
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!GMainContext *g_source_get_context (GSource *source);
function g_source_get_context(source) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_source_get_context
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_callback (GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify);
subroutine g_source_set_callback(source, func, data, notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_funcs (GSource *source, GSourceFuncs *funcs);
subroutine g_source_set_funcs(source, funcs) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: funcs
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_source_is_destroyed (GSource *source);
function g_source_is_destroyed(source) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_is_destroyed
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_name (GSource *source, const char *name);
subroutine g_source_set_name(source, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_source_set_static_name (GSource *source, const char *name);
subroutine g_source_set_static_name(source, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const char * g_source_get_name (GSource *source);
function g_source_get_name(source) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_source_get_name
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_name_by_id (guint tag, const char *name);
subroutine g_source_set_name_by_id(tag, name) bind(c)
  import :: c_int, c_char
  integer(c_int), value :: tag
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_source_set_ready_time (GSource *source, gint64 ready_time);
subroutine g_source_set_ready_time(source, ready_time) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr), value :: source
  integer(c_int64_t), value :: ready_time
end subroutine

! GLIB_AVAILABLE_IN_2_36
!gint64 g_source_get_ready_time (GSource *source);
function g_source_get_ready_time(source) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_source_get_ready_time
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_2_36
!gpointer g_source_add_unix_fd (GSource *source, gint fd, GIOCondition events);
function g_source_add_unix_fd(source, fd, events) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_source_add_unix_fd
  type(c_ptr), value :: source
  integer(c_int), value :: fd
  integer(c_int), value :: events
end function

! GLIB_AVAILABLE_IN_2_36
!void g_source_modify_unix_fd (GSource *source, gpointer tag, GIOCondition new_events);
subroutine g_source_modify_unix_fd(source, tag, new_events) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: source
  type(c_ptr), value :: tag
  integer(c_int), value :: new_events
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_source_remove_unix_fd (GSource *source, gpointer tag);
subroutine g_source_remove_unix_fd(source, tag) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: tag
end subroutine

! GLIB_AVAILABLE_IN_2_36
!GIOCondition g_source_query_unix_fd (GSource *source, gpointer tag);
function g_source_query_unix_fd(source, tag) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_query_unix_fd
  type(c_ptr), value :: source
  type(c_ptr), value :: tag
end function

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_callback_indirect (GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs);
subroutine g_source_set_callback_indirect(source, callback_data,&
& callback_funcs) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: callback_data
  type(c_ptr), value :: callback_funcs
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_add_poll (GSource *source, GPollFD *fd);
subroutine g_source_add_poll(source, fd) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_remove_poll (GSource *source, GPollFD *fd);
subroutine g_source_remove_poll(source, fd) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_add_child_source (GSource *source, GSource *child_source);
subroutine g_source_add_child_source(source, child_source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: child_source
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_remove_child_source (GSource *source, GSource *child_source);
subroutine g_source_remove_child_source(source, child_source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: child_source
end subroutine

! GLIB_DEPRECATED_IN_2_28_FOR(g_source_get_time)
!void g_source_get_current_time (GSource *source, GTimeVal *timeval);
subroutine g_source_get_current_time(source, timeval) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: timeval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint64 g_source_get_time (GSource *source);
function g_source_get_time(source) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_source_get_time
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_idle_source_new (void);
function g_idle_source_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_idle_source_new
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_child_watch_source_new (GPid pid);
function g_child_watch_source_new(pid) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_child_watch_source_new
  integer(c_int), value :: pid
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_timeout_source_new (guint interval);
function g_timeout_source_new(interval) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new
  integer(c_int), value :: interval
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_timeout_source_new_seconds (guint interval);
function g_timeout_source_new_seconds(interval) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new_seconds
  integer(c_int), value :: interval
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_get_real_time)
!void g_get_current_time (GTimeVal *result);
subroutine g_get_current_time(result) bind(c)
  import :: c_ptr
  type(c_ptr), value :: result
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint64 g_get_monotonic_time (void);
function g_get_monotonic_time() bind(c)
  import :: c_int64_t
  integer(c_int64_t) :: g_get_monotonic_time
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_get_real_time (void);
function g_get_real_time() bind(c)
  import :: c_int64_t
  integer(c_int64_t) :: g_get_real_time
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_source_remove (guint tag);
function g_source_remove(tag) bind(c)
  import :: c_int
  integer(c_int) :: g_source_remove
  integer(c_int), value :: tag
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_source_remove_by_user_data (gpointer user_data);
function g_source_remove_by_user_data(user_data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_source_remove_by_user_data
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs, gpointer user_data);
function g_source_remove_by_funcs_user_data(funcs, user_data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_source_remove_by_funcs_user_data
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_56
!void g_clear_handle_id (guint *tag_ptr, GClearHandleFunc clear_func);
subroutine g_clear_handle_id(tag_ptr, clear_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: tag_ptr
  type(c_funptr), value :: clear_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_timeout_add_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_full(priority, interval, function, data, notify) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_timeout_add (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add(interval, function, data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_timeout_add_seconds_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_seconds_full(priority, interval, function, data, notify)&
& bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_timeout_add_seconds (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add_seconds(interval, function, data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_child_watch_add_full (gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
function g_child_watch_add_full(priority, pid, function, data, notify) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_child_watch_add (GPid pid, GChildWatchFunc function, gpointer data);
function g_child_watch_add(pid, function, data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_idle_add (GSourceFunc function, gpointer data);
function g_idle_add(function, data) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_idle_add_full (gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_idle_add_full(priority, function, data, notify) bind(c)
  import :: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add_full
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_idle_remove_by_data (gpointer data);
function g_idle_remove_by_data(data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_idle_remove_by_data
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_invoke_full (GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
subroutine g_main_context_invoke_full(context, priority, function, data,&
& notify) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: context
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_main_context_invoke (GMainContext *context, GSourceFunc function, gpointer data);
subroutine g_main_context_invoke(context, function, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gpoll.h
!--------------------------------------------------
! 
!gint g_poll (GPollFD *fds, guint nfds, gint timeout);
function g_poll(fds, nfds, timeout) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_poll
  type(c_ptr), value :: fds
  integer(c_int), value :: nfds
  integer(c_int), value :: timeout
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gstrvbuilder.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_68
!GStrvBuilder *g_strv_builder_new (void);
function g_strv_builder_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_strv_builder_new
end function

! GLIB_AVAILABLE_IN_2_68
!void g_strv_builder_unref (GStrvBuilder *builder);
subroutine g_strv_builder_unref(builder) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GLIB_AVAILABLE_IN_2_68
!GStrvBuilder *g_strv_builder_ref (GStrvBuilder *builder);
function g_strv_builder_ref(builder) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_strv_builder_ref
  type(c_ptr), value :: builder
end function

! GLIB_AVAILABLE_IN_2_68
!void g_strv_builder_add (GStrvBuilder *builder, const char *value);
subroutine g_strv_builder_add(builder, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_strv_builder_addv (GStrvBuilder *builder, const char **value);
subroutine g_strv_builder_addv(builder, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), dimension(*) :: value
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gbitlock.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_bit_lock (volatile gint *address, gint lock_bit);
subroutine g_bit_lock(address, lock_bit) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_bit_trylock (volatile gint *address, gint lock_bit);
function g_bit_trylock(address, lock_bit) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_bit_trylock
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bit_unlock (volatile gint *address, gint lock_bit);
subroutine g_bit_unlock(address, lock_bit) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_pointer_bit_lock (volatile void *address, gint lock_bit);
subroutine g_pointer_bit_lock(address, lock_bit) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pointer_bit_trylock (volatile void *address, gint lock_bit);
function g_pointer_bit_trylock(address, lock_bit) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pointer_bit_trylock
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end function

! GLIB_AVAILABLE_IN_ALL
!void g_pointer_bit_unlock (volatile void *address, gint lock_bit);
subroutine g_pointer_bit_unlock(address, lock_bit) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/grcbox.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_58
!gpointer g_rc_box_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_rc_box_alloc(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_rc_box_alloc
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_rc_box_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_rc_box_alloc0(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_rc_box_alloc0
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_rc_box_dup (gsize block_size, gconstpointer mem_block) G_GNUC_ALLOC_SIZE(1);
function g_rc_box_dup(block_size, mem_block) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_rc_box_dup
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_rc_box_acquire (gpointer mem_block);
function g_rc_box_acquire(mem_block) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_rc_box_acquire
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_2_58
!void g_rc_box_release (gpointer mem_block);
subroutine g_rc_box_release(mem_block) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_block
end subroutine

! GLIB_AVAILABLE_IN_2_58
!void g_rc_box_release_full (gpointer mem_block, GDestroyNotify clear_func);
subroutine g_rc_box_release_full(mem_block, clear_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: mem_block
  type(c_funptr), value :: clear_func
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gsize g_rc_box_get_size (gpointer mem_block);
function g_rc_box_get_size(mem_block) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_rc_box_get_size
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_atomic_rc_box_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_atomic_rc_box_alloc(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_atomic_rc_box_alloc
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_atomic_rc_box_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_atomic_rc_box_alloc0(block_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_atomic_rc_box_alloc0
  integer(c_size_t), value :: block_size
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_atomic_rc_box_dup (gsize block_size, gconstpointer mem_block) G_GNUC_ALLOC_SIZE(1);
function g_atomic_rc_box_dup(block_size, mem_block) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_atomic_rc_box_dup
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_atomic_rc_box_acquire (gpointer mem_block);
function g_atomic_rc_box_acquire(mem_block) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_atomic_rc_box_acquire
  type(c_ptr), value :: mem_block
end function

! GLIB_AVAILABLE_IN_2_58
!void g_atomic_rc_box_release (gpointer mem_block);
subroutine g_atomic_rc_box_release(mem_block) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_block
end subroutine

! GLIB_AVAILABLE_IN_2_58
!void g_atomic_rc_box_release_full (gpointer mem_block, GDestroyNotify clear_func);
subroutine g_atomic_rc_box_release_full(mem_block, clear_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: mem_block
  type(c_funptr), value :: clear_func
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gsize g_atomic_rc_box_get_size (gpointer mem_block);
function g_atomic_rc_box_get_size(mem_block) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_atomic_rc_box_get_size
  type(c_ptr), value :: mem_block
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmacros.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmessages.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gsize g_printf_string_upper_bound (const gchar* format, va_list args) G_GNUC_PRINTF(1, 0);
function g_printf_string_upper_bound(format, args) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_printf_string_upper_bound
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_log_set_handler (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
function g_log_set_handler(log_domain, log_levels, log_func, user_data) bind(c)
  import :: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_log_set_handler
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_levels
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_46
!guint g_log_set_handler_full (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data, GDestroyNotify destroy);
function g_log_set_handler_full(log_domain, log_levels, log_func, user_data,&
& destroy) bind(c)
  import :: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_log_set_handler_full
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_levels
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_log_remove_handler (const gchar *log_domain, guint handler_id);
subroutine g_log_remove_handler(log_domain, handler_id) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: handler_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_log_default_handler (const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
subroutine g_log_default_handler(log_domain, log_level, message, unused_data)&
& bind(c)
  import :: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: message
  type(c_ptr), value :: unused_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GLogFunc g_log_set_default_handler (GLogFunc log_func, gpointer user_data);
function g_log_set_default_handler(log_func, user_data) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr) :: g_log_set_default_handler
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_logv (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args) G_GNUC_PRINTF(3, 0);
subroutine g_logv(log_domain, log_level, format, args) bind(c)
  import :: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain, GLogLevelFlags fatal_mask);
function g_log_set_fatal_mask(log_domain, fatal_mask) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_log_set_fatal_mask
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: fatal_mask
end function

! GLIB_AVAILABLE_IN_ALL
!GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
function g_log_set_always_fatal(fatal_mask) bind(c)
  import :: c_int
  integer(c_int) :: g_log_set_always_fatal
  integer(c_int), value :: fatal_mask
end function

! GLIB_AVAILABLE_IN_2_50
!void g_log_structured_array (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields);
subroutine g_log_structured_array(log_level, fields, n_fields) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
  integer(c_size_t), value :: n_fields
end subroutine

! GLIB_AVAILABLE_IN_2_50
!void g_log_variant (const gchar *log_domain, GLogLevelFlags log_level, GVariant *fields);
subroutine g_log_variant(log_domain, log_level, fields) bind(c)
  import :: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
end subroutine

! GLIB_AVAILABLE_IN_2_50
!void g_log_set_writer_func (GLogWriterFunc func, gpointer user_data, GDestroyNotify user_data_free);
subroutine g_log_set_writer_func(func, user_data, user_data_free) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free
end subroutine

! GLIB_AVAILABLE_IN_2_50
!gboolean g_log_writer_supports_color (gint output_fd);
function g_log_writer_supports_color(output_fd) bind(c)
  import :: c_int
  integer(c_int) :: g_log_writer_supports_color
  integer(c_int), value :: output_fd
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_log_writer_is_journald (gint output_fd);
function g_log_writer_is_journald(output_fd) bind(c)
  import :: c_int
  integer(c_int) :: g_log_writer_is_journald
  integer(c_int), value :: output_fd
end function

! GLIB_AVAILABLE_IN_2_50
!gchar *g_log_writer_format_fields (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gboolean use_color);
function g_log_writer_format_fields(log_level, fields, n_fields, use_color)&
& bind(c)
  import :: c_ptr, c_int, c_size_t
  type(c_ptr) :: g_log_writer_format_fields
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
  integer(c_size_t), value :: n_fields
  integer(c_int), value :: use_color
end function

! GLIB_AVAILABLE_IN_2_50
!GLogWriterOutput g_log_writer_journald (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
function g_log_writer_journald(log_level, fields, n_fields, user_data) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_log_writer_journald
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
  integer(c_size_t), value :: n_fields
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_50
!GLogWriterOutput g_log_writer_standard_streams (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
function g_log_writer_standard_streams(log_level, fields, n_fields, user_data)&
& bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_log_writer_standard_streams
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
  integer(c_size_t), value :: n_fields
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_50
!GLogWriterOutput g_log_writer_default (GLogLevelFlags log_level, const GLogField *fields, gsize n_fields, gpointer user_data);
function g_log_writer_default(log_level, fields, n_fields, user_data) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_log_writer_default
  integer(c_int), value :: log_level
  type(c_ptr), value :: fields
  integer(c_size_t), value :: n_fields
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_68
!void g_log_writer_default_set_use_stderr (gboolean use_stderr);
subroutine g_log_writer_default_set_use_stderr(use_stderr) bind(c)
  import :: c_int
  integer(c_int), value :: use_stderr
end subroutine

! GLIB_AVAILABLE_IN_2_68
!gboolean g_log_writer_default_would_drop (GLogLevelFlags log_level, const char *log_domain);
function g_log_writer_default_would_drop(log_level, log_domain) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_log_writer_default_would_drop
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: log_domain
end function

! GLIB_AVAILABLE_IN_2_72
!gboolean g_log_get_debug_enabled (void);
function g_log_get_debug_enabled() bind(c)
  import :: c_int
  integer(c_int) :: g_log_get_debug_enabled
end function

! GLIB_AVAILABLE_IN_2_72
!void g_log_set_debug_enabled (gboolean enabled);
subroutine g_log_set_debug_enabled(enabled) bind(c)
  import :: c_int
  integer(c_int), value :: enabled
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_return_if_fail_warning (const char *log_domain, const char *pretty_function, const char *expression) G_ANALYZER_NORETURN;
subroutine g_return_if_fail_warning(log_domain, pretty_function, expression)&
& bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: log_domain
  character(kind=c_char), dimension(*) :: pretty_function
  character(kind=c_char), dimension(*) :: expression
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_warn_message (const char *domain, const char *file, int line, const char *func, const char *warnexpr) G_ANALYZER_NORETURN;
subroutine g_warn_message(domain, file, line, func, warnexpr) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: warnexpr
end subroutine

! 
!G_NORETURN void g_assert_warning (const char *log_domain, const char *file, const int line, const char *pretty_function, const char *expression);
subroutine g_assert_warning(log_domain, file, line, pretty_function,&
& expression) bind(c)
  import :: c_char, c_int
  character(kind=c_char), dimension(*) :: log_domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: pretty_function
  character(kind=c_char), dimension(*) :: expression
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GPrintFunc g_set_print_handler (GPrintFunc func);
function g_set_print_handler(func) bind(c)
  import :: c_funptr
  type(c_funptr) :: g_set_print_handler
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!GPrintFunc g_set_printerr_handler (GPrintFunc func);
function g_set_printerr_handler(func) bind(c)
  import :: c_funptr
  type(c_funptr) :: g_set_printerr_handler
  type(c_funptr), value :: func
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/giochannel.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_init (GIOChannel *channel);
subroutine g_io_channel_init(channel) bind(c)
  import :: c_ptr
  type(c_ptr), value :: channel
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GIOChannel *g_io_channel_ref (GIOChannel *channel);
function g_io_channel_ref(channel) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_channel_ref
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_unref (GIOChannel *channel);
subroutine g_io_channel_unref(channel) bind(c)
  import :: c_ptr
  type(c_ptr), value :: channel
end subroutine

! GLIB_DEPRECATED_FOR(g_io_channel_read_chars)
!GIOError g_io_channel_read (GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read);
function g_io_channel_read(channel, buf, count, bytes_read) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_io_channel_read
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: buf
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_read
end function

! GLIB_DEPRECATED_FOR(g_io_channel_write_chars)
!GIOError g_io_channel_write (GIOChannel *channel, const gchar *buf, gsize count, gsize *bytes_written);
function g_io_channel_write(channel, buf, count, bytes_written) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_io_channel_write
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: buf
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_written
end function

! GLIB_DEPRECATED_FOR(g_io_channel_seek_position)
!GIOError g_io_channel_seek (GIOChannel *channel, gint64 offset, GSeekType type);
function g_io_channel_seek(channel, offset, type) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_io_channel_seek
  type(c_ptr), value :: channel
  integer(c_int64_t), value :: offset
  integer(c_int), value :: type
end function

! GLIB_DEPRECATED_FOR(g_io_channel_shutdown)
!void g_io_channel_close (GIOChannel *channel);
subroutine g_io_channel_close(channel) bind(c)
  import :: c_ptr
  type(c_ptr), value :: channel
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_shutdown (GIOChannel *channel, gboolean flush, GError **err);
function g_io_channel_shutdown(channel, flush, err) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_shutdown
  type(c_ptr), value :: channel
  integer(c_int), value :: flush
  type(c_ptr), value :: err
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_io_add_watch_full (GIOChannel *channel, gint priority, GIOCondition condition, GIOFunc func, gpointer user_data, GDestroyNotify notify);
function g_io_add_watch_full(channel, priority, condition, func, user_data,&
& notify) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_io_add_watch_full
  type(c_ptr), value :: channel
  integer(c_int), value :: priority
  integer(c_int), value :: condition
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!GSource * g_io_create_watch (GIOChannel *channel, GIOCondition condition);
function g_io_create_watch(channel, condition) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_create_watch
  type(c_ptr), value :: channel
  integer(c_int), value :: condition
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_io_add_watch (GIOChannel *channel, GIOCondition condition, GIOFunc func, gpointer user_data);
function g_io_add_watch(channel, condition, func, user_data) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_io_add_watch
  type(c_ptr), value :: channel
  integer(c_int), value :: condition
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_set_buffer_size (GIOChannel *channel, gsize size);
subroutine g_io_channel_set_buffer_size(channel, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: channel
  integer(c_size_t), value :: size
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gsize g_io_channel_get_buffer_size (GIOChannel *channel);
function g_io_channel_get_buffer_size(channel) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_io_channel_get_buffer_size
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
function g_io_channel_get_buffer_condition(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_get_buffer_condition
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_set_flags (GIOChannel *channel, GIOFlags flags, GError **error);
function g_io_channel_set_flags(channel, flags, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_set_flags
  type(c_ptr), value :: channel
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOFlags g_io_channel_get_flags (GIOChannel *channel);
function g_io_channel_get_flags(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_get_flags
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_set_line_term (GIOChannel *channel, const gchar *line_term, gint length);
subroutine g_io_channel_set_line_term(channel, line_term, length) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: line_term
  integer(c_int), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_io_channel_get_line_term (GIOChannel *channel, gint *length);
function g_io_channel_get_line_term(channel, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_channel_get_line_term
  type(c_ptr), value :: channel
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_set_buffered (GIOChannel *channel, gboolean buffered);
subroutine g_io_channel_set_buffered(channel, buffered) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: channel
  integer(c_int), value :: buffered
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_channel_get_buffered (GIOChannel *channel);
function g_io_channel_get_buffered(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_get_buffered
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_set_encoding (GIOChannel *channel, const gchar *encoding, GError **error);
function g_io_channel_set_encoding(channel, encoding, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_io_channel_set_encoding
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: encoding
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_io_channel_get_encoding (GIOChannel *channel);
function g_io_channel_get_encoding(channel) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_channel_get_encoding
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_set_close_on_unref (GIOChannel *channel, gboolean do_close);
subroutine g_io_channel_set_close_on_unref(channel, do_close) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: channel
  integer(c_int), value :: do_close
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);
function g_io_channel_get_close_on_unref(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_get_close_on_unref
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_flush (GIOChannel *channel, GError **error);
function g_io_channel_flush(channel, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_flush
  type(c_ptr), value :: channel
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_read_line (GIOChannel *channel, gchar **str_return, gsize *length, gsize *terminator_pos, GError **error);
function g_io_channel_read_line(channel, str_return, length, terminator_pos,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_read_line
  type(c_ptr), value :: channel
  type(c_ptr), dimension(*) :: str_return
  type(c_ptr), value :: length
  type(c_ptr), value :: terminator_pos
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_read_line_string (GIOChannel *channel, GString *buffer, gsize *terminator_pos, GError **error);
function g_io_channel_read_line_string(channel, buffer, terminator_pos, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_read_line_string
  type(c_ptr), value :: channel
  type(c_ptr), value :: buffer
  type(c_ptr), value :: terminator_pos
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_read_to_end (GIOChannel *channel, gchar **str_return, gsize *length, GError **error);
function g_io_channel_read_to_end(channel, str_return, length, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_read_to_end
  type(c_ptr), value :: channel
  type(c_ptr), dimension(*) :: str_return
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_read_chars (GIOChannel *channel, gchar *buf, gsize count, gsize *bytes_read, GError **error);
function g_io_channel_read_chars(channel, buf, count, bytes_read, error)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_io_channel_read_chars
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: buf
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_read_unichar (GIOChannel *channel, gunichar *thechar, GError **error);
function g_io_channel_read_unichar(channel, thechar, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_io_channel_read_unichar
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: thechar
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_write_chars (GIOChannel *channel, const gchar *buf, gssize count, gsize *bytes_written, GError **error);
function g_io_channel_write_chars(channel, buf, count, bytes_written, error)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_io_channel_write_chars
  type(c_ptr), value :: channel
  character(kind=c_char), dimension(*) :: buf
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_write_unichar (GIOChannel *channel, gunichar thechar, GError **error);
function g_io_channel_write_unichar(channel, thechar, error) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_io_channel_write_unichar
  type(c_ptr), value :: channel
  integer(c_int32_t), value :: thechar
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStatus g_io_channel_seek_position (GIOChannel *channel, gint64 offset, GSeekType type, GError **error);
function g_io_channel_seek_position(channel, offset, type, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_io_channel_seek_position
  type(c_ptr), value :: channel
  integer(c_int64_t), value :: offset
  integer(c_int), value :: type
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOChannel* g_io_channel_new_file (const gchar *filename, const gchar *mode, GError **error);
function g_io_channel_new_file(filename, mode, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_channel_new_file
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: mode
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_io_channel_error_quark (void);
function g_io_channel_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_io_channel_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GIOChannelError g_io_channel_error_from_errno (gint en);
function g_io_channel_error_from_errno(en) bind(c)
  import :: c_int
  integer(c_int) :: g_io_channel_error_from_errno
  integer(c_int), value :: en
end function

! GLIB_AVAILABLE_IN_ALL
!GIOChannel* g_io_channel_unix_new (int fd);
function g_io_channel_unix_new(fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_channel_unix_new
  integer(c_int), value :: fd
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_io_channel_unix_get_fd (GIOChannel *channel);
function g_io_channel_unix_get_fd(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_unix_get_fd
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_win32_make_pollfd (GIOChannel *channel, GIOCondition condition, GPollFD *fd);
subroutine g_io_channel_win32_make_pollfd(channel, condition, fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: channel
  integer(c_int), value :: condition
  type(c_ptr), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_io_channel_win32_poll (GPollFD *fds, gint n_fds, gint timeout_);
function g_io_channel_win32_poll(fds, n_fds, timeout_) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_win32_poll
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
  integer(c_int), value :: timeout_
end function

! GLIB_AVAILABLE_IN_ALL
!GIOChannel* g_io_channel_win32_new_fd (gint fd);
function g_io_channel_win32_new_fd(fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_channel_win32_new_fd
  integer(c_int), value :: fd
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_io_channel_win32_get_fd (GIOChannel *channel);
function g_io_channel_win32_get_fd(channel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_channel_win32_get_fd
  type(c_ptr), value :: channel
end function

! GLIB_AVAILABLE_IN_ALL
!GIOChannel *g_io_channel_win32_new_socket (gint socket);
function g_io_channel_win32_new_socket(socket) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_channel_win32_new_socket
  integer(c_int), value :: socket
end function

! GLIB_DEPRECATED_FOR(g_io_channel_win32_new_socket)
!GIOChannel *g_io_channel_win32_new_stream_socket (gint socket);
function g_io_channel_win32_new_stream_socket(socket) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_channel_win32_new_stream_socket
  integer(c_int), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_channel_win32_set_debug (GIOChannel *channel, gboolean flag);
subroutine g_io_channel_win32_set_debug(channel, flag) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: channel
  integer(c_int), value :: flag
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gshell.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_shell_error_quark (void);
function g_shell_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_shell_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_shell_quote (const gchar *unquoted_string);
function g_shell_quote(unquoted_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_shell_quote
  character(kind=c_char), dimension(*) :: unquoted_string
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_shell_unquote (const gchar *quoted_string, GError **error);
function g_shell_unquote(quoted_string, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_shell_unquote
  character(kind=c_char), dimension(*) :: quoted_string
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_shell_parse_argv (const gchar *command_line, gint *argcp, gchar ***argvp, GError **error);
function g_shell_parse_argv(command_line, argcp, argvp, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_shell_parse_argv
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: argcp
  type(c_ptr), dimension(*) :: argvp
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gregex.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_regex_error_quark (void);
function g_regex_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_regex_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GRegex *g_regex_new (const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error);
function g_regex_new(pattern, compile_options, match_options, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_new
  character(kind=c_char), dimension(*) :: pattern
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GRegex *g_regex_ref (GRegex *regex);
function g_regex_ref(regex) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_regex_ref
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!void g_regex_unref (GRegex *regex);
subroutine g_regex_unref(regex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: regex
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_regex_get_pattern (const GRegex *regex);
function g_regex_get_pattern(regex) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_regex_get_pattern
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_regex_get_max_backref (const GRegex *regex);
function g_regex_get_max_backref(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_max_backref
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_regex_get_capture_count (const GRegex *regex);
function g_regex_get_capture_count(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_capture_count
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_get_has_cr_or_lf (const GRegex *regex);
function g_regex_get_has_cr_or_lf(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_has_cr_or_lf
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_2_38
!gint g_regex_get_max_lookbehind (const GRegex *regex);
function g_regex_get_max_lookbehind(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_max_lookbehind
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_regex_get_string_number (const GRegex *regex, const gchar *name);
function g_regex_get_string_number(regex, name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_get_string_number
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_regex_escape_string (const gchar *string, gint length);
function g_regex_escape_string(string, length) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_escape_string
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_regex_escape_nul (const gchar *string, gint length);
function g_regex_escape_nul(string, length) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_escape_nul
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GRegexCompileFlags g_regex_get_compile_flags (const GRegex *regex);
function g_regex_get_compile_flags(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_compile_flags
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!GRegexMatchFlags g_regex_get_match_flags (const GRegex *regex);
function g_regex_get_match_flags(regex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_regex_get_match_flags
  type(c_ptr), value :: regex
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_match_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_match_simple(pattern, string, compile_options, match_options)&
& bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_regex_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_match (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match(regex, string, match_options, match_info) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_match
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_match_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_full(regex, string, string_len, start_position,&
& match_options, match_info, error) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_regex_match_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_match_all (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match_all(regex, string, match_options, match_info) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_match_all
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_match_all_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_all_full(regex, string, string_len, start_position,&
& match_options, match_info, error) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_regex_match_all_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_regex_split_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_split_simple(pattern, string, compile_options, match_options)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_regex_split (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options);
function g_regex_split(regex, string, match_options) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_regex_split_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error);
function g_regex_split_full(regex, string, string_len, start_position,&
& match_options, max_tokens, error) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_split_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  integer(c_int), value :: max_tokens
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_regex_replace (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace(regex, string, string_len, start_position,&
& replacement, match_options, error) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_regex_replace_literal (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace_literal(regex, string, string_len, start_position,&
& replacement, match_options, error) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace_literal
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_regex_replace_eval (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error);
function g_regex_replace_eval(regex, string, string_len, start_position,&
& match_options, eval, user_data, error) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr) :: g_regex_replace_eval
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_funptr), value :: eval
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_regex_check_replacement (const gchar *replacement, gboolean *has_references, GError **error);
function g_regex_check_replacement(replacement, has_references, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_regex_check_replacement
  character(kind=c_char), dimension(*) :: replacement
  type(c_ptr), value :: has_references
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
function g_match_info_get_regex(match_info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_match_info_get_regex
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_match_info_get_string (const GMatchInfo *match_info);
function g_match_info_get_string(match_info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_match_info_get_string
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!GMatchInfo *g_match_info_ref (GMatchInfo *match_info);
function g_match_info_ref(match_info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_match_info_ref
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!void g_match_info_unref (GMatchInfo *match_info);
subroutine g_match_info_unref(match_info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: match_info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_match_info_free (GMatchInfo *match_info);
subroutine g_match_info_free(match_info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: match_info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_match_info_next (GMatchInfo *match_info, GError **error);
function g_match_info_next(match_info, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_match_info_next
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_match_info_matches (const GMatchInfo *match_info);
function g_match_info_matches(match_info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_match_info_matches
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_match_info_get_match_count (const GMatchInfo *match_info);
function g_match_info_get_match_count(match_info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_match_info_get_match_count
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
function g_match_info_is_partial_match(match_info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_match_info_is_partial_match
  type(c_ptr), value :: match_info
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error);
function g_match_info_expand_references(match_info, string_to_expand, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_match_info_expand_references
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: string_to_expand
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_match_info_fetch (const GMatchInfo *match_info, gint match_num);
function g_match_info_fetch(match_info, match_num) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_match_info_fetch
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_match_info_fetch_pos (const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos);
function g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_match_info_fetch_pos
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_match_info_fetch_named (const GMatchInfo *match_info, const gchar *name);
function g_match_info_fetch_named(match_info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_match_info_fetch_named
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos);
function g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_match_info_fetch_named_pos
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_match_info_fetch_all (const GMatchInfo *match_info);
function g_match_info_fetch_all(match_info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_match_info_fetch_all
  type(c_ptr), value :: match_info
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gcharset.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_get_charset (const char **charset);
function g_get_charset(charset) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_get_charset
  type(c_ptr), dimension(*) :: charset
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_get_codeset (void);
function g_get_codeset() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_codeset
end function

! GLIB_AVAILABLE_IN_2_62
!gboolean g_get_console_charset (const char **charset);
function g_get_console_charset(charset) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_get_console_charset
  type(c_ptr), dimension(*) :: charset
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * const * g_get_language_names (void);
function g_get_language_names() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_language_names
end function

! GLIB_AVAILABLE_IN_2_58
!const gchar * const * g_get_language_names_with_category (const gchar *category_name);
function g_get_language_names_with_category(category_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_get_language_names_with_category
  character(kind=c_char), dimension(*) :: category_name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_get_locale_variants (const gchar *locale);
function g_get_locale_variants(locale) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_get_locale_variants
  character(kind=c_char), dimension(*) :: locale
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/grefstring.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_58
!char * g_ref_string_new (const char *str);
function g_ref_string_new(str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_ref_string_new
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_2_58
!char * g_ref_string_new_len (const char *str, gssize len);
function g_ref_string_new_len(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ref_string_new_len
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_2_58
!char * g_ref_string_new_intern (const char *str);
function g_ref_string_new_intern(str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_ref_string_new_intern
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_2_58
!char * g_ref_string_acquire (char *str);
function g_ref_string_acquire(str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_ref_string_acquire
  character(kind=c_char), dimension(*) :: str
end function

! GLIB_AVAILABLE_IN_2_58
!void g_ref_string_release (char *str);
subroutine g_ref_string_release(str) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: str
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gsize g_ref_string_length (char *str);
function g_ref_string_length(str) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_ref_string_length
  character(kind=c_char), dimension(*) :: str
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/genviron.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!const gchar * g_getenv (const gchar *variable);
function g_getenv(variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_getenv
  character(kind=c_char), dimension(*) :: variable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_setenv (const gchar *variable, const gchar *value, gboolean overwrite);
function g_setenv(variable, value, overwrite) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_setenv
  character(kind=c_char), dimension(*) :: variable
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: overwrite
end function

! GLIB_AVAILABLE_IN_ALL
!void g_unsetenv (const gchar *variable);
subroutine g_unsetenv(variable) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: variable
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_listenv (void);
function g_listenv() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_listenv
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_get_environ (void);
function g_get_environ() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_environ
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_environ_getenv (gchar **envp, const gchar *variable);
function g_environ_getenv(envp, variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_environ_getenv
  type(c_ptr), dimension(*) :: envp
  character(kind=c_char), dimension(*) :: variable
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_environ_setenv (gchar **envp, const gchar *variable, const gchar *value, gboolean overwrite) G_GNUC_WARN_UNUSED_RESULT;
function g_environ_setenv(envp, variable, value, overwrite) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_environ_setenv
  type(c_ptr), dimension(*) :: envp
  character(kind=c_char), dimension(*) :: variable
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: overwrite
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_environ_unsetenv (gchar **envp, const gchar *variable) G_GNUC_WARN_UNUSED_RESULT;
function g_environ_unsetenv(envp, variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_environ_unsetenv
  type(c_ptr), dimension(*) :: envp
  character(kind=c_char), dimension(*) :: variable
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/guri.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_66
!GUri * g_uri_ref (GUri *uri);
function g_uri_ref(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_ref
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!void g_uri_unref (GUri *uri);
subroutine g_uri_unref(uri) bind(c)
  import :: c_ptr
  type(c_ptr), value :: uri
end subroutine

! GLIB_AVAILABLE_IN_2_66
!gboolean g_uri_split_with_user (const gchar *uri_ref, GUriFlags flags, gchar **scheme, gchar **user, gchar **password, gchar **auth_params, gchar **host, gint *port, gchar **path, gchar **query, gchar **fragment, GError **error);
function g_uri_split_with_user(uri_ref, flags, scheme, user, password,&
& auth_params, host, port, path, query, fragment, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_uri_split_with_user
  character(kind=c_char), dimension(*) :: uri_ref
  integer(c_int), value :: flags
  type(c_ptr), dimension(*) :: scheme
  type(c_ptr), dimension(*) :: user
  type(c_ptr), dimension(*) :: password
  type(c_ptr), dimension(*) :: auth_params
  type(c_ptr), dimension(*) :: host
  type(c_ptr), value :: port
  type(c_ptr), dimension(*) :: path
  type(c_ptr), dimension(*) :: query
  type(c_ptr), dimension(*) :: fragment
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_uri_split_network (const gchar *uri_string, GUriFlags flags, gchar **scheme, gchar **host, gint *port, GError **error);
function g_uri_split_network(uri_string, flags, scheme, host, port, error)&
& bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_uri_split_network
  character(kind=c_char), dimension(*) :: uri_string
  integer(c_int), value :: flags
  type(c_ptr), dimension(*) :: scheme
  type(c_ptr), dimension(*) :: host
  type(c_ptr), value :: port
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_uri_is_valid (const gchar *uri_string, GUriFlags flags, GError **error);
function g_uri_is_valid(uri_string, flags, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_uri_is_valid
  character(kind=c_char), dimension(*) :: uri_string
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gchar * g_uri_join (GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
function g_uri_join(flags, scheme, userinfo, host, port, path, query, fragment)&
& bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_uri_join
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: scheme
  character(kind=c_char), dimension(*) :: userinfo
  character(kind=c_char), dimension(*) :: host
  integer(c_int), value :: port
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: query
  character(kind=c_char), dimension(*) :: fragment
end function

! GLIB_AVAILABLE_IN_2_66
!gchar * g_uri_join_with_user (GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
function g_uri_join_with_user(flags, scheme, user, password, auth_params, host,&
& port, path, query, fragment) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_uri_join_with_user
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: scheme
  character(kind=c_char), dimension(*) :: user
  character(kind=c_char), dimension(*) :: password
  character(kind=c_char), dimension(*) :: auth_params
  character(kind=c_char), dimension(*) :: host
  integer(c_int), value :: port
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: query
  character(kind=c_char), dimension(*) :: fragment
end function

! GLIB_AVAILABLE_IN_2_66
!GUri * g_uri_parse (const gchar *uri_string, GUriFlags flags, GError **error);
function g_uri_parse(uri_string, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_uri_parse
  character(kind=c_char), dimension(*) :: uri_string
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GUri * g_uri_parse_relative (GUri *base_uri, const gchar *uri_ref, GUriFlags flags, GError **error);
function g_uri_parse_relative(base_uri, uri_ref, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_uri_parse_relative
  type(c_ptr), value :: base_uri
  character(kind=c_char), dimension(*) :: uri_ref
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!gchar * g_uri_resolve_relative (const gchar *base_uri_string, const gchar *uri_ref, GUriFlags flags, GError **error);
function g_uri_resolve_relative(base_uri_string, uri_ref, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_uri_resolve_relative
  character(kind=c_char), dimension(*) :: base_uri_string
  character(kind=c_char), dimension(*) :: uri_ref
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GUri * g_uri_build (GUriFlags flags, const gchar *scheme, const gchar *userinfo, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
function g_uri_build(flags, scheme, userinfo, host, port, path, query,&
& fragment) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_uri_build
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: scheme
  character(kind=c_char), dimension(*) :: userinfo
  character(kind=c_char), dimension(*) :: host
  integer(c_int), value :: port
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: query
  character(kind=c_char), dimension(*) :: fragment
end function

! GLIB_AVAILABLE_IN_2_66
!GUri * g_uri_build_with_user (GUriFlags flags, const gchar *scheme, const gchar *user, const gchar *password, const gchar *auth_params, const gchar *host, gint port, const gchar *path, const gchar *query, const gchar *fragment);
function g_uri_build_with_user(flags, scheme, user, password, auth_params,&
& host, port, path, query, fragment) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_uri_build_with_user
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: scheme
  character(kind=c_char), dimension(*) :: user
  character(kind=c_char), dimension(*) :: password
  character(kind=c_char), dimension(*) :: auth_params
  character(kind=c_char), dimension(*) :: host
  integer(c_int), value :: port
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: query
  character(kind=c_char), dimension(*) :: fragment
end function

! GLIB_AVAILABLE_IN_2_66
!GLIB_AVAILABLE_TYPE_IN_2_66 char * g_uri_to_string (GUri *uri);
function g_uri_to_string(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_to_string
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!char * g_uri_to_string_partial (GUri *uri, GUriHideFlags flags);
function g_uri_to_string_partial(uri, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_uri_to_string_partial
  type(c_ptr), value :: uri
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_scheme (GUri *uri);
function g_uri_get_scheme(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_scheme
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_userinfo (GUri *uri);
function g_uri_get_userinfo(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_userinfo
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_user (GUri *uri);
function g_uri_get_user(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_user
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_password (GUri *uri);
function g_uri_get_password(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_password
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_auth_params (GUri *uri);
function g_uri_get_auth_params(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_auth_params
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_host (GUri *uri);
function g_uri_get_host(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_host
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!gint g_uri_get_port (GUri *uri);
function g_uri_get_port(uri) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_uri_get_port
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_path (GUri *uri);
function g_uri_get_path(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_path
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_query (GUri *uri);
function g_uri_get_query(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_query
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const gchar *g_uri_get_fragment (GUri *uri);
function g_uri_get_fragment(uri) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_uri_get_fragment
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!GUriFlags g_uri_get_flags (GUri *uri);
function g_uri_get_flags(uri) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_uri_get_flags
  type(c_ptr), value :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!GLIB_AVAILABLE_TYPE_IN_2_66 GHashTable *g_uri_parse_params (const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags, GError **error);
function g_uri_parse_params(params, length, separators, flags, error) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_uri_parse_params
  character(kind=c_char), dimension(*) :: params
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: separators
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!void g_uri_params_iter_init (GUriParamsIter *iter, const gchar *params, gssize length, const gchar *separators, GUriParamsFlags flags);
subroutine g_uri_params_iter_init(iter, params, length, separators, flags)&
& bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: params
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: separators
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_66
!gboolean g_uri_params_iter_next (GUriParamsIter *iter, gchar **attribute, gchar **value, GError **error);
function g_uri_params_iter_next(iter, attribute, value, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_uri_params_iter_next
  type(c_ptr), value :: iter
  type(c_ptr), dimension(*) :: attribute
  type(c_ptr), dimension(*) :: value
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!GQuark g_uri_error_quark (void);
function g_uri_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_uri_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_uri_unescape_string (const char *escaped_string, const char *illegal_characters);
function g_uri_unescape_string(escaped_string, illegal_characters) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_string
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_uri_unescape_segment (const char *escaped_string, const char *escaped_string_end, const char *illegal_characters);
function g_uri_unescape_segment(escaped_string, escaped_string_end,&
& illegal_characters) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_segment
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: escaped_string_end
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_uri_parse_scheme (const char *uri);
function g_uri_parse_scheme(uri) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_uri_parse_scheme
  character(kind=c_char), dimension(*) :: uri
end function

! GLIB_AVAILABLE_IN_2_66
!const char *g_uri_peek_scheme (const char *uri);
function g_uri_peek_scheme(uri) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_uri_peek_scheme
  character(kind=c_char), dimension(*) :: uri
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_uri_escape_string (const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
function g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_uri_escape_string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  integer(c_int), value :: allow_utf8
end function

! GLIB_AVAILABLE_IN_2_66
!GBytes * g_uri_unescape_bytes (const char *escaped_string, gssize length, const char *illegal_characters, GError **error);
function g_uri_unescape_bytes(escaped_string, length, illegal_characters,&
& error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_uri_unescape_bytes
  character(kind=c_char), dimension(*) :: escaped_string
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: illegal_characters
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_66
!char * g_uri_escape_bytes (const guint8 *unescaped, gsize length, const char *reserved_chars_allowed);
function g_uri_escape_bytes(unescaped, length, reserved_chars_allowed) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_uri_escape_bytes
  type(c_ptr), value :: unescaped
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/grefcount.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_58
!void g_ref_count_init (grefcount *rc);
subroutine g_ref_count_init(rc) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rc
end subroutine

! GLIB_AVAILABLE_IN_2_58
!void g_ref_count_inc (grefcount *rc);
subroutine g_ref_count_inc(rc) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rc
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gboolean g_ref_count_dec (grefcount *rc);
function g_ref_count_dec(rc) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_ref_count_dec
  type(c_ptr), value :: rc
end function

! GLIB_AVAILABLE_IN_2_58
!gboolean g_ref_count_compare (grefcount *rc, gint val);
function g_ref_count_compare(rc, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_ref_count_compare
  type(c_ptr), value :: rc
  integer(c_int), value :: val
end function

! GLIB_AVAILABLE_IN_2_58
!void g_atomic_ref_count_init (gatomicrefcount *arc);
subroutine g_atomic_ref_count_init(arc) bind(c)
  import :: c_ptr
  type(c_ptr), value :: arc
end subroutine

! GLIB_AVAILABLE_IN_2_58
!void g_atomic_ref_count_inc (gatomicrefcount *arc);
subroutine g_atomic_ref_count_inc(arc) bind(c)
  import :: c_ptr
  type(c_ptr), value :: arc
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gboolean g_atomic_ref_count_dec (gatomicrefcount *arc);
function g_atomic_ref_count_dec(arc) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_ref_count_dec
  type(c_ptr), value :: arc
end function

! GLIB_AVAILABLE_IN_2_58
!gboolean g_atomic_ref_count_compare (gatomicrefcount *arc, gint val);
function g_atomic_ref_count_compare(arc, val) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_atomic_ref_count_compare
  type(c_ptr), value :: arc
  integer(c_int), value :: val
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gconvert.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_convert_error_quark (void);
function g_convert_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_convert_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GIConv g_iconv_open (const gchar *to_codeset, const gchar *from_codeset);
function g_iconv_open(to_codeset, from_codeset) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_iconv_open
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_iconv (GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left);
function g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_iconv
  type(c_ptr), value :: converter
  type(c_ptr), dimension(*) :: inbuf
  type(c_ptr), value :: inbytes_left
  type(c_ptr), dimension(*) :: outbuf
  type(c_ptr), value :: outbytes_left
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_iconv_close (GIConv converter);
function g_iconv_close(converter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_iconv_close
  type(c_ptr), value :: converter
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_convert (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert(str, len, to_codeset, from_codeset, bytes_read,&
& bytes_written, error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_convert_with_iconv (const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_iconv(str, len, converter, bytes_read, bytes_written,&
& error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_iconv
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  type(c_ptr), value :: converter
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_convert_with_fallback (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback,&
& bytes_read, bytes_written, error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_fallback
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  character(kind=c_char), dimension(*) :: fallback
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_locale_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error)&
& bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_to_utf8
  character(kind=c_char), dimension(*) :: opsysstring
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_locale_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error)&
& bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_from_utf8
  character(kind=c_char), dimension(*) :: utf8string
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_filename_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_filename_to_utf8(opsysstring, len, bytes_read, bytes_written, error)&
& bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_filename_to_utf8
  character(kind=c_char), dimension(*) :: opsysstring
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_filename_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_filename_from_utf8(utf8string, len, bytes_read, bytes_written,&
& error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_filename_from_utf8
  character(kind=c_char), dimension(*) :: utf8string
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_filename_from_uri (const gchar *uri, gchar **hostname, GError **error) G_GNUC_MALLOC;
function g_filename_from_uri(uri, hostname, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_from_uri
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), dimension(*) :: hostname
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_filename_to_uri (const gchar *filename, const gchar *hostname, GError **error) G_GNUC_MALLOC;
function g_filename_to_uri(filename, hostname, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_to_uri
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_filename_display_name (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_name(filename) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_display_name
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_get_filename_charsets (const gchar ***filename_charsets);
function g_get_filename_charsets(filename_charsets) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_get_filename_charsets
  type(c_ptr), dimension(*) :: filename_charsets
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_filename_display_basename (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_basename(filename) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_display_basename
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_uri_list_extract_uris (const gchar *uri_list);
function g_uri_list_extract_uris(uri_list) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_uri_list_extract_uris
  character(kind=c_char), dimension(*) :: uri_list
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_name (void);
function g_get_user_name() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_name
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_real_name (void);
function g_get_real_name() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_real_name
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_home_dir (void);
function g_get_home_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_home_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_tmp_dir (void);
function g_get_tmp_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_tmp_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_host_name (void);
function g_get_host_name() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_host_name
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_prgname (void);
function g_get_prgname() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_prgname
end function

! GLIB_AVAILABLE_IN_ALL
!void g_set_prgname (const gchar *prgname);
subroutine g_set_prgname(prgname) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: prgname
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_application_name (void);
function g_get_application_name() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_application_name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_set_application_name (const gchar *application_name);
subroutine g_set_application_name(application_name) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: application_name
end subroutine

! GLIB_AVAILABLE_IN_2_64
!gchar * g_get_os_info (const gchar *key_name);
function g_get_os_info(key_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_get_os_info
  character(kind=c_char), dimension(*) :: key_name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_reload_user_special_dirs_cache (void);
subroutine g_reload_user_special_dirs_cache() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_data_dir (void);
function g_get_user_data_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_data_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_config_dir (void);
function g_get_user_config_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_config_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_cache_dir (void);
function g_get_user_cache_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_cache_dir
end function

! GLIB_AVAILABLE_IN_2_72
!const gchar * g_get_user_state_dir (void);
function g_get_user_state_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_state_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * const * g_get_system_data_dirs (void);
function g_get_system_data_dirs() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_system_data_dirs
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * const * g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void));
function g_win32_get_system_data_dirs_for_module() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_win32_get_system_data_dirs_for_module
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * const * g_get_system_config_dirs (void);
function g_get_system_config_dirs() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_system_config_dirs
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_runtime_dir (void);
function g_get_user_runtime_dir() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_get_user_runtime_dir
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_get_user_special_dir (GUserDirectory directory);
function g_get_user_special_dir(directory) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_get_user_special_dir
  integer(c_int), value :: directory
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_parse_debug_string (const gchar *string, const GDebugKey *keys, guint nkeys);
function g_parse_debug_string(string, keys, nkeys) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_parse_debug_string
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: keys
  integer(c_int), value :: nkeys
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_vsnprintf (gchar *string, gulong n, gchar const *format, va_list args) G_GNUC_PRINTF(3, 0);
function g_vsnprintf(string, n, format, args) bind(c)
  import :: c_int, c_char, c_long, c_ptr
  integer(c_int) :: g_vsnprintf
  character(kind=c_char), dimension(*) :: string
  integer(c_long), value :: n
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!void g_nullify_pointer (gpointer *nullify_location);
subroutine g_nullify_pointer(nullify_location) bind(c)
  import :: c_ptr
  type(c_ptr), value :: nullify_location
end subroutine

! GLIB_AVAILABLE_IN_2_30
!gchar *g_format_size_full (guint64 size, GFormatSizeFlags flags);
function g_format_size_full(size, flags) bind(c)
  import :: c_ptr, c_int64_t, c_int
  type(c_ptr) :: g_format_size_full
  integer(c_int64_t), value :: size
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_format_size (guint64 size);
function g_format_size(size) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_format_size
  integer(c_int64_t), value :: size
end function

! GLIB_DEPRECATED_IN_2_30_FOR(g_format_size)
!gchar *g_format_size_for_display (goffset size);
function g_format_size_for_display(size) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_format_size_for_display
  integer(c_int64_t), value :: size
end function

! GLIB_DEPRECATED
!void g_atexit (GVoidFunc func);
subroutine g_atexit(func) bind(c)
  import :: c_funptr
  type(c_funptr), value :: func
end subroutine

! GLIB_DEPRECATED
!int atexit (void (*)(void));
function atexit() bind(c)
  import :: c_int
  integer(c_int) :: atexit
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_find_program_in_path (const gchar *program);
function g_find_program_in_path(program) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_find_program_in_path
  character(kind=c_char), dimension(*) :: program
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_bit_nth_lsf (gulong mask, gint nth_bit);
function g_bit_nth_lsf(mask, nth_bit) bind(c)
  import :: c_int, c_long
  integer(c_int) :: g_bit_nth_lsf
  integer(c_long), value :: mask
  integer(c_int), value :: nth_bit
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_bit_nth_msf (gulong mask, gint nth_bit);
function g_bit_nth_msf(mask, nth_bit) bind(c)
  import :: c_int, c_long
  integer(c_int) :: g_bit_nth_msf
  integer(c_long), value :: mask
  integer(c_int), value :: nth_bit
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bit_storage (gulong number);
function g_bit_storage(number) bind(c)
  import :: c_int, c_long
  integer(c_int) :: g_bit_storage
  integer(c_long), value :: number
end function

! GLIB_AVAILABLE_IN_2_50
!G_NORETURN void g_abort (void) G_ANALYZER_NORETURN;
subroutine g_abort() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/garray.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_new (gboolean zero_terminated, gboolean clear_, guint element_size);
function g_array_new(zero_terminated, clear_, element_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_new
  integer(c_int), value :: zero_terminated
  integer(c_int), value :: clear_
  integer(c_int), value :: element_size
end function

! GLIB_AVAILABLE_IN_2_64
!gpointer g_array_steal (GArray *array, gsize *len);
function g_array_steal(array, len) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_array_steal
  type(c_ptr), value :: array
  type(c_ptr), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_sized_new (gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
function g_array_sized_new(zero_terminated, clear_, element_size,&
& reserved_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_sized_new
  integer(c_int), value :: zero_terminated
  integer(c_int), value :: clear_
  integer(c_int), value :: element_size
  integer(c_int), value :: reserved_size
end function

! GLIB_AVAILABLE_IN_2_62
!GArray* g_array_copy (GArray *array);
function g_array_copy(array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_array_copy
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_array_free (GArray *array, gboolean free_segment);
function g_array_free(array, free_segment) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_segment
end function

! GLIB_AVAILABLE_IN_ALL
!GArray *g_array_ref (GArray *array);
function g_array_ref(array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_array_ref
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!void g_array_unref (GArray *array);
subroutine g_array_unref(array) bind(c)
  import :: c_ptr
  type(c_ptr), value :: array
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_array_get_element_size (GArray *array);
function g_array_get_element_size(array) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_array_get_element_size
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_append_vals (GArray *array, gconstpointer data, guint len);
function g_array_append_vals(array, data, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_append_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_prepend_vals (GArray *array, gconstpointer data, guint len);
function g_array_prepend_vals(array, data, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_prepend_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_insert_vals (GArray *array, guint index_, gconstpointer data, guint len);
function g_array_insert_vals(array, index_, data, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_insert_vals
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_set_size (GArray *array, guint length);
function g_array_set_size(array, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_remove_index (GArray *array, guint index_);
function g_array_remove_index(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_remove_index_fast (GArray *array, guint index_);
function g_array_remove_index_fast(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GArray* g_array_remove_range (GArray *array, guint index_, guint length);
function g_array_remove_range(array, index_, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_array_sort (GArray *array, GCompareFunc compare_func);
subroutine g_array_sort(array, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_array_sort_with_data (GArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_array_sort_with_data(array, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_62
!gboolean g_array_binary_search (GArray *array, gconstpointer target, GCompareFunc compare_func, guint *out_match_index);
function g_array_binary_search(array, target, compare_func, out_match_index)&
& bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_array_binary_search
  type(c_ptr), value :: array
  type(c_ptr), value :: target
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: out_match_index
end function

! GLIB_AVAILABLE_IN_ALL
!void g_array_set_clear_func (GArray *array, GDestroyNotify clear_func);
subroutine g_array_set_clear_func(array, clear_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: clear_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GPtrArray* g_ptr_array_new (void);
function g_ptr_array_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_ptr_array_new
end function

! GLIB_AVAILABLE_IN_ALL
!GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify element_free_func);
function g_ptr_array_new_with_free_func(element_free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_ptr_array_new_with_free_func
  type(c_funptr), value :: element_free_func
end function

! GLIB_AVAILABLE_IN_2_64
!gpointer* g_ptr_array_steal (GPtrArray *array, gsize *len);
function g_ptr_array_steal(array, len) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_ptr_array_steal
  type(c_ptr), value :: array
  type(c_ptr), value :: len
end function

! GLIB_AVAILABLE_IN_2_62
!GPtrArray *g_ptr_array_copy (GPtrArray *array, GCopyFunc func, gpointer user_data);
function g_ptr_array_copy(array, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_ptr_array_copy
  type(c_ptr), value :: array
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GPtrArray* g_ptr_array_sized_new (guint reserved_size);
function g_ptr_array_sized_new(reserved_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_sized_new
  integer(c_int), value :: reserved_size
end function

! GLIB_AVAILABLE_IN_ALL
!GPtrArray* g_ptr_array_new_full (guint reserved_size, GDestroyNotify element_free_func);
function g_ptr_array_new_full(reserved_size, element_free_func) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_ptr_array_new_full
  integer(c_int), value :: reserved_size
  type(c_funptr), value :: element_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer* g_ptr_array_free (GPtrArray *array, gboolean free_seg);
function g_ptr_array_free(array, free_seg) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_seg
end function

! GLIB_AVAILABLE_IN_ALL
!GPtrArray* g_ptr_array_ref (GPtrArray *array);
function g_ptr_array_ref(array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_ptr_array_ref
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_unref (GPtrArray *array);
subroutine g_ptr_array_unref(array) bind(c)
  import :: c_ptr
  type(c_ptr), value :: array
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_set_free_func (GPtrArray *array, GDestroyNotify element_free_func);
subroutine g_ptr_array_set_free_func(array, element_free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: element_free_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_set_size (GPtrArray *array, gint length);
subroutine g_ptr_array_set_size(array, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_ptr_array_remove_index (GPtrArray *array, guint index_);
function g_ptr_array_remove_index(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_ptr_array_remove_index_fast (GPtrArray *array, guint index_);
function g_ptr_array_remove_index_fast(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_ptr_array_steal_index (GPtrArray *array, guint index_);
function g_ptr_array_steal_index(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_steal_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_2_58
!gpointer g_ptr_array_steal_index_fast (GPtrArray *array, guint index_);
function g_ptr_array_steal_index_fast(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_steal_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_ptr_array_remove (GPtrArray *array, gpointer data);
function g_ptr_array_remove(array, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_ptr_array_remove
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_ptr_array_remove_fast (GPtrArray *array, gpointer data);
function g_ptr_array_remove_fast(array, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_ptr_array_remove_fast
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GPtrArray *g_ptr_array_remove_range (GPtrArray *array, guint index_, guint length);
function g_ptr_array_remove_range(array, index_, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_add (GPtrArray *array, gpointer data);
subroutine g_ptr_array_add(array, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_ptr_array_extend (GPtrArray *array_to_extend, GPtrArray *array, GCopyFunc func, gpointer user_data);
subroutine g_ptr_array_extend(array_to_extend, array, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array_to_extend
  type(c_ptr), value :: array
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_ptr_array_extend_and_steal (GPtrArray *array_to_extend, GPtrArray *array);
subroutine g_ptr_array_extend_and_steal(array_to_extend, array) bind(c)
  import :: c_ptr
  type(c_ptr), value :: array_to_extend
  type(c_ptr), value :: array
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_ptr_array_insert (GPtrArray *array, gint index_, gpointer data);
subroutine g_ptr_array_insert(array, index_, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_sort (GPtrArray *array, GCompareFunc compare_func);
subroutine g_ptr_array_sort(array, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_sort_with_data (GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_ptr_array_sort_with_data(array, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_ptr_array_foreach (GPtrArray *array, GFunc func, gpointer user_data);
subroutine g_ptr_array_foreach(array, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_54
!gboolean g_ptr_array_find (GPtrArray *haystack, gconstpointer needle, guint *index_);
function g_ptr_array_find(haystack, needle, index_) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_ptr_array_find
  type(c_ptr), value :: haystack
  type(c_ptr), value :: needle
  type(c_ptr), value :: index_
end function

! GLIB_AVAILABLE_IN_2_54
!gboolean g_ptr_array_find_with_equal_func (GPtrArray *haystack, gconstpointer needle, GEqualFunc equal_func, guint *index_);
function g_ptr_array_find_with_equal_func(haystack, needle, equal_func, index_)&
& bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_ptr_array_find_with_equal_func
  type(c_ptr), value :: haystack
  type(c_ptr), value :: needle
  type(c_funptr), value :: equal_func
  type(c_ptr), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_new (void);
function g_byte_array_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_byte_array_new
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_new_take (guint8 *data, gsize len);
function g_byte_array_new_take(data, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_byte_array_new_take
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_2_64
!guint8* g_byte_array_steal (GByteArray *array, gsize *len);
function g_byte_array_steal(array, len) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_byte_array_steal
  type(c_ptr), value :: array
  type(c_ptr), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_sized_new (guint reserved_size);
function g_byte_array_sized_new(reserved_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_sized_new
  integer(c_int), value :: reserved_size
end function

! GLIB_AVAILABLE_IN_ALL
!guint8* g_byte_array_free (GByteArray *array, gboolean free_segment);
function g_byte_array_free(array, free_segment) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_segment
end function

! GLIB_AVAILABLE_IN_ALL
!GBytes* g_byte_array_free_to_bytes (GByteArray *array);
function g_byte_array_free_to_bytes(array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_byte_array_free_to_bytes
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray *g_byte_array_ref (GByteArray *array);
function g_byte_array_ref(array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_byte_array_ref
  type(c_ptr), value :: array
end function

! GLIB_AVAILABLE_IN_ALL
!void g_byte_array_unref (GByteArray *array);
subroutine g_byte_array_unref(array) bind(c)
  import :: c_ptr
  type(c_ptr), value :: array
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_append (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_append(array, data, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_append
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_prepend (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_prepend(array, data, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_prepend
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_set_size (GByteArray *array, guint length);
function g_byte_array_set_size(array, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_remove_index (GByteArray *array, guint index_);
function g_byte_array_remove_index(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_remove_index_fast (GByteArray *array, guint index_);
function g_byte_array_remove_index_fast(array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GLIB_AVAILABLE_IN_ALL
!GByteArray* g_byte_array_remove_range (GByteArray *array, guint index_, guint length);
function g_byte_array_remove_range(array, index_, length) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_byte_array_sort (GByteArray *array, GCompareFunc compare_func);
subroutine g_byte_array_sort(array, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_byte_array_sort_with_data (GByteArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_byte_array_sort_with_data(array, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gdate.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GDate* g_date_new (void);
function g_date_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_new
end function

! GLIB_AVAILABLE_IN_ALL
!GDate* g_date_new_dmy (GDateDay day, GDateMonth month, GDateYear year);
function g_date_new_dmy(day, month, year) bind(c)
  import :: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr) :: g_date_new_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!GDate* g_date_new_julian (guint32 julian_day);
function g_date_new_julian(julian_day) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_date_new_julian
  integer(c_int32_t), value :: julian_day
end function

! GLIB_AVAILABLE_IN_ALL
!void g_date_free (GDate *date);
subroutine g_date_free(date) bind(c)
  import :: c_ptr
  type(c_ptr), value :: date
end subroutine

! GLIB_AVAILABLE_IN_2_56
!GDate* g_date_copy (const GDate *date);
function g_date_copy(date) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_date_copy
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid (const GDate *date);
function g_date_valid(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_valid
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_day (GDateDay day) G_GNUC_CONST;
function g_date_valid_day(day) bind(c)
  import :: c_int, c_int8_t
  integer(c_int) :: g_date_valid_day
  integer(c_int8_t), value :: day
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_month (GDateMonth month) G_GNUC_CONST;
function g_date_valid_month(month) bind(c)
  import :: c_int
  integer(c_int) :: g_date_valid_month
  integer(c_int), value :: month
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_year (GDateYear year) G_GNUC_CONST;
function g_date_valid_year(year) bind(c)
  import :: c_int, c_int16_t
  integer(c_int) :: g_date_valid_year
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_weekday (GDateWeekday weekday) G_GNUC_CONST;
function g_date_valid_weekday(weekday) bind(c)
  import :: c_int
  integer(c_int) :: g_date_valid_weekday
  integer(c_int), value :: weekday
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_julian (guint32 julian_date) G_GNUC_CONST;
function g_date_valid_julian(julian_date) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_date_valid_julian
  integer(c_int32_t), value :: julian_date
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_valid_dmy (GDateDay day, GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_valid_dmy(day, month, year) bind(c)
  import :: c_int, c_int8_t, c_int16_t
  integer(c_int) :: g_date_valid_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!GDateWeekday g_date_get_weekday (const GDate *date);
function g_date_get_weekday(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_weekday
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!GDateMonth g_date_get_month (const GDate *date);
function g_date_get_month(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_month
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!GDateYear g_date_get_year (const GDate *date);
function g_date_get_year(date) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_date_get_year
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!GDateDay g_date_get_day (const GDate *date);
function g_date_get_day(date) bind(c)
  import :: c_int8_t, c_ptr
  integer(c_int8_t) :: g_date_get_day
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!guint32 g_date_get_julian (const GDate *date);
function g_date_get_julian(date) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_date_get_julian
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_date_get_day_of_year (const GDate *date);
function g_date_get_day_of_year(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_day_of_year
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_date_get_monday_week_of_year (const GDate *date);
function g_date_get_monday_week_of_year(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_monday_week_of_year
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_date_get_sunday_week_of_year (const GDate *date);
function g_date_get_sunday_week_of_year(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_sunday_week_of_year
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_date_get_iso8601_week_of_year (const GDate *date);
function g_date_get_iso8601_week_of_year(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_get_iso8601_week_of_year
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!void g_date_clear (GDate *date, guint n_dates);
subroutine g_date_clear(date, n_dates) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_dates
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_parse (GDate *date, const gchar *str);
subroutine g_date_set_parse(date, str) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: date
  character(kind=c_char), dimension(*) :: str
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_time_t (GDate *date, time_t timet);
subroutine g_date_set_time_t(date, timet) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: date
  integer(c_long), value :: timet
end subroutine

! GLIB_DEPRECATED_IN_2_62_FOR(g_date_set_time_t)
!void g_date_set_time_val (GDate *date, GTimeVal *timeval);
subroutine g_date_set_time_val(date, timeval) bind(c)
  import :: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: timeval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_month (GDate *date, GDateMonth month);
subroutine g_date_set_month(date, month) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: month
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_day (GDate *date, GDateDay day);
subroutine g_date_set_day(date, day) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_year (GDate *date, GDateYear year);
subroutine g_date_set_year(date, year) bind(c)
  import :: c_ptr, c_int16_t
  type(c_ptr), value :: date
  integer(c_int16_t), value :: year
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_dmy (GDate *date, GDateDay day, GDateMonth month, GDateYear y);
subroutine g_date_set_dmy(date, day, month, y) bind(c)
  import :: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: y
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_set_julian (GDate *date, guint32 julian_date);
subroutine g_date_set_julian(date, julian_date) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: date
  integer(c_int32_t), value :: julian_date
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_is_first_of_month (const GDate *date);
function g_date_is_first_of_month(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_is_first_of_month
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_is_last_of_month (const GDate *date);
function g_date_is_last_of_month(date) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_is_last_of_month
  type(c_ptr), value :: date
end function

! GLIB_AVAILABLE_IN_ALL
!void g_date_add_days (GDate *date, guint n_days);
subroutine g_date_add_days(date, n_days) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_subtract_days (GDate *date, guint n_days);
subroutine g_date_subtract_days(date, n_days) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_add_months (GDate *date, guint n_months);
subroutine g_date_add_months(date, n_months) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_subtract_months (GDate *date, guint n_months);
subroutine g_date_subtract_months(date, n_months) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_add_years (GDate *date, guint n_years);
subroutine g_date_add_years(date, n_years) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_subtract_years (GDate *date, guint n_years);
subroutine g_date_subtract_years(date, n_years) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_date_is_leap_year (GDateYear year) G_GNUC_CONST;
function g_date_is_leap_year(year) bind(c)
  import :: c_int, c_int16_t
  integer(c_int) :: g_date_is_leap_year
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!guint8 g_date_get_days_in_month (GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_get_days_in_month(month, year) bind(c)
  import :: c_int8_t, c_int, c_int16_t
  integer(c_int8_t) :: g_date_get_days_in_month
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!guint8 g_date_get_monday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_monday_weeks_in_year(year) bind(c)
  import :: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_monday_weeks_in_year
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!guint8 g_date_get_sunday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_sunday_weeks_in_year(year) bind(c)
  import :: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_sunday_weeks_in_year
  integer(c_int16_t), value :: year
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_days_between (const GDate *date1, const GDate *date2);
function g_date_days_between(date1, date2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_days_between
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_date_compare (const GDate *lhs, const GDate *rhs);
function g_date_compare(lhs, rhs) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_date_compare
  type(c_ptr), value :: lhs
  type(c_ptr), value :: rhs
end function

! GLIB_AVAILABLE_IN_ALL
!void g_date_to_struct_tm (const GDate *date, struct tm *tm);
subroutine g_date_to_struct_tm(date, tm) bind(c)
  import :: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: tm
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_clamp (GDate *date, const GDate *min_date, const GDate *max_date);
subroutine g_date_clamp(date, min_date, max_date) bind(c)
  import :: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: min_date
  type(c_ptr), value :: max_date
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_date_order (GDate *date1, GDate *date2);
subroutine g_date_order(date1, date2) bind(c)
  import :: c_ptr
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gsize g_date_strftime (gchar *s, gsize slen, const gchar *format, const GDate *date);
function g_date_strftime(s, slen, format, date) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_date_strftime
  character(kind=c_char), dimension(*) :: s
  integer(c_size_t), value :: slen
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: date
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gunicode.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!guint32 g_unicode_script_to_iso15924 (GUnicodeScript script);
function g_unicode_script_to_iso15924(script) bind(c)
  import :: c_int32_t, c_int
  integer(c_int32_t) :: g_unicode_script_to_iso15924
  integer(c_int), value :: script
end function

! GLIB_AVAILABLE_IN_ALL
!GUnicodeScript g_unicode_script_from_iso15924 (guint32 iso15924);
function g_unicode_script_from_iso15924(iso15924) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unicode_script_from_iso15924
  integer(c_int32_t), value :: iso15924
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isalnum (gunichar c) G_GNUC_CONST;
function g_unichar_isalnum(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isalnum
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isalpha (gunichar c) G_GNUC_CONST;
function g_unichar_isalpha(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isalpha
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_iscntrl (gunichar c) G_GNUC_CONST;
function g_unichar_iscntrl(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_iscntrl
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isdigit(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isdigit
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isgraph (gunichar c) G_GNUC_CONST;
function g_unichar_isgraph(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isgraph
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_islower (gunichar c) G_GNUC_CONST;
function g_unichar_islower(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_islower
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isprint (gunichar c) G_GNUC_CONST;
function g_unichar_isprint(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isprint
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_ispunct (gunichar c) G_GNUC_CONST;
function g_unichar_ispunct(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_ispunct
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isspace (gunichar c) G_GNUC_CONST;
function g_unichar_isspace(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isspace
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isupper (gunichar c) G_GNUC_CONST;
function g_unichar_isupper(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isupper
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isxdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isxdigit(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isxdigit
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_istitle (gunichar c) G_GNUC_CONST;
function g_unichar_istitle(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_istitle
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_isdefined (gunichar c) G_GNUC_CONST;
function g_unichar_isdefined(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_isdefined
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_iswide (gunichar c) G_GNUC_CONST;
function g_unichar_iswide(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_iswide
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_iswide_cjk(gunichar c) G_GNUC_CONST;
function g_unichar_iswide_cjk(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_iswide_cjk
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_iszerowidth(gunichar c) G_GNUC_CONST;
function g_unichar_iszerowidth(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_iszerowidth
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_ismark (gunichar c) G_GNUC_CONST;
function g_unichar_ismark(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_ismark
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar g_unichar_toupper (gunichar c) G_GNUC_CONST;
function g_unichar_toupper(c) bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_unichar_toupper
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar g_unichar_tolower (gunichar c) G_GNUC_CONST;
function g_unichar_tolower(c) bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_unichar_tolower
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar g_unichar_totitle (gunichar c) G_GNUC_CONST;
function g_unichar_totitle(c) bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_unichar_totitle
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_unichar_digit_value (gunichar c) G_GNUC_CONST;
function g_unichar_digit_value(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_digit_value
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_unichar_xdigit_value (gunichar c) G_GNUC_CONST;
function g_unichar_xdigit_value(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_xdigit_value
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!GUnicodeType g_unichar_type (gunichar c) G_GNUC_CONST;
function g_unichar_type(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_type
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!GUnicodeBreakType g_unichar_break_type (gunichar c) G_GNUC_CONST;
function g_unichar_break_type(c) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_break_type
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_unichar_combining_class (gunichar uc) G_GNUC_CONST;
function g_unichar_combining_class(uc) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_combining_class
  integer(c_int32_t), value :: uc
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_get_mirror_char (gunichar ch, gunichar *mirrored_ch);
function g_unichar_get_mirror_char(ch, mirrored_ch) bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_get_mirror_char
  integer(c_int32_t), value :: ch
  character(kind=c_char), dimension(*) :: mirrored_ch
end function

! GLIB_AVAILABLE_IN_ALL
!GUnicodeScript g_unichar_get_script (gunichar ch) G_GNUC_CONST;
function g_unichar_get_script(ch) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_get_script
  integer(c_int32_t), value :: ch
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_validate (gunichar ch) G_GNUC_CONST;
function g_unichar_validate(ch) bind(c)
  import :: c_int, c_int32_t
  integer(c_int) :: g_unichar_validate
  integer(c_int32_t), value :: ch
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_compose (gunichar a, gunichar b, gunichar *ch);
function g_unichar_compose(a, b, ch) bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_compose
  integer(c_int32_t), value :: a
  integer(c_int32_t), value :: b
  character(kind=c_char), dimension(*) :: ch
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unichar_decompose (gunichar ch, gunichar *a, gunichar *b);
function g_unichar_decompose(ch, a, b) bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_decompose
  integer(c_int32_t), value :: ch
  character(kind=c_char), dimension(*) :: a
  character(kind=c_char), dimension(*) :: b
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_unichar_fully_decompose (gunichar ch, gboolean compat, gunichar *result, gsize result_len);
function g_unichar_fully_decompose(ch, compat, result, result_len) bind(c)
  import :: c_size_t, c_int32_t, c_int, c_char
  integer(c_size_t) :: g_unichar_fully_decompose
  integer(c_int32_t), value :: ch
  integer(c_int), value :: compat
  character(kind=c_char), dimension(*) :: result
  integer(c_size_t), value :: result_len
end function

! GLIB_AVAILABLE_IN_ALL
!void g_unicode_canonical_ordering (gunichar *string, gsize len);
subroutine g_unicode_canonical_ordering(string, len) bind(c)
  import :: c_char, c_size_t
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end subroutine

! GLIB_DEPRECATED_IN_2_30
!gunichar *g_unicode_canonical_decomposition (gunichar ch, gsize *result_len) G_GNUC_MALLOC;
function g_unicode_canonical_decomposition(ch, result_len) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_unicode_canonical_decomposition
  integer(c_int32_t), value :: ch
  type(c_ptr), value :: result_len
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar g_utf8_get_char (const gchar *p) G_GNUC_PURE;
function g_utf8_get_char(p) bind(c)
  import :: c_int32_t, c_char
  integer(c_int32_t) :: g_utf8_get_char
  character(kind=c_char), dimension(*) :: p
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar g_utf8_get_char_validated (const gchar *p, gssize max_len) G_GNUC_PURE;
function g_utf8_get_char_validated(p, max_len) bind(c)
  import :: c_int32_t, c_char, c_size_t
  integer(c_int32_t) :: g_utf8_get_char_validated
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max_len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_offset_to_pointer (const gchar *str, glong offset) G_GNUC_PURE;
function g_utf8_offset_to_pointer(str, offset) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_offset_to_pointer
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: offset
end function

! GLIB_AVAILABLE_IN_ALL
!glong g_utf8_pointer_to_offset (const gchar *str, const gchar *pos) G_GNUC_PURE;
function g_utf8_pointer_to_offset(str, pos) bind(c)
  import :: c_long, c_char
  integer(c_long) :: g_utf8_pointer_to_offset
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: pos
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_prev_char (const gchar *p) G_GNUC_PURE;
function g_utf8_prev_char(p) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_utf8_prev_char
  character(kind=c_char), dimension(*) :: p
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_find_next_char (const gchar *p, const gchar *end) G_GNUC_PURE;
function g_utf8_find_next_char(p, end) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_next_char
  character(kind=c_char), dimension(*) :: p
  character(kind=c_char), dimension(*) :: end
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_find_prev_char (const gchar *str, const gchar *p) G_GNUC_PURE;
function g_utf8_find_prev_char(str, p) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_prev_char
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: p
end function

! GLIB_AVAILABLE_IN_ALL
!glong g_utf8_strlen (const gchar *p, gssize max) G_GNUC_PURE;
function g_utf8_strlen(p, max) bind(c)
  import :: c_long, c_char, c_size_t
  integer(c_long) :: g_utf8_strlen
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_utf8_substring (const gchar *str, glong start_pos, glong end_pos) G_GNUC_MALLOC;
function g_utf8_substring(str, start_pos, end_pos) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_substring
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: start_pos
  integer(c_long), value :: end_pos
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_strncpy (gchar *dest, const gchar *src, gsize n);
function g_utf8_strncpy(dest, src, n) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strncpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_strchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strchr(p, len, c) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_strrchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strrchr(p, len, c) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strrchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf8_strreverse (const gchar *str, gssize len);
function g_utf8_strreverse(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strreverse
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_utf16(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar * g_utf8_to_ucs4 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_ucs4(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar * g_utf8_to_ucs4_fast (const gchar *str, glong len, glong *items_written) G_GNUC_MALLOC;
function g_utf8_to_ucs4_fast(str, len, items_written) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4_fast
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_written
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar * g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_ucs4(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_utf8(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gunichar2 *g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf16(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_ucs4_to_utf8 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf8(str, len, items_read, items_written, error) bind(c)
  import :: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_unichar_to_utf8 (gunichar c, gchar *outbuf);
function g_unichar_to_utf8(c, outbuf) bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_to_utf8
  integer(c_int32_t), value :: c
  character(kind=c_char), dimension(*) :: outbuf
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_utf8_validate (const gchar *str, gssize max_len, const gchar **end);
function g_utf8_validate(str, max_len, end) bind(c)
  import :: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_utf8_validate
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: max_len
  type(c_ptr), dimension(*) :: end
end function

! GLIB_AVAILABLE_IN_2_60
!gboolean g_utf8_validate_len (const gchar *str, gsize max_len, const gchar **end);
function g_utf8_validate_len(str, max_len, end) bind(c)
  import :: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_utf8_validate_len
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: max_len
  type(c_ptr), dimension(*) :: end
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strup(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strdown(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_casefold (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_casefold(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_casefold
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_normalize (const gchar *str, gssize len, GNormalizeMode mode) G_GNUC_MALLOC;
function g_utf8_normalize(str, len, mode) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_utf8_normalize
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  integer(c_int), value :: mode
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_utf8_collate (const gchar *str1, const gchar *str2) G_GNUC_PURE;
function g_utf8_collate(str1, str2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_utf8_collate
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_collate_key (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_utf8_collate_key_for_filename (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key_for_filename(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key_for_filename
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_2_52
!gchar *g_utf8_make_valid (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_make_valid(str, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_make_valid
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gthreadpool.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GThreadPool * g_thread_pool_new (GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error);
function g_thread_pool_new(func, user_data, max_threads, exclusive, error)&
& bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_thread_pool_new
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  integer(c_int), value :: max_threads
  integer(c_int), value :: exclusive
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_70
!GThreadPool * g_thread_pool_new_full (GFunc func, gpointer user_data, GDestroyNotify item_free_func, gint max_threads, gboolean exclusive, GError **error);
function g_thread_pool_new_full(func, user_data, item_free_func, max_threads,&
& exclusive, error) bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_thread_pool_new_full
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: item_free_func
  integer(c_int), value :: max_threads
  integer(c_int), value :: exclusive
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_pool_free (GThreadPool *pool, gboolean immediate, gboolean wait_);
subroutine g_thread_pool_free(pool, immediate, wait_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: pool
  integer(c_int), value :: immediate
  integer(c_int), value :: wait_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_thread_pool_push (GThreadPool *pool, gpointer data, GError **error);
function g_thread_pool_push(pool, data, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_push
  type(c_ptr), value :: pool
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_thread_pool_unprocessed (GThreadPool *pool);
function g_thread_pool_unprocessed(pool) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_unprocessed
  type(c_ptr), value :: pool
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_pool_set_sort_function (GThreadPool *pool, GCompareDataFunc func, gpointer user_data);
subroutine g_thread_pool_set_sort_function(pool, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: pool
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_46
!gboolean g_thread_pool_move_to_front (GThreadPool *pool, gpointer data);
function g_thread_pool_move_to_front(pool, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_move_to_front
  type(c_ptr), value :: pool
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_thread_pool_set_max_threads (GThreadPool *pool, gint max_threads, GError **error);
function g_thread_pool_set_max_threads(pool, max_threads, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_set_max_threads
  type(c_ptr), value :: pool
  integer(c_int), value :: max_threads
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_thread_pool_get_max_threads (GThreadPool *pool);
function g_thread_pool_get_max_threads(pool) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_max_threads
  type(c_ptr), value :: pool
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_thread_pool_get_num_threads (GThreadPool *pool);
function g_thread_pool_get_num_threads(pool) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_num_threads
  type(c_ptr), value :: pool
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_pool_set_max_unused_threads (gint max_threads);
subroutine g_thread_pool_set_max_unused_threads(max_threads) bind(c)
  import :: c_int
  integer(c_int), value :: max_threads
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_thread_pool_get_max_unused_threads (void);
function g_thread_pool_get_max_unused_threads() bind(c)
  import :: c_int
  integer(c_int) :: g_thread_pool_get_max_unused_threads
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_thread_pool_get_num_unused_threads (void);
function g_thread_pool_get_num_unused_threads() bind(c)
  import :: c_int
  integer(c_int) :: g_thread_pool_get_num_unused_threads
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_pool_stop_unused_threads (void);
subroutine g_thread_pool_stop_unused_threads() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_thread_pool_set_max_idle_time (guint interval);
subroutine g_thread_pool_set_max_idle_time(interval) bind(c)
  import :: c_int
  integer(c_int), value :: interval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_thread_pool_get_max_idle_time (void);
function g_thread_pool_get_max_idle_time() bind(c)
  import :: c_int
  integer(c_int) :: g_thread_pool_get_max_idle_time
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/ghook.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_init (GHookList *hook_list, guint hook_size);
subroutine g_hook_list_init(hook_list, hook_size) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: hook_size
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_clear (GHookList *hook_list);
subroutine g_hook_list_clear(hook_list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_alloc (GHookList *hook_list);
function g_hook_alloc(hook_list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hook_alloc
  type(c_ptr), value :: hook_list
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hook_free (GHookList *hook_list, GHook *hook);
subroutine g_hook_free(hook_list, hook) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GHook * g_hook_ref (GHookList *hook_list, GHook *hook);
function g_hook_ref(hook_list, hook) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hook_ref
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hook_unref (GHookList *hook_list, GHook *hook);
subroutine g_hook_unref(hook_list, hook) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hook_destroy (GHookList *hook_list, gulong hook_id);
function g_hook_destroy(hook_list, hook_id) bind(c)
  import :: c_int, c_ptr, c_long
  integer(c_int) :: g_hook_destroy
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hook_destroy_link (GHookList *hook_list, GHook *hook);
subroutine g_hook_destroy_link(hook_list, hook) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_prepend (GHookList *hook_list, GHook *hook);
subroutine g_hook_prepend(hook_list, hook) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_insert_before (GHookList *hook_list, GHook *sibling, GHook *hook);
subroutine g_hook_insert_before(hook_list, sibling, hook) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: hook
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_insert_sorted (GHookList *hook_list, GHook *hook, GHookCompareFunc func);
subroutine g_hook_insert_sorted(hook_list, hook, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  type(c_funptr), value :: func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_get (GHookList *hook_list, gulong hook_id);
function g_hook_get(hook_list, hook_id) bind(c)
  import :: c_ptr, c_long
  type(c_ptr) :: g_hook_get
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_find (GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
function g_hook_find(hook_list, need_valids, func, data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_hook_find
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_find_data (GHookList *hook_list, gboolean need_valids, gpointer data);
function g_hook_find_data(hook_list, need_valids, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_hook_find_data
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_find_func (GHookList *hook_list, gboolean need_valids, gpointer func);
function g_hook_find_func(hook_list, need_valids, func) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_hook_find_func
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_find_func_data (GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data);
function g_hook_find_func_data(hook_list, need_valids, func, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_hook_find_func_data
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_first_valid (GHookList *hook_list, gboolean may_be_in_call);
function g_hook_first_valid(hook_list, may_be_in_call) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_hook_first_valid
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_be_in_call
end function

! GLIB_AVAILABLE_IN_ALL
!GHook* g_hook_next_valid (GHookList *hook_list, GHook *hook, gboolean may_be_in_call);
function g_hook_next_valid(hook_list, hook, may_be_in_call) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_hook_next_valid
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  integer(c_int), value :: may_be_in_call
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_hook_compare_ids (GHook *new_hook, GHook *sibling);
function g_hook_compare_ids(new_hook, sibling) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_hook_compare_ids
  type(c_ptr), value :: new_hook
  type(c_ptr), value :: sibling
end function

! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_invoke (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke(hook_list, may_recurse) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_invoke_check (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke_check(hook_list, may_recurse) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_marshal (GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal(hook_list, may_recurse, marshaller,&
& marshal_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_hook_list_marshal_check (GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal_check(hook_list, may_recurse, marshaller,&
& marshal_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/ghmac.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_30
!GHmac * g_hmac_new (GChecksumType digest_type, const guchar *key, gsize key_len);
function g_hmac_new(digest_type, key, key_len) bind(c)
  import :: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_hmac_new
  integer(c_int), value :: digest_type
  character(kind=c_char), dimension(*) :: key
  integer(c_size_t), value :: key_len
end function

! GLIB_AVAILABLE_IN_2_30
!GHmac * g_hmac_copy (const GHmac *hmac);
function g_hmac_copy(hmac) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hmac_copy
  type(c_ptr), value :: hmac
end function

! GLIB_AVAILABLE_IN_2_30
!GHmac * g_hmac_ref (GHmac *hmac);
function g_hmac_ref(hmac) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hmac_ref
  type(c_ptr), value :: hmac
end function

! GLIB_AVAILABLE_IN_2_30
!void g_hmac_unref (GHmac *hmac);
subroutine g_hmac_unref(hmac) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hmac
end subroutine

! GLIB_AVAILABLE_IN_2_30
!void g_hmac_update (GHmac *hmac, const guchar *data, gssize length);
subroutine g_hmac_update(hmac, data, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: hmac
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_2_30
!const gchar * g_hmac_get_string (GHmac *hmac);
function g_hmac_get_string(hmac) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_hmac_get_string
  type(c_ptr), value :: hmac
end function

! GLIB_AVAILABLE_IN_2_30
!void g_hmac_get_digest (GHmac *hmac, guint8 *buffer, gsize *digest_len);
subroutine g_hmac_get_digest(hmac, buffer, digest_len) bind(c)
  import :: c_ptr
  type(c_ptr), value :: hmac
  type(c_ptr), value :: buffer
  type(c_ptr), value :: digest_len
end subroutine

! GLIB_AVAILABLE_IN_2_30
!gchar *g_compute_hmac_for_data (GChecksumType digest_type, const guchar *key, gsize key_len, const guchar *data, gsize length);
function g_compute_hmac_for_data(digest_type, key, key_len, data, length)&
& bind(c)
  import :: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_hmac_for_data
  integer(c_int), value :: digest_type
  character(kind=c_char), dimension(*) :: key
  integer(c_size_t), value :: key_len
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_2_30
!gchar *g_compute_hmac_for_string (GChecksumType digest_type, const guchar *key, gsize key_len, const gchar *str, gssize length);
function g_compute_hmac_for_string(digest_type, key, key_len, str, length)&
& bind(c)
  import :: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_hmac_for_string
  integer(c_int), value :: digest_type
  character(kind=c_char), dimension(*) :: key
  integer(c_size_t), value :: key_len
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_2_50
!gchar *g_compute_hmac_for_bytes (GChecksumType digest_type, GBytes *key, GBytes *data);
function g_compute_hmac_for_bytes(digest_type, key, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_compute_hmac_for_bytes
  integer(c_int), value :: digest_type
  type(c_ptr), value :: key
  type(c_ptr), value :: data
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gdir.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GDir * g_dir_open (const gchar *path, guint flags, GError **error);
function g_dir_open(path, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dir_open
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_dir_read_name (GDir *dir);
function g_dir_read_name(dir) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dir_read_name
  type(c_ptr), value :: dir
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dir_rewind (GDir *dir);
subroutine g_dir_rewind(dir) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dir
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dir_close (GDir *dir);
subroutine g_dir_close(dir) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dir
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmarkup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_markup_error_quark (void);
function g_markup_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_markup_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
function g_markup_parse_context_new(parser, flags, user_data,&
& user_data_dnotify) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_markup_parse_context_new
  type(c_ptr), value :: parser
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_dnotify
end function

! GLIB_AVAILABLE_IN_2_36
!GMarkupParseContext *g_markup_parse_context_ref (GMarkupParseContext *context);
function g_markup_parse_context_ref(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_markup_parse_context_ref
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_2_36
!void g_markup_parse_context_unref (GMarkupParseContext *context);
subroutine g_markup_parse_context_unref(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_markup_parse_context_free (GMarkupParseContext *context);
subroutine g_markup_parse_context_free(context) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_markup_parse_context_parse (GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error);
function g_markup_parse_context_parse(context, text, text_len, error) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_markup_parse_context_parse
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: text_len
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_markup_parse_context_push (GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data);
subroutine g_markup_parse_context_push(context, parser, user_data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: parser
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_markup_parse_context_pop (GMarkupParseContext *context);
function g_markup_parse_context_pop(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_markup_parse_context_pop
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context, GError **error);
function g_markup_parse_context_end_parse(context, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_markup_parse_context_end_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_markup_parse_context_get_element (GMarkupParseContext *context);
function g_markup_parse_context_get_element(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!const GSList * g_markup_parse_context_get_element_stack (GMarkupParseContext *context);
function g_markup_parse_context_get_element_stack(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element_stack
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!void g_markup_parse_context_get_position (GMarkupParseContext *context, gint *line_number, gint *char_number);
subroutine g_markup_parse_context_get_position(context, line_number,&
& char_number) bind(c)
  import :: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: line_number
  type(c_ptr), value :: char_number
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_markup_parse_context_get_user_data (GMarkupParseContext *context);
function g_markup_parse_context_get_user_data(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_user_data
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_markup_escape_text (const gchar *text, gssize length);
function g_markup_escape_text(text, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_markup_escape_text
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_markup_vprintf_escaped (const char *format, va_list args) G_GNUC_PRINTF(1, 0);
function g_markup_vprintf_escaped(format, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_markup_vprintf_escaped
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtree.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GTree* g_tree_new (GCompareFunc key_compare_func);
function g_tree_new(key_compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new
  type(c_funptr), value :: key_compare_func
end function

! GLIB_AVAILABLE_IN_ALL
!GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func, gpointer key_compare_data);
function g_tree_new_with_data(key_compare_func, key_compare_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_with_data
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
end function

! GLIB_AVAILABLE_IN_ALL
!GTree* g_tree_new_full (GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func,&
& value_destroy_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_full
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_node_first (GTree *tree);
function g_tree_node_first(tree) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_first
  type(c_ptr), value :: tree
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_node_last (GTree *tree);
function g_tree_node_last(tree) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_last
  type(c_ptr), value :: tree
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_node_previous (GTreeNode *node);
function g_tree_node_previous(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_previous
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_node_next (GTreeNode *node);
function g_tree_node_next(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_next
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GTree* g_tree_ref (GTree *tree);
function g_tree_ref(tree) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_ref
  type(c_ptr), value :: tree
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tree_unref (GTree *tree);
subroutine g_tree_unref(tree) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_tree_destroy (GTree *tree);
subroutine g_tree_destroy(tree) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
end subroutine

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_insert_node (GTree *tree, gpointer key, gpointer value);
function g_tree_insert_node(tree, key, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_insert_node
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tree_insert (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_insert(tree, key, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_replace_node (GTree *tree, gpointer key, gpointer value);
function g_tree_replace_node(tree, key, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_replace_node
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tree_replace (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_replace(tree, key, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tree_remove (GTree *tree, gconstpointer key);
function g_tree_remove(tree, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tree_remove
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_70
!void g_tree_remove_all (GTree *tree);
subroutine g_tree_remove_all(tree) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tree_steal (GTree *tree, gconstpointer key);
function g_tree_steal(tree, key) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tree_steal
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_68
!gpointer g_tree_node_key (GTreeNode *node);
function g_tree_node_key(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_key
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_2_68
!gpointer g_tree_node_value (GTreeNode *node);
function g_tree_node_value(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_node_value
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_lookup_node (GTree *tree, gconstpointer key);
function g_tree_lookup_node(tree, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_lookup_node
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_tree_lookup (GTree *tree, gconstpointer key);
function g_tree_lookup(tree, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_lookup
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tree_lookup_extended (GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_tree_lookup_extended(tree, lookup_key, orig_key, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tree_lookup_extended
  type(c_ptr), value :: tree
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tree_foreach (GTree *tree, GTraverseFunc func, gpointer user_data);
subroutine g_tree_foreach(tree, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: tree
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_68
!void g_tree_foreach_node (GTree *tree, GTraverseNodeFunc func, gpointer user_data);
subroutine g_tree_foreach_node(tree, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: tree
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED
!void g_tree_traverse (GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
subroutine g_tree_traverse(tree, traverse_func, traverse_type, user_data)&
& bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr), value :: tree
  type(c_funptr), value :: traverse_func
  integer(c_int), value :: traverse_type
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_search_node (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
function g_tree_search_node(tree, search_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_tree_search_node
  type(c_ptr), value :: tree
  type(c_funptr), value :: search_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_tree_search (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
function g_tree_search(tree, search_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_tree_search
  type(c_ptr), value :: tree
  type(c_funptr), value :: search_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_lower_bound (GTree *tree, gconstpointer key);
function g_tree_lower_bound(tree, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_lower_bound
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_68
!GTreeNode *g_tree_upper_bound (GTree *tree, gconstpointer key);
function g_tree_upper_bound(tree, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tree_upper_bound
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_tree_height (GTree *tree);
function g_tree_height(tree) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tree_height
  type(c_ptr), value :: tree
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_tree_nnodes (GTree *tree);
function g_tree_nnodes(tree) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tree_nnodes
  type(c_ptr), value :: tree
end function

! 
!void g_tree_dump (GTree *tree);
subroutine g_tree_dump(tree) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/glist.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GList* g_list_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_list_alloc() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_alloc
end function

! GLIB_AVAILABLE_IN_ALL
!void g_list_free (GList *list);
subroutine g_list_free(list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_list_free_1 (GList *list);
subroutine g_list_free_1(list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_list_free_full (GList *list, GDestroyNotify free_func);
subroutine g_list_free_full(list, free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: free_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_append (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_append(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_prepend (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_prepend(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_insert (GList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert(list, data, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_insert_sorted (GList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted(list, data, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_insert_sorted_with_data (GList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted_with_data(list, data, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_insert_before (GList *list, GList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_before(list, sibling, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_insert_before
  type(c_ptr), value :: list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_2_62
!GList* g_list_insert_before_link (GList *list, GList *sibling, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_before_link(list, sibling, link_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_insert_before_link
  type(c_ptr), value :: list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: link_
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_concat (GList *list1, GList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_list_concat(list1, list2) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_remove (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_remove_all (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_all(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_remove_link (GList *list, GList *llink) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_link(list, llink) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_delete_link (GList *list, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_list_delete_link(list, link_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_reverse (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_reverse(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_reverse
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_copy (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_copy(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_copy
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_2_34
!GList* g_list_copy_deep (GList *list, GCopyFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_copy_deep(list, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_copy_deep
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_nth (GList *list, guint n);
function g_list_nth(list, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_nth_prev (GList *list, guint n);
function g_list_nth_prev(list, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_nth_prev
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_find (GList *list, gconstpointer data);
function g_list_find(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_find_custom (GList *list, gconstpointer data, GCompareFunc func);
function g_list_find_custom(list, data, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_list_position (GList *list, GList *llink);
function g_list_position(list, llink) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_list_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_list_index (GList *list, gconstpointer data);
function g_list_index(list, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_list_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_last (GList *list);
function g_list_last(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_last
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_first (GList *list);
function g_list_first(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_list_first
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_list_length (GList *list);
function g_list_length(list) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_list_length
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!void g_list_foreach (GList *list, GFunc func, gpointer user_data);
subroutine g_list_foreach(list, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_sort (GList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort(list, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_list_sort_with_data (GList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort_with_data(list, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_list_nth_data (GList *list, guint n);
function g_list_nth_data(list, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_2_64
!void g_clear_list (GList **list_ptr, GDestroyNotify destroy);
subroutine g_clear_list(list_ptr, destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: list_ptr
  type(c_funptr), value :: destroy
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gerror.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_68
!GQuark g_error_domain_register_static (const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
function g_error_domain_register_static(error_type_name,&
& error_type_private_size, error_type_init, error_type_copy, error_type_clear)&
& bind(c)
  import :: c_int32_t, c_char, c_size_t, c_funptr
  integer(c_int32_t) :: g_error_domain_register_static
  character(kind=c_char), dimension(*) :: error_type_name
  integer(c_size_t), value :: error_type_private_size
  type(c_funptr), value :: error_type_init
  type(c_funptr), value :: error_type_copy
  type(c_funptr), value :: error_type_clear
end function

! GLIB_AVAILABLE_IN_2_68
!GQuark g_error_domain_register (const char *error_type_name, gsize error_type_private_size, GErrorInitFunc error_type_init, GErrorCopyFunc error_type_copy, GErrorClearFunc error_type_clear);
function g_error_domain_register(error_type_name, error_type_private_size,&
& error_type_init, error_type_copy, error_type_clear) bind(c)
  import :: c_int32_t, c_char, c_size_t, c_funptr
  integer(c_int32_t) :: g_error_domain_register
  character(kind=c_char), dimension(*) :: error_type_name
  integer(c_size_t), value :: error_type_private_size
  type(c_funptr), value :: error_type_init
  type(c_funptr), value :: error_type_copy
  type(c_funptr), value :: error_type_clear
end function

! GLIB_AVAILABLE_IN_ALL
!GError* g_error_new_literal (GQuark domain, gint code, const gchar *message);
function g_error_new_literal(domain, code, message) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_literal
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end function

! GLIB_AVAILABLE_IN_ALL
!GError* g_error_new_valist (GQuark domain, gint code, const gchar *format, va_list args) G_GNUC_PRINTF(3, 0);
function g_error_new_valist(domain, code, format, args) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_valist
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!void g_error_free (GError *error);
subroutine g_error_free(error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: error
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GError* g_error_copy (const GError *error);
function g_error_copy(error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_error_copy
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_error_matches (const GError *error, GQuark domain, gint code);
function g_error_matches(error, domain, code) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_error_matches
  type(c_ptr), value :: error
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
end function

! GLIB_AVAILABLE_IN_ALL
!void g_set_error_literal (GError **err, GQuark domain, gint code, const gchar *message);
subroutine g_set_error_literal(err, domain, code, message) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: err
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_propagate_error (GError **dest, GError *src);
subroutine g_propagate_error(dest, src) bind(c)
  import :: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: src
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_clear_error (GError **err);
subroutine g_clear_error(err) bind(c)
  import :: c_ptr
  type(c_ptr), value :: err
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_prefix_error_literal (GError **err, const gchar *prefix);
subroutine g_prefix_error_literal(err, prefix) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: err
  character(kind=c_char), dimension(*) :: prefix
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gnode.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_new (gpointer data);
function g_node_new(data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_new
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_node_destroy (GNode *root);
subroutine g_node_destroy(root) bind(c)
  import :: c_ptr
  type(c_ptr), value :: root
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_node_unlink (GNode *node);
subroutine g_node_unlink(node) bind(c)
  import :: c_ptr
  type(c_ptr), value :: node
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_copy_deep (GNode *node, GCopyFunc copy_func, gpointer data);
function g_node_copy_deep(node, copy_func, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_node_copy_deep
  type(c_ptr), value :: node
  type(c_funptr), value :: copy_func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_copy (GNode *node);
function g_node_copy(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_copy
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_insert (GNode *parent, gint position, GNode *node);
function g_node_insert(parent, position, node) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_node_insert
  type(c_ptr), value :: parent
  integer(c_int), value :: position
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_insert_before (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_before(parent, sibling, node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_insert_before
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_insert_after (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_after(parent, sibling, node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_insert_after
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_prepend (GNode *parent, GNode *node);
function g_node_prepend(parent, node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_prepend
  type(c_ptr), value :: parent
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_node_n_nodes (GNode *root, GTraverseFlags flags);
function g_node_n_nodes(root, flags) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_n_nodes
  type(c_ptr), value :: root
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_get_root (GNode *node);
function g_node_get_root(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_get_root
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_node_is_ancestor (GNode *node, GNode *descendant);
function g_node_is_ancestor(node, descendant) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_is_ancestor
  type(c_ptr), value :: node
  type(c_ptr), value :: descendant
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_node_depth (GNode *node);
function g_node_depth(node) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_depth
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_find (GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data);
function g_node_find(root, order, flags, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_node_find
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_node_traverse (GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
subroutine g_node_traverse(root, order, flags, max_depth, func, data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  integer(c_int), value :: max_depth
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_node_max_height (GNode *root);
function g_node_max_height(root) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_max_height
  type(c_ptr), value :: root
end function

! GLIB_AVAILABLE_IN_ALL
!void g_node_children_foreach (GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
subroutine g_node_children_foreach(node, flags, func, data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_node_reverse_children (GNode *node);
subroutine g_node_reverse_children(node) bind(c)
  import :: c_ptr
  type(c_ptr), value :: node
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_node_n_children (GNode *node);
function g_node_n_children(node) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_n_children
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_nth_child (GNode *node, guint n);
function g_node_nth_child(node, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_node_nth_child
  type(c_ptr), value :: node
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_last_child (GNode *node);
function g_node_last_child(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_last_child
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_find_child (GNode *node, GTraverseFlags flags, gpointer data);
function g_node_find_child(node, flags, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_node_find_child
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_node_child_position (GNode *node, GNode *child);
function g_node_child_position(node, child) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_child_position
  type(c_ptr), value :: node
  type(c_ptr), value :: child
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_node_child_index (GNode *node, gpointer data);
function g_node_child_index(node, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_node_child_index
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_first_sibling (GNode *node);
function g_node_first_sibling(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_first_sibling
  type(c_ptr), value :: node
end function

! GLIB_AVAILABLE_IN_ALL
!GNode* g_node_last_sibling (GNode *node);
function g_node_last_sibling(node) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_node_last_sibling
  type(c_ptr), value :: node
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gstringchunk.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GStringChunk* g_string_chunk_new (gsize size);
function g_string_chunk_new(size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_string_chunk_new
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!void g_string_chunk_free (GStringChunk *chunk);
subroutine g_string_chunk_free(chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_string_chunk_clear (GStringChunk *chunk);
subroutine g_string_chunk_clear(chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar* g_string_chunk_insert (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert(chunk, string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_string_chunk_insert_len (GStringChunk *chunk, const gchar *string, gssize len);
function g_string_chunk_insert_len(chunk, string, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_chunk_insert_len
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_string_chunk_insert_const (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert_const(chunk, string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert_const
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/ghostutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_hostname_is_non_ascii (const gchar *hostname);
function g_hostname_is_non_ascii(hostname) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_hostname_is_non_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hostname_is_ascii_encoded (const gchar *hostname);
function g_hostname_is_ascii_encoded(hostname) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_hostname_is_ascii_encoded
  character(kind=c_char), dimension(*) :: hostname
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_hostname_is_ip_address (const gchar *hostname);
function g_hostname_is_ip_address(hostname) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_hostname_is_ip_address
  character(kind=c_char), dimension(*) :: hostname
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_hostname_to_ascii (const gchar *hostname);
function g_hostname_to_ascii(hostname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_hostname_to_unicode (const gchar *hostname);
function g_hostname_to_unicode(hostname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_unicode
  character(kind=c_char), dimension(*) :: hostname
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gprimes.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!guint g_spaced_primes_closest (guint num) G_GNUC_CONST;
function g_spaced_primes_closest(num) bind(c)
  import :: c_int
  integer(c_int) :: g_spaced_primes_closest
  integer(c_int), value :: num
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/glib-typeof.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gslist.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_alloc() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_alloc
end function

! GLIB_AVAILABLE_IN_ALL
!void g_slist_free (GSList *list);
subroutine g_slist_free(list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_slist_free_1 (GSList *list);
subroutine g_slist_free_1(list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_slist_free_full (GSList *list, GDestroyNotify free_func);
subroutine g_slist_free_full(list, free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: free_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_append (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_append(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_prepend (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_prepend(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_insert (GSList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert(list, data, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_slist_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_insert_sorted (GSList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted(list, data, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_insert_sorted_with_data (GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted_with_data(list, data, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_insert_before (GSList *slist, GSList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_before(slist, sibling, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_insert_before
  type(c_ptr), value :: slist
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_concat (GSList *list1, GSList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_concat(list1, list2) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_remove (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_remove_all (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_all(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_remove_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_link(list, link_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_delete_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_delete_link(list, link_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_reverse (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_reverse(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_reverse
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_copy (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_copy(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_copy
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_2_34
!GSList* g_slist_copy_deep (GSList *list, GCopyFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_copy_deep(list, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_copy_deep
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_nth (GSList *list, guint n);
function g_slist_nth(list, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_slist_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_find (GSList *list, gconstpointer data);
function g_slist_find(list, data) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_find_custom (GSList *list, gconstpointer data, GCompareFunc func);
function g_slist_find_custom(list, data, func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_slist_position (GSList *list, GSList *llink);
function g_slist_position(list, llink) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_slist_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_slist_index (GSList *list, gconstpointer data);
function g_slist_index(list, data) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_slist_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_last (GSList *list);
function g_slist_last(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_slist_last
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_slist_length (GSList *list);
function g_slist_length(list) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_slist_length
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!void g_slist_foreach (GSList *list, GFunc func, gpointer user_data);
subroutine g_slist_foreach(list, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_sort (GSList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort(list, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GLIB_AVAILABLE_IN_ALL
!GSList* g_slist_sort_with_data (GSList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort_with_data(list, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_slist_nth_data (GSList *list, guint n);
function g_slist_nth_data(list, n) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_slist_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GLIB_AVAILABLE_IN_2_64
!void g_clear_slist (GSList **slist_ptr, GDestroyNotify destroy);
subroutine g_clear_slist(slist_ptr, destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: slist_ptr
  type(c_funptr), value :: destroy
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gbacktrace.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_on_error_query (const gchar *prg_name);
subroutine g_on_error_query(prg_name) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_on_error_stack_trace (const gchar *prg_name);
subroutine g_on_error_stack_trace(prg_name) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gtrashstack.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_48
!void g_trash_stack_push (GTrashStack **stack_p, gpointer data_p);
subroutine g_trash_stack_push(stack_p, data_p) bind(c)
  import :: c_ptr
  type(c_ptr), value :: stack_p
  type(c_ptr), value :: data_p
end subroutine

! GLIB_DEPRECATED_IN_2_48
!gpointer g_trash_stack_pop (GTrashStack **stack_p);
function g_trash_stack_pop(stack_p) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_trash_stack_pop
  type(c_ptr), value :: stack_p
end function

! GLIB_DEPRECATED_IN_2_48
!gpointer g_trash_stack_peek (GTrashStack **stack_p);
function g_trash_stack_peek(stack_p) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_trash_stack_peek
  type(c_ptr), value :: stack_p
end function

! GLIB_DEPRECATED_IN_2_48
!guint g_trash_stack_height (GTrashStack **stack_p);
function g_trash_stack_height(stack_p) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_trash_stack_height
  type(c_ptr), value :: stack_p
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gi18n-lib.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/gquark.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_quark_try_string (const gchar *string);
function g_quark_try_string(string) bind(c)
  import :: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_try_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_quark_from_static_string (const gchar *string);
function g_quark_from_static_string(string) bind(c)
  import :: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_static_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_quark_from_string (const gchar *string);
function g_quark_from_string(string) bind(c)
  import :: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_quark_to_string (GQuark quark) G_GNUC_CONST;
function g_quark_to_string(quark) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_quark_to_string
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_intern_string (const gchar *string);
function g_intern_string(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_intern_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_intern_static_string (const gchar *string);
function g_intern_static_string(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_intern_static_string
  character(kind=c_char), dimension(*) :: string
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gasyncqueue.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GAsyncQueue *g_async_queue_new (void);
function g_async_queue_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_new
end function

! GLIB_AVAILABLE_IN_ALL
!GAsyncQueue *g_async_queue_new_full (GDestroyNotify item_free_func);
function g_async_queue_new_full(item_free_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_async_queue_new_full
  type(c_funptr), value :: item_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_lock (GAsyncQueue *queue);
subroutine g_async_queue_lock(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unlock(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GAsyncQueue *g_async_queue_ref (GAsyncQueue *queue);
function g_async_queue_ref(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_ref
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_unref (GAsyncQueue *queue);
subroutine g_async_queue_unref(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_DEPRECATED_FOR(g_async_queue_ref)
!void g_async_queue_ref_unlocked (GAsyncQueue *queue);
subroutine g_async_queue_ref_unlocked(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_DEPRECATED_FOR(g_async_queue_unref)
!void g_async_queue_unref_and_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unref_and_unlock(queue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_push (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push(queue, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_push_unlocked (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push_unlocked(queue, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_push_sorted (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted(queue, data, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted_unlocked(queue, data, func, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_pop (GAsyncQueue *queue);
function g_async_queue_pop(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_pop
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_pop_unlocked(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_pop_unlocked
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_try_pop (GAsyncQueue *queue);
function g_async_queue_try_pop(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_try_pop
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_try_pop_unlocked(queue) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_try_pop_unlocked
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_timeout_pop (GAsyncQueue *queue, guint64 timeout);
function g_async_queue_timeout_pop(queue, timeout) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_async_queue_timeout_pop
  type(c_ptr), value :: queue
  integer(c_int64_t), value :: timeout
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_queue_timeout_pop_unlocked (GAsyncQueue *queue, guint64 timeout);
function g_async_queue_timeout_pop_unlocked(queue, timeout) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr) :: g_async_queue_timeout_pop_unlocked
  type(c_ptr), value :: queue
  integer(c_int64_t), value :: timeout
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_async_queue_length (GAsyncQueue *queue);
function g_async_queue_length(queue) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_queue_length
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_async_queue_length_unlocked (GAsyncQueue *queue);
function g_async_queue_length_unlocked(queue) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_queue_length_unlocked
  type(c_ptr), value :: queue
end function

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_sort (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort(queue, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_queue_sort_unlocked (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort_unlocked(queue, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_46
!gboolean g_async_queue_remove (GAsyncQueue *queue, gpointer item);
function g_async_queue_remove(queue, item) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_queue_remove
  type(c_ptr), value :: queue
  type(c_ptr), value :: item
end function

! GLIB_AVAILABLE_IN_2_46
!gboolean g_async_queue_remove_unlocked (GAsyncQueue *queue, gpointer item);
function g_async_queue_remove_unlocked(queue, item) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_queue_remove_unlocked
  type(c_ptr), value :: queue
  type(c_ptr), value :: item
end function

! GLIB_AVAILABLE_IN_2_46
!void g_async_queue_push_front (GAsyncQueue *queue, gpointer item);
subroutine g_async_queue_push_front(queue, item) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_46
!void g_async_queue_push_front_unlocked (GAsyncQueue *queue, gpointer item);
subroutine g_async_queue_push_front_unlocked(queue, item) bind(c)
  import :: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: item
end subroutine

! GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop)
!gpointer g_async_queue_timed_pop (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop(queue, end_time) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

! GLIB_DEPRECATED_FOR(g_async_queue_timeout_pop_unlocked)
!gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop_unlocked(queue, end_time) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop_unlocked
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gpattern.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GPatternSpec* g_pattern_spec_new (const gchar *pattern);
function g_pattern_spec_new(pattern) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_pattern_spec_new
  character(kind=c_char), dimension(*) :: pattern
end function

! GLIB_AVAILABLE_IN_ALL
!void g_pattern_spec_free (GPatternSpec *pspec);
subroutine g_pattern_spec_free(pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_2_70
!GPatternSpec *g_pattern_spec_copy (GPatternSpec *pspec);
function g_pattern_spec_copy(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_pattern_spec_copy
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pattern_spec_equal (GPatternSpec *pspec1, GPatternSpec *pspec2);
function g_pattern_spec_equal(pspec1, pspec2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pattern_spec_equal
  type(c_ptr), value :: pspec1
  type(c_ptr), value :: pspec2
end function

! GLIB_AVAILABLE_IN_2_70
!gboolean g_pattern_spec_match (GPatternSpec *pspec, gsize string_length, const gchar *string, const gchar *string_reversed);
function g_pattern_spec_match(pspec, string_length, string, string_reversed)&
& bind(c)
  import :: c_int, c_ptr, c_size_t, c_char
  integer(c_int) :: g_pattern_spec_match
  type(c_ptr), value :: pspec
  integer(c_size_t), value :: string_length
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: string_reversed
end function

! GLIB_AVAILABLE_IN_2_70
!gboolean g_pattern_spec_match_string (GPatternSpec *pspec, const gchar *string);
function g_pattern_spec_match_string(pspec, string) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_pattern_spec_match_string
  type(c_ptr), value :: pspec
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_DEPRECATED_IN_2_70_FOR (g_pattern_spec_match)
!gboolean g_pattern_match (GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed);
function g_pattern_match(pspec, string_length, string, string_reversed) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_pattern_match
  type(c_ptr), value :: pspec
  integer(c_int), value :: string_length
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: string_reversed
end function

! GLIB_DEPRECATED_IN_2_70_FOR (g_pattern_spec_match_string)
!gboolean g_pattern_match_string (GPatternSpec *pspec, const gchar *string);
function g_pattern_match_string(pspec, string) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_pattern_match_string
  type(c_ptr), value :: pspec
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pattern_match_simple (const gchar *pattern, const gchar *string);
function g_pattern_match_simple(pattern, string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_pattern_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gstring.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GString* g_string_new (const gchar *init);
function g_string_new(init) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_new
  character(kind=c_char), dimension(*) :: init
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_new_len (const gchar *init, gssize len);
function g_string_new_len(init, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_new_len
  character(kind=c_char), dimension(*) :: init
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_sized_new (gsize dfl_size);
function g_string_sized_new(dfl_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_string_sized_new
  integer(c_size_t), value :: dfl_size
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_string_free (GString *string, gboolean free_segment);
function g_string_free(string, free_segment) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_string_free
  type(c_ptr), value :: string
  integer(c_int), value :: free_segment
end function

! GLIB_AVAILABLE_IN_2_34
!GBytes* g_string_free_to_bytes (GString *string);
function g_string_free_to_bytes(string) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_string_free_to_bytes
  type(c_ptr), value :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_string_equal (const GString *v, const GString *v2);
function g_string_equal(v, v2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_string_equal
  type(c_ptr), value :: v
  type(c_ptr), value :: v2
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_string_hash (const GString *str);
function g_string_hash(str) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_string_hash
  type(c_ptr), value :: str
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_assign (GString *string, const gchar *rval);
function g_string_assign(string, rval) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_assign
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: rval
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_truncate (GString *string, gsize len);
function g_string_truncate(string, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_string_truncate
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_set_size (GString *string, gsize len);
function g_string_set_size(string, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_string_set_size
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_insert_len (GString *string, gssize pos, const gchar *val, gssize len);
function g_string_insert_len(string, pos, val, len) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_append (GString *string, const gchar *val);
function g_string_append(string, val) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_append
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_append_len (GString *string, const gchar *val, gssize len);
function g_string_append_len(string, val, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_append_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_append_c (GString *string, gchar c);
function g_string_append_c(string, c) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr) :: g_string_append_c
  type(c_ptr), value :: string
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_append_unichar (GString *string, gunichar wc);
function g_string_append_unichar(string, wc) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_string_append_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_prepend (GString *string, const gchar *val);
function g_string_prepend(string, val) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_string_prepend
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_prepend_c (GString *string, gchar c);
function g_string_prepend_c(string, c) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr) :: g_string_prepend_c
  type(c_ptr), value :: string
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_prepend_unichar (GString *string, gunichar wc);
function g_string_prepend_unichar(string, wc) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_string_prepend_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_prepend_len (GString *string, const gchar *val, gssize len);
function g_string_prepend_len(string, val, len) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_prepend_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_insert (GString *string, gssize pos, const gchar *val);
function g_string_insert(string, pos, val) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_insert_c (GString *string, gssize pos, gchar c);
function g_string_insert_c(string, pos, c) bind(c)
  import :: c_ptr, c_size_t, c_int8_t
  type(c_ptr) :: g_string_insert_c
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(kind=c_int8_t), value :: c
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_insert_unichar (GString *string, gssize pos, gunichar wc);
function g_string_insert_unichar(string, pos, wc) bind(c)
  import :: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_string_insert_unichar
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_int32_t), value :: wc
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_overwrite (GString *string, gsize pos, const gchar *val);
function g_string_overwrite(string, pos, val) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_overwrite_len (GString *string, gsize pos, const gchar *val, gssize len);
function g_string_overwrite_len(string, pos, val, len) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_erase (GString *string, gssize pos, gssize len);
function g_string_erase(string, pos, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_string_erase
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_2_68
!guint g_string_replace (GString *string, const gchar *find, const gchar *replace, guint limit);
function g_string_replace(string, find, replace, limit) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_string_replace
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: find
  character(kind=c_char), dimension(*) :: replace
  integer(c_int), value :: limit
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_ascii_down (GString *string);
function g_string_ascii_down(string) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_string_ascii_down
  type(c_ptr), value :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_ascii_up (GString *string);
function g_string_ascii_up(string) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_string_ascii_up
  type(c_ptr), value :: string
end function

! GLIB_AVAILABLE_IN_ALL
!void g_string_vprintf (GString *string, const gchar *format, va_list args) G_GNUC_PRINTF(2, 0);
subroutine g_string_vprintf(string, format, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_string_append_vprintf (GString *string, const gchar *format, va_list args) G_GNUC_PRINTF(2, 0);
subroutine g_string_append_vprintf(string, format, args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GString* g_string_append_uri_escaped (GString *string, const gchar *unescaped, const gchar *reserved_chars_allowed, gboolean allow_utf8);
function g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed,&
& allow_utf8) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_string_append_uri_escaped
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  integer(c_int), value :: allow_utf8
end function

! GLIB_DEPRECATED
!GString *g_string_down (GString *string);
function g_string_down(string) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_string_down
  type(c_ptr), value :: string
end function

! GLIB_DEPRECATED
!GString *g_string_up (GString *string);
function g_string_up(string) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_string_up
  type(c_ptr), value :: string
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gmappedfile.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GMappedFile *g_mapped_file_new (const gchar *filename, gboolean writable, GError **error);
function g_mapped_file_new(filename, writable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_mapped_file_new
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: writable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GMappedFile *g_mapped_file_new_from_fd (gint fd, gboolean writable, GError **error);
function g_mapped_file_new_from_fd(fd, writable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_mapped_file_new_from_fd
  integer(c_int), value :: fd
  integer(c_int), value :: writable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_mapped_file_get_length (GMappedFile *file);
function g_mapped_file_get_length(file) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_mapped_file_get_length
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_mapped_file_get_contents (GMappedFile *file);
function g_mapped_file_get_contents(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mapped_file_get_contents
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_2_34
!GBytes * g_mapped_file_get_bytes (GMappedFile *file);
function g_mapped_file_get_bytes(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mapped_file_get_bytes
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!GMappedFile *g_mapped_file_ref (GMappedFile *file);
function g_mapped_file_ref(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mapped_file_ref
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mapped_file_unref (GMappedFile *file);
subroutine g_mapped_file_unref(file) bind(c)
  import :: c_ptr
  type(c_ptr), value :: file
end subroutine

! GLIB_DEPRECATED_FOR(g_mapped_file_unref)
!void g_mapped_file_free (GMappedFile *file);
subroutine g_mapped_file_free(file) bind(c)
  import :: c_ptr
  type(c_ptr), value :: file
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/gthread.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_thread_error_quark (void);
function g_thread_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_thread_error_quark
end function

! GLIB_AVAILABLE_IN_2_32
!GThread * g_thread_ref (GThread *thread);
function g_thread_ref(thread) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_thread_ref
  type(c_ptr), value :: thread
end function

! GLIB_AVAILABLE_IN_2_32
!void g_thread_unref (GThread *thread);
subroutine g_thread_unref(thread) bind(c)
  import :: c_ptr
  type(c_ptr), value :: thread
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GThread * g_thread_new (const gchar *name, GThreadFunc func, gpointer data);
function g_thread_new(name, func, data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_thread_new
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_2_32
!GThread * g_thread_try_new (const gchar *name, GThreadFunc func, gpointer data, GError **error);
function g_thread_try_new(name, func, data, error) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_thread_try_new
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GThread * g_thread_self (void);
function g_thread_self() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_thread_self
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_exit (gpointer retval);
subroutine g_thread_exit(retval) bind(c)
  import :: c_ptr
  type(c_ptr), value :: retval
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_thread_join (GThread *thread);
function g_thread_join(thread) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_thread_join
  type(c_ptr), value :: thread
end function

! GLIB_AVAILABLE_IN_ALL
!void g_thread_yield (void);
subroutine g_thread_yield() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_mutex_init (GMutex *mutex);
subroutine g_mutex_init(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_mutex_clear (GMutex *mutex);
subroutine g_mutex_clear(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_mutex_lock (GMutex *mutex);
subroutine g_mutex_lock(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mutex_trylock (GMutex *mutex);
function g_mutex_trylock(mutex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mutex_trylock
  type(c_ptr), value :: mutex
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mutex_unlock (GMutex *mutex);
subroutine g_mutex_unlock(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_init (GRWLock *rw_lock);
subroutine g_rw_lock_init(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_clear (GRWLock *rw_lock);
subroutine g_rw_lock_clear(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_writer_lock (GRWLock *rw_lock);
subroutine g_rw_lock_writer_lock(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_rw_lock_writer_trylock (GRWLock *rw_lock);
function g_rw_lock_writer_trylock(rw_lock) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_rw_lock_writer_trylock
  type(c_ptr), value :: rw_lock
end function

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_writer_unlock (GRWLock *rw_lock);
subroutine g_rw_lock_writer_unlock(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_reader_lock (GRWLock *rw_lock);
subroutine g_rw_lock_reader_lock(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_rw_lock_reader_trylock (GRWLock *rw_lock);
function g_rw_lock_reader_trylock(rw_lock) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_rw_lock_reader_trylock
  type(c_ptr), value :: rw_lock
end function

! GLIB_AVAILABLE_IN_2_32
!void g_rw_lock_reader_unlock (GRWLock *rw_lock);
subroutine g_rw_lock_reader_unlock(rw_lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rw_lock
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rec_mutex_init (GRecMutex *rec_mutex);
subroutine g_rec_mutex_init(rec_mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rec_mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rec_mutex_clear (GRecMutex *rec_mutex);
subroutine g_rec_mutex_clear(rec_mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rec_mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_rec_mutex_lock (GRecMutex *rec_mutex);
subroutine g_rec_mutex_lock(rec_mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rec_mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_rec_mutex_trylock (GRecMutex *rec_mutex);
function g_rec_mutex_trylock(rec_mutex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_rec_mutex_trylock
  type(c_ptr), value :: rec_mutex
end function

! GLIB_AVAILABLE_IN_2_32
!void g_rec_mutex_unlock (GRecMutex *rec_mutex);
subroutine g_rec_mutex_unlock(rec_mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: rec_mutex
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_cond_init (GCond *cond);
subroutine g_cond_init(cond) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_cond_clear (GCond *cond);
subroutine g_cond_clear(cond) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cond_wait (GCond *cond, GMutex *mutex);
subroutine g_cond_wait(cond, mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cond_signal (GCond *cond);
subroutine g_cond_signal(cond) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cond_broadcast (GCond *cond);
subroutine g_cond_broadcast(cond) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_cond_wait_until (GCond *cond, GMutex *mutex, gint64 end_time);
function g_cond_wait_until(cond, mutex, end_time) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_cond_wait_until
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
  integer(c_int64_t), value :: end_time
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_private_get (GPrivate *key);
function g_private_get(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_private_get
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_ALL
!void g_private_set (GPrivate *key, gpointer value);
subroutine g_private_set(key, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_private_replace (GPrivate *key, gpointer value);
subroutine g_private_replace(key, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
function g_once_impl(once, func, arg) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_once_impl
  type(c_ptr), value :: once
  type(c_funptr), value :: func
  type(c_ptr), value :: arg
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_once_init_enter (volatile void *location);
function g_once_init_enter(location) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_once_init_enter
  type(c_ptr), value :: location
end function

! GLIB_AVAILABLE_IN_ALL
!void g_once_init_leave (volatile void *location, gsize result);
subroutine g_once_init_leave(location, result) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: location
  integer(c_size_t), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_36
!guint g_get_num_processors (void);
function g_get_num_processors() bind(c)
  import :: c_int
  integer(c_int) :: g_get_num_processors
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/gcompletion.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_26
!GCompletion* g_completion_new (GCompletionFunc func);
function g_completion_new(func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_completion_new
  type(c_funptr), value :: func
end function

! GLIB_DEPRECATED_IN_2_26
!void g_completion_add_items (GCompletion* cmp, GList* items);
subroutine g_completion_add_items(cmp, items) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! GLIB_DEPRECATED_IN_2_26
!void g_completion_remove_items (GCompletion* cmp, GList* items);
subroutine g_completion_remove_items(cmp, items) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! GLIB_DEPRECATED_IN_2_26
!void g_completion_clear_items (GCompletion* cmp);
subroutine g_completion_clear_items(cmp) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cmp
end subroutine

! GLIB_DEPRECATED_IN_2_26
!GList* g_completion_complete (GCompletion* cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete(cmp, prefix, new_prefix) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_completion_complete
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  type(c_ptr), dimension(*) :: new_prefix
end function

! GLIB_DEPRECATED_IN_2_26
!GList* g_completion_complete_utf8 (GCompletion *cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete_utf8(cmp, prefix, new_prefix) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_completion_complete_utf8
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  type(c_ptr), dimension(*) :: new_prefix
end function

! GLIB_DEPRECATED_IN_2_26
!void g_completion_set_compare (GCompletion *cmp, GCompletionStrncmpFunc strncmp_func);
subroutine g_completion_set_compare(cmp, strncmp_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: cmp
  type(c_funptr), value :: strncmp_func
end subroutine

! GLIB_DEPRECATED_IN_2_26
!void g_completion_free (GCompletion* cmp);
subroutine g_completion_free(cmp) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cmp
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/gallocator.h
!--------------------------------------------------
! GLIB_DEPRECATED
!GMemChunk * g_mem_chunk_new (const gchar *name, gint atom_size, gsize area_size, gint type);
function g_mem_chunk_new(name, atom_size, area_size, type) bind(c)
  import :: c_ptr, c_char, c_int, c_size_t
  type(c_ptr) :: g_mem_chunk_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: atom_size
  integer(c_size_t), value :: area_size
  integer(c_int), value :: type
end function

! GLIB_DEPRECATED
!void g_mem_chunk_destroy (GMemChunk *mem_chunk);
subroutine g_mem_chunk_destroy(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! GLIB_DEPRECATED
!gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
function g_mem_chunk_alloc(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc
  type(c_ptr), value :: mem_chunk
end function

! GLIB_DEPRECATED
!gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
function g_mem_chunk_alloc0(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc0
  type(c_ptr), value :: mem_chunk
end function

! GLIB_DEPRECATED
!void g_mem_chunk_free (GMemChunk *mem_chunk, gpointer mem);
subroutine g_mem_chunk_free(mem_chunk, mem) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_chunk
  type(c_ptr), value :: mem
end subroutine

! GLIB_DEPRECATED
!void g_mem_chunk_clean (GMemChunk *mem_chunk);
subroutine g_mem_chunk_clean(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! GLIB_DEPRECATED
!void g_mem_chunk_reset (GMemChunk *mem_chunk);
subroutine g_mem_chunk_reset(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! GLIB_DEPRECATED
!void g_mem_chunk_print (GMemChunk *mem_chunk);
subroutine g_mem_chunk_print(mem_chunk) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! GLIB_DEPRECATED
!void g_mem_chunk_info (void);
subroutine g_mem_chunk_info() bind(c)
end subroutine

! GLIB_DEPRECATED
!void g_blow_chunks (void);
subroutine g_blow_chunks() bind(c)
end subroutine

! GLIB_DEPRECATED
!GAllocator * g_allocator_new (const gchar *name, guint n_preallocs);
function g_allocator_new(name, n_preallocs) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_allocator_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: n_preallocs
end function

! GLIB_DEPRECATED
!void g_allocator_free (GAllocator *allocator);
subroutine g_allocator_free(allocator) bind(c)
  import :: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! GLIB_DEPRECATED
!void g_list_push_allocator (GAllocator *allocator);
subroutine g_list_push_allocator(allocator) bind(c)
  import :: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! GLIB_DEPRECATED
!void g_list_pop_allocator (void);
subroutine g_list_pop_allocator() bind(c)
end subroutine

! GLIB_DEPRECATED
!void g_slist_push_allocator (GAllocator *allocator);
subroutine g_slist_push_allocator(allocator) bind(c)
  import :: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! GLIB_DEPRECATED
!void g_slist_pop_allocator (void);
subroutine g_slist_pop_allocator() bind(c)
end subroutine

! GLIB_DEPRECATED
!void g_node_push_allocator (GAllocator *allocator);
subroutine g_node_push_allocator(allocator) bind(c)
  import :: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! GLIB_DEPRECATED
!void g_node_pop_allocator (void);
subroutine g_node_pop_allocator() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/grel.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_26
!GRelation* g_relation_new (gint fields);
function g_relation_new(fields) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_relation_new
  integer(c_int), value :: fields
end function

! GLIB_DEPRECATED_IN_2_26
!void g_relation_destroy (GRelation *relation);
subroutine g_relation_destroy(relation) bind(c)
  import :: c_ptr
  type(c_ptr), value :: relation
end subroutine

! GLIB_DEPRECATED_IN_2_26
!void g_relation_index (GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
subroutine g_relation_index(relation, field, hash_func, key_equal_func) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: relation
  integer(c_int), value :: field
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end subroutine

! GLIB_DEPRECATED_IN_2_26
!gint g_relation_delete (GRelation *relation, gconstpointer key, gint field);
function g_relation_delete(relation, key, field) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_relation_delete
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! GLIB_DEPRECATED_IN_2_26
!GTuples* g_relation_select (GRelation *relation, gconstpointer key, gint field);
function g_relation_select(relation, key, field) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_relation_select
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! GLIB_DEPRECATED_IN_2_26
!gint g_relation_count (GRelation *relation, gconstpointer key, gint field);
function g_relation_count(relation, key, field) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_relation_count
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! GLIB_DEPRECATED_IN_2_26
!void g_relation_print (GRelation *relation);
subroutine g_relation_print(relation) bind(c)
  import :: c_ptr
  type(c_ptr), value :: relation
end subroutine

! GLIB_DEPRECATED_IN_2_26
!void g_tuples_destroy (GTuples *tuples);
subroutine g_tuples_destroy(tuples) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tuples
end subroutine

! GLIB_DEPRECATED_IN_2_26
!gpointer g_tuples_index (GTuples *tuples, gint index_, gint field);
function g_tuples_index(tuples, index_, field) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_tuples_index
  type(c_ptr), value :: tuples
  integer(c_int), value :: index_
  integer(c_int), value :: field
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/gmain.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/gthread.h
!--------------------------------------------------
! 
!guint64 (*g_thread_gettime) (void);
function guint64() bind(c)
  import :: c_int64_t
  integer(c_int64_t) :: guint64
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_thread_new)
!GThread *g_thread_create (GThreadFunc func, gpointer data, gboolean joinable, GError **error);
function g_thread_create(func, data, joinable, error) bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_thread_create
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  integer(c_int), value :: joinable
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_32
!void g_thread_foreach (GFunc thread_func, gpointer user_data);
subroutine g_thread_foreach(thread_func, user_data) bind(c)
  import :: c_funptr, c_ptr
  type(c_funptr), value :: thread_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_init)
!void g_static_mutex_init (GStaticMutex *mutex);
subroutine g_static_mutex_init(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_mutex_clear)
!void g_static_mutex_free (GStaticMutex *mutex);
subroutine g_static_mutex_free(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(GMutex)
!GMutex *g_static_mutex_get_mutex_impl (GStaticMutex *mutex);
function g_static_mutex_get_mutex_impl(mutex) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_static_mutex_get_mutex_impl
  type(c_ptr), value :: mutex
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_init)
!void g_static_rec_mutex_init (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_init(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_lock)
!void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_lock(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_try_lock)
!gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
function g_static_rec_mutex_trylock(mutex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_static_rec_mutex_trylock
  type(c_ptr), value :: mutex
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_unlock)
!void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_unlock(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32
!void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex, guint depth);
subroutine g_static_rec_mutex_lock_full(mutex, depth) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: mutex
  integer(c_int), value :: depth
end subroutine

! GLIB_DEPRECATED_IN_2_32
!guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
function g_static_rec_mutex_unlock_full(mutex) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_static_rec_mutex_unlock_full
  type(c_ptr), value :: mutex
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_rec_mutex_free)
!void g_static_rec_mutex_free (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_free(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_init)
!void g_static_rw_lock_init (GStaticRWLock *lock);
subroutine g_static_rw_lock_init(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_lock)
!void g_static_rw_lock_reader_lock (GStaticRWLock *lock);
subroutine g_static_rw_lock_reader_lock(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_trylock)
!gboolean g_static_rw_lock_reader_trylock (GStaticRWLock *lock);
function g_static_rw_lock_reader_trylock(lock) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_static_rw_lock_reader_trylock
  type(c_ptr), value :: lock
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_reader_unlock)
!void g_static_rw_lock_reader_unlock (GStaticRWLock *lock);
subroutine g_static_rw_lock_reader_unlock(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_lock)
!void g_static_rw_lock_writer_lock (GStaticRWLock *lock);
subroutine g_static_rw_lock_writer_lock(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_trylock)
!gboolean g_static_rw_lock_writer_trylock (GStaticRWLock *lock);
function g_static_rw_lock_writer_trylock(lock) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_static_rw_lock_writer_trylock
  type(c_ptr), value :: lock
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_writer_unlock)
!void g_static_rw_lock_writer_unlock (GStaticRWLock *lock);
subroutine g_static_rw_lock_writer_unlock(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_rw_lock_free)
!void g_static_rw_lock_free (GStaticRWLock *lock);
subroutine g_static_rw_lock_free(lock) bind(c)
  import :: c_ptr
  type(c_ptr), value :: lock
end subroutine

! GLIB_DEPRECATED_IN_2_32
!GPrivate * g_private_new (GDestroyNotify notify);
function g_private_new(notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_private_new
  type(c_funptr), value :: notify
end function

! GLIB_DEPRECATED_IN_2_32
!void g_static_private_init (GStaticPrivate *private_key);
subroutine g_static_private_init(private_key) bind(c)
  import :: c_ptr
  type(c_ptr), value :: private_key
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_private_get)
!gpointer g_static_private_get (GStaticPrivate *private_key);
function g_static_private_get(private_key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_static_private_get
  type(c_ptr), value :: private_key
end function

! GLIB_DEPRECATED_IN_2_32_FOR(g_private_set)
!void g_static_private_set (GStaticPrivate *private_key, gpointer data, GDestroyNotify notify);
subroutine g_static_private_set(private_key, data, notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: private_key
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! GLIB_DEPRECATED_IN_2_32
!void g_static_private_free (GStaticPrivate *private_key);
subroutine g_static_private_free(private_key) bind(c)
  import :: c_ptr
  type(c_ptr), value :: private_key
end subroutine

! GLIB_DEPRECATED_IN_2_32
!gboolean g_once_init_enter_impl (volatile gsize *location);
function g_once_init_enter_impl(location) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_once_init_enter_impl
  type(c_ptr), value :: location
end function

! GLIB_DEPRECATED_IN_2_32
!void g_thread_init (gpointer vtable);
subroutine g_thread_init(vtable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: vtable
end subroutine

! GLIB_DEPRECATED_IN_2_32
!void g_thread_init_with_errorcheck_mutexes (gpointer vtable);
subroutine g_thread_init_with_errorcheck_mutexes(vtable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: vtable
end subroutine

! GLIB_DEPRECATED_IN_2_32
!gboolean g_thread_get_initialized (void);
function g_thread_get_initialized() bind(c)
  import :: c_int
  integer(c_int) :: g_thread_get_initialized
end function

! GLIB_DEPRECATED_IN_2_32
!GMutex * g_mutex_new (void);
function g_mutex_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mutex_new
end function

! GLIB_DEPRECATED_IN_2_32
!void g_mutex_free (GMutex *mutex);
subroutine g_mutex_free(mutex) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! GLIB_DEPRECATED_IN_2_32
!GCond * g_cond_new (void);
function g_cond_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_cond_new
end function

! GLIB_DEPRECATED_IN_2_32
!void g_cond_free (GCond *cond);
subroutine g_cond_free(cond) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cond
end subroutine

! GLIB_DEPRECATED_IN_2_32
!gboolean g_cond_timed_wait (GCond *cond, GMutex *mutex, GTimeVal *timeval);
function g_cond_timed_wait(cond, mutex, timeval) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_cond_timed_wait
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
  type(c_ptr), value :: timeval
end function

!--------------------------------------------------
! /usr/include/glib-2.0/glib/deprecated/gcache.h
!--------------------------------------------------
! GLIB_DEPRECATED
!GCache* g_cache_new (GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
function g_cache_new(value_new_func, value_destroy_func, key_dup_func,&
& key_destroy_func, hash_key_func, hash_value_func, key_equal_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_cache_new
  type(c_funptr), value :: value_new_func
  type(c_funptr), value :: value_destroy_func
  type(c_funptr), value :: key_dup_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: hash_key_func
  type(c_funptr), value :: hash_value_func
  type(c_funptr), value :: key_equal_func
end function

! GLIB_DEPRECATED
!void g_cache_destroy (GCache *cache);
subroutine g_cache_destroy(cache) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cache
end subroutine

! GLIB_DEPRECATED
!gpointer g_cache_insert (GCache *cache, gpointer key);
function g_cache_insert(cache, key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_cache_insert
  type(c_ptr), value :: cache
  type(c_ptr), value :: key
end function

! GLIB_DEPRECATED
!void g_cache_remove (GCache *cache, gconstpointer value);
subroutine g_cache_remove(cache, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cache
  type(c_ptr), value :: value
end subroutine

! GLIB_DEPRECATED
!void g_cache_key_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_key_foreach(cache, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED
!void g_cache_value_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_value_foreach(cache, func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmemoryinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_memory_input_stream_get_type (void) G_GNUC_CONST;
function g_memory_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_memory_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream * g_memory_input_stream_new (void);
function g_memory_input_stream_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_input_stream_new
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream * g_memory_input_stream_new_from_data (const void *data, gssize len, GDestroyNotify destroy);
function g_memory_input_stream_new_from_data(data, len, destroy) bind(c)
  import :: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_input_stream_new_from_data
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end function

! GLIB_AVAILABLE_IN_2_34
!GInputStream * g_memory_input_stream_new_from_bytes (GBytes *bytes);
function g_memory_input_stream_new_from_bytes(bytes) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_input_stream_new_from_bytes
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_ALL
!void g_memory_input_stream_add_data (GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
subroutine g_memory_input_stream_add_data(stream, data, len, destroy) bind(c)
  import :: c_ptr, c_size_t, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_memory_input_stream_add_bytes (GMemoryInputStream *stream, GBytes *bytes);
subroutine g_memory_input_stream_add_bytes(stream, bytes) bind(c)
  import :: c_ptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: bytes
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsbackend.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_backend_get_type (void) G_GNUC_CONST;
function g_tls_backend_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_backend_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsBackend * g_tls_backend_get_default (void);
function g_tls_backend_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_backend_get_default
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsDatabase * g_tls_backend_get_default_database (GTlsBackend *backend);
function g_tls_backend_get_default_database(backend) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_backend_get_default_database
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_2_60
!void g_tls_backend_set_default_database (GTlsBackend *backend, GTlsDatabase *database);
subroutine g_tls_backend_set_default_database(backend, database) bind(c)
  import :: c_ptr
  type(c_ptr), value :: backend
  type(c_ptr), value :: database
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tls_backend_supports_tls (GTlsBackend *backend);
function g_tls_backend_supports_tls(backend) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_backend_supports_tls
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_2_48
!gboolean g_tls_backend_supports_dtls (GTlsBackend *backend);
function g_tls_backend_supports_dtls(backend) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_backend_supports_dtls
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_tls_backend_get_certificate_type (GTlsBackend *backend);
function g_tls_backend_get_certificate_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_certificate_type
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_tls_backend_get_client_connection_type (GTlsBackend *backend);
function g_tls_backend_get_client_connection_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_client_connection_type
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_tls_backend_get_server_connection_type (GTlsBackend *backend);
function g_tls_backend_get_server_connection_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_server_connection_type
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_tls_backend_get_file_database_type (GTlsBackend *backend);
function g_tls_backend_get_file_database_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_file_database_type
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_2_48
!GType g_tls_backend_get_dtls_client_connection_type (GTlsBackend *backend);
function g_tls_backend_get_dtls_client_connection_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_dtls_client_connection_type
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_2_48
!GType g_tls_backend_get_dtls_server_connection_type (GTlsBackend *backend);
function g_tls_backend_get_dtls_server_connection_type(backend) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_dtls_server_connection_type
  type(c_ptr), value :: backend
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmount.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_mount_get_type (void) G_GNUC_CONST;
function g_mount_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_mount_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_mount_get_root (GMount *mount);
function g_mount_get_root(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_root
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_mount_get_default_location (GMount *mount);
function g_mount_get_default_location(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_default_location
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_mount_get_name (GMount *mount);
function g_mount_get_name(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_name
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_mount_get_icon (GMount *mount);
function g_mount_get_icon(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_icon
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_mount_get_symbolic_icon (GMount *mount);
function g_mount_get_symbolic_icon(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_symbolic_icon
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_mount_get_uuid (GMount *mount);
function g_mount_get_uuid(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_uuid
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!GVolume * g_mount_get_volume (GMount *mount);
function g_mount_get_volume(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_volume
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!GDrive * g_mount_get_drive (GMount *mount);
function g_mount_get_drive(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_drive
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_can_unmount (GMount *mount);
function g_mount_can_unmount(mount) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_can_unmount
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_can_eject (GMount *mount);
function g_mount_can_eject(mount) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_can_eject
  type(c_ptr), value :: mount
end function

! GLIB_DEPRECATED_FOR(g_mount_unmount_with_operation)
!void g_mount_unmount (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount(mount, flags, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_mount_unmount_with_operation_finish)
!gboolean g_mount_unmount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_finish(mount, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_unmount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_FOR(g_mount_eject_with_operation)
!void g_mount_eject (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject(mount, flags, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_mount_eject_with_operation_finish)
!gboolean g_mount_eject_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_finish(mount, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_eject_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_remount (GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_remount(mount, flags, mount_operation, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_remount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_remount_finish(mount, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_remount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_guess_content_type (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_guess_content_type(mount, force_rescan, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_mount_guess_content_type_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_guess_content_type_finish(mount, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_guess_content_type_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_mount_guess_content_type_sync (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
function g_mount_guess_content_type_sync(mount, force_rescan, cancellable,&
& error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_mount_guess_content_type_sync
  type(c_ptr), value :: mount
  integer(c_int), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_is_shadowed (GMount *mount);
function g_mount_is_shadowed(mount) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_is_shadowed
  type(c_ptr), value :: mount
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_shadow (GMount *mount);
subroutine g_mount_shadow(mount) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mount
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_mount_unshadow (GMount *mount);
subroutine g_mount_unshadow(mount) bind(c)
  import :: c_ptr
  type(c_ptr), value :: mount
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_mount_unmount_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount_with_operation(mount, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_unmount_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_with_operation_finish(mount, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_unmount_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_eject_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject_with_operation(mount, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_eject_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_with_operation_finish(mount, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_eject_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_mount_get_sort_key (GMount *mount);
function g_mount_get_sort_key(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_get_sort_key
  type(c_ptr), value :: mount
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gio-autocleanups.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlspassword.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_password_get_type (void) G_GNUC_CONST;
function g_tls_password_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_password_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsPassword * g_tls_password_new (GTlsPasswordFlags flags, const gchar *description);
function g_tls_password_new(flags, description) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_tls_password_new
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: description
end function

! GLIB_AVAILABLE_IN_ALL
!const guchar * g_tls_password_get_value (GTlsPassword *password, gsize *length);
function g_tls_password_get_value(password, length) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_password_get_value
  type(c_ptr), value :: password
  type(c_ptr), value :: length
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_password_set_value (GTlsPassword *password, const guchar *value, gssize length);
subroutine g_tls_password_set_value(password, value, length) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr), value :: password
  character(kind=c_char), dimension(*) :: value
  integer(c_size_t), value :: length
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_tls_password_set_value_full (GTlsPassword *password, guchar *value, gssize length, GDestroyNotify destroy);
subroutine g_tls_password_set_value_full(password, value, length, destroy)&
& bind(c)
  import :: c_ptr, c_char, c_size_t, c_funptr
  type(c_ptr), value :: password
  character(kind=c_char), dimension(*) :: value
  integer(c_size_t), value :: length
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsPasswordFlags g_tls_password_get_flags (GTlsPassword *password);
function g_tls_password_get_flags(password) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_password_get_flags
  type(c_ptr), value :: password
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_password_set_flags (GTlsPassword *password, GTlsPasswordFlags flags);
subroutine g_tls_password_set_flags(password, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: password
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar* g_tls_password_get_description (GTlsPassword *password);
function g_tls_password_get_description(password) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_password_get_description
  type(c_ptr), value :: password
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_password_set_description (GTlsPassword *password, const gchar *description);
subroutine g_tls_password_set_description(password, description) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: password
  character(kind=c_char), dimension(*) :: description
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_tls_password_get_warning (GTlsPassword *password);
function g_tls_password_get_warning(password) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_password_get_warning
  type(c_ptr), value :: password
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_password_set_warning (GTlsPassword *password, const gchar *warning);
subroutine g_tls_password_set_warning(password, warning) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: password
  character(kind=c_char), dimension(*) :: warning
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdatagrambased.h
!--------------------------------------------------
! 
!GType g_datagram_based_get_type (void);
function g_datagram_based_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_datagram_based_get_type
end function

! 
!gint g_datagram_based_receive_messages (GDatagramBased *datagram_based, GInputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
function g_datagram_based_receive_messages(datagram_based, messages,&
& num_messages, flags, timeout, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_datagram_based_receive_messages
  type(c_ptr), value :: datagram_based
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  integer(c_int64_t), value :: timeout
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! 
!gint g_datagram_based_send_messages (GDatagramBased *datagram_based, GOutputMessage *messages, guint num_messages, gint flags, gint64 timeout, GCancellable *cancellable, GError **error);
function g_datagram_based_send_messages(datagram_based, messages, num_messages,&
& flags, timeout, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_datagram_based_send_messages
  type(c_ptr), value :: datagram_based
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  integer(c_int64_t), value :: timeout
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! 
!GSource * g_datagram_based_create_source (GDatagramBased *datagram_based, GIOCondition condition, GCancellable *cancellable);
function g_datagram_based_create_source(datagram_based, condition, cancellable)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_datagram_based_create_source
  type(c_ptr), value :: datagram_based
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
end function

! 
!GIOCondition g_datagram_based_condition_check (GDatagramBased *datagram_based, GIOCondition condition);
function g_datagram_based_condition_check(datagram_based, condition) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_datagram_based_condition_check
  type(c_ptr), value :: datagram_based
  integer(c_int), value :: condition
end function

! 
!gboolean g_datagram_based_condition_wait (GDatagramBased *datagram_based, GIOCondition condition, gint64 timeout, GCancellable *cancellable, GError **error);
function g_datagram_based_condition_wait(datagram_based, condition, timeout,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_datagram_based_condition_wait
  type(c_ptr), value :: datagram_based
  integer(c_int), value :: condition
  integer(c_int64_t), value :: timeout
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsettingsschema.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_settings_schema_source_get_type (void) G_GNUC_CONST;
function g_settings_schema_source_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_settings_schema_source_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GSettingsSchemaSource * g_settings_schema_source_get_default (void);
function g_settings_schema_source_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_source_get_default
end function

! GLIB_AVAILABLE_IN_2_32
!GSettingsSchemaSource * g_settings_schema_source_ref (GSettingsSchemaSource *source);
function g_settings_schema_source_ref(source) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_source_ref
  type(c_ptr), value :: source
end function

! GLIB_AVAILABLE_IN_2_32
!void g_settings_schema_source_unref (GSettingsSchemaSource *source);
subroutine g_settings_schema_source_unref(source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GSettingsSchemaSource * g_settings_schema_source_new_from_directory (const gchar *directory, GSettingsSchemaSource *parent, gboolean trusted, GError **error);
function g_settings_schema_source_new_from_directory(directory, parent,&
& trusted, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_settings_schema_source_new_from_directory
  character(kind=c_char), dimension(*) :: directory
  type(c_ptr), value :: parent
  integer(c_int), value :: trusted
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GSettingsSchema * g_settings_schema_source_lookup (GSettingsSchemaSource *source, const gchar *schema_id, gboolean recursive);
function g_settings_schema_source_lookup(source, schema_id, recursive) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_settings_schema_source_lookup
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: schema_id
  integer(c_int), value :: recursive
end function

! GLIB_AVAILABLE_IN_2_40
!void g_settings_schema_source_list_schemas (GSettingsSchemaSource *source, gboolean recursive, gchar ***non_relocatable, gchar ***relocatable);
subroutine g_settings_schema_source_list_schemas(source, recursive,&
& non_relocatable, relocatable) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: recursive
  type(c_ptr), dimension(*) :: non_relocatable
  type(c_ptr), dimension(*) :: relocatable
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GType g_settings_schema_get_type (void) G_GNUC_CONST;
function g_settings_schema_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_settings_schema_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GSettingsSchema * g_settings_schema_ref (GSettingsSchema *schema);
function g_settings_schema_ref(schema) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_ref
  type(c_ptr), value :: schema
end function

! GLIB_AVAILABLE_IN_2_32
!void g_settings_schema_unref (GSettingsSchema *schema);
subroutine g_settings_schema_unref(schema) bind(c)
  import :: c_ptr
  type(c_ptr), value :: schema
end subroutine

! GLIB_AVAILABLE_IN_2_32
!const gchar * g_settings_schema_get_id (GSettingsSchema *schema);
function g_settings_schema_get_id(schema) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_get_id
  type(c_ptr), value :: schema
end function

! GLIB_AVAILABLE_IN_2_32
!const gchar * g_settings_schema_get_path (GSettingsSchema *schema);
function g_settings_schema_get_path(schema) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_get_path
  type(c_ptr), value :: schema
end function

! GLIB_AVAILABLE_IN_2_40
!GSettingsSchemaKey * g_settings_schema_get_key (GSettingsSchema *schema, const gchar *name);
function g_settings_schema_get_key(schema, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_schema_get_key
  type(c_ptr), value :: schema
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_settings_schema_has_key (GSettingsSchema *schema, const gchar *name);
function g_settings_schema_has_key(schema, name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_schema_has_key
  type(c_ptr), value :: schema
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_2_46
!gchar** g_settings_schema_list_keys (GSettingsSchema *schema);
function g_settings_schema_list_keys(schema) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_list_keys
  type(c_ptr), value :: schema
end function

! GLIB_AVAILABLE_IN_2_44
!gchar ** g_settings_schema_list_children (GSettingsSchema *schema);
function g_settings_schema_list_children(schema) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_list_children
  type(c_ptr), value :: schema
end function

! GLIB_AVAILABLE_IN_2_40
!GType g_settings_schema_key_get_type (void) G_GNUC_CONST;
function g_settings_schema_key_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_settings_schema_key_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GSettingsSchemaKey * g_settings_schema_key_ref (GSettingsSchemaKey *key);
function g_settings_schema_key_ref(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_ref
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!void g_settings_schema_key_unref (GSettingsSchemaKey *key);
subroutine g_settings_schema_key_unref(key) bind(c)
  import :: c_ptr
  type(c_ptr), value :: key
end subroutine

! GLIB_AVAILABLE_IN_2_40
!const GVariantType * g_settings_schema_key_get_value_type (GSettingsSchemaKey *key);
function g_settings_schema_key_get_value_type(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_value_type
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_settings_schema_key_get_default_value (GSettingsSchemaKey *key);
function g_settings_schema_key_get_default_value(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_default_value
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_settings_schema_key_get_range (GSettingsSchemaKey *key);
function g_settings_schema_key_get_range(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_range
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_settings_schema_key_range_check (GSettingsSchemaKey *key, GVariant *value);
function g_settings_schema_key_range_check(key, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_settings_schema_key_range_check
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_2_44
!const gchar * g_settings_schema_key_get_name (GSettingsSchemaKey *key);
function g_settings_schema_key_get_name(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_name
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!const gchar * g_settings_schema_key_get_summary (GSettingsSchemaKey *key);
function g_settings_schema_key_get_summary(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_summary
  type(c_ptr), value :: key
end function

! GLIB_AVAILABLE_IN_2_40
!const gchar * g_settings_schema_key_get_description (GSettingsSchemaKey *key);
function g_settings_schema_key_get_description(key) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_schema_key_get_description
  type(c_ptr), value :: key
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketservice.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_service_get_type (void);
function g_socket_service_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_service_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketService *g_socket_service_new (void);
function g_socket_service_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_service_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_service_start (GSocketService *service);
subroutine g_socket_service_start(service) bind(c)
  import :: c_ptr
  type(c_ptr), value :: service
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_socket_service_stop (GSocketService *service);
subroutine g_socket_service_stop(service) bind(c)
  import :: c_ptr
  type(c_ptr), value :: service
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_service_is_active (GSocketService *service);
function g_socket_service_is_active(service) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_service_is_active
  type(c_ptr), value :: service
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/ginetsocketaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_inet_socket_address_get_type (void) G_GNUC_CONST;
function g_inet_socket_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_inet_socket_address_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_inet_socket_address_new (GInetAddress *address, guint16 port);
function g_inet_socket_address_new(address, port) bind(c)
  import :: c_ptr, c_int16_t
  type(c_ptr) :: g_inet_socket_address_new
  type(c_ptr), value :: address
  integer(c_int16_t), value :: port
end function

! GLIB_AVAILABLE_IN_2_40
!GSocketAddress *g_inet_socket_address_new_from_string (const char *address, guint port);
function g_inet_socket_address_new_from_string(address, port) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_inet_socket_address_new_from_string
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: port
end function

! GLIB_AVAILABLE_IN_ALL
!GInetAddress * g_inet_socket_address_get_address (GInetSocketAddress *address);
function g_inet_socket_address_get_address(address) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_inet_socket_address_get_address
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_inet_socket_address_get_port (GInetSocketAddress *address);
function g_inet_socket_address_get_port(address) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_inet_socket_address_get_port
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_2_32
!guint32 g_inet_socket_address_get_flowinfo (GInetSocketAddress *address);
function g_inet_socket_address_get_flowinfo(address) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_inet_socket_address_get_flowinfo
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_2_32
!guint32 g_inet_socket_address_get_scope_id (GInetSocketAddress *address);
function g_inet_socket_address_get_scope_id(address) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_inet_socket_address_get_scope_id
  type(c_ptr), value :: address
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketaddressenumerator.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_address_enumerator_get_type (void) G_GNUC_CONST;
function g_socket_address_enumerator_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_address_enumerator_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_socket_address_enumerator_next (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_socket_address_enumerator_next(enumerator, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_address_enumerator_next_async (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_address_enumerator_next_async(enumerator, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_socket_address_enumerator_next_finish (GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_socket_address_enumerator_next_finish(enumerator, result, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gliststore.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_44
!void g_list_store_insert (GListStore *store, guint position, gpointer item);
subroutine g_list_store_insert(store, position, item) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: store
  integer(c_int), value :: position
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_44
!guint g_list_store_insert_sorted (GListStore *store, gpointer item, GCompareDataFunc compare_func, gpointer user_data);
function g_list_store_insert_sorted(store, item, compare_func, user_data)&
& bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_list_store_insert_sorted
  type(c_ptr), value :: store
  type(c_ptr), value :: item
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_46
!void g_list_store_sort (GListStore *store, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_list_store_sort(store, compare_func, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: store
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_list_store_append (GListStore *store, gpointer item);
subroutine g_list_store_append(store, item) bind(c)
  import :: c_ptr
  type(c_ptr), value :: store
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_list_store_remove (GListStore *store, guint position);
subroutine g_list_store_remove(store, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: store
  integer(c_int), value :: position
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_list_store_remove_all (GListStore *store);
subroutine g_list_store_remove_all(store) bind(c)
  import :: c_ptr
  type(c_ptr), value :: store
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_list_store_splice (GListStore *store, guint position, guint n_removals, gpointer *additions, guint n_additions);
subroutine g_list_store_splice(store, position, n_removals, additions,&
& n_additions) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: store
  integer(c_int), value :: position
  integer(c_int), value :: n_removals
  type(c_ptr), value :: additions
  integer(c_int), value :: n_additions
end subroutine

! GLIB_AVAILABLE_IN_2_64
!gboolean g_list_store_find (GListStore *store, gpointer item, guint *position);
function g_list_store_find(store, item, position) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_list_store_find
  type(c_ptr), value :: store
  type(c_ptr), value :: item
  type(c_ptr), value :: position
end function

! GLIB_AVAILABLE_IN_2_64
!gboolean g_list_store_find_with_equal_func (GListStore *store, gpointer item, GEqualFunc equal_func, guint *position);
function g_list_store_find_with_equal_func(store, item, equal_func, position)&
& bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_list_store_find_with_equal_func
  type(c_ptr), value :: store
  type(c_ptr), value :: item
  type(c_funptr), value :: equal_func
  type(c_ptr), value :: position
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusauthobserver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_auth_observer_get_type (void) G_GNUC_CONST;
function g_dbus_auth_observer_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_auth_observer_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusAuthObserver *g_dbus_auth_observer_new (void);
function g_dbus_auth_observer_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_auth_observer_new
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_auth_observer_authorize_authenticated_peer (GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
function g_dbus_auth_observer_authorize_authenticated_peer(observer, stream,&
& credentials) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_auth_observer_authorize_authenticated_peer
  type(c_ptr), value :: observer
  type(c_ptr), value :: stream
  type(c_ptr), value :: credentials
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_dbus_auth_observer_allow_mechanism (GDBusAuthObserver *observer, const gchar *mechanism);
function g_dbus_auth_observer_allow_mechanism(observer, mechanism) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_auth_observer_allow_mechanism
  type(c_ptr), value :: observer
  character(kind=c_char), dimension(*) :: mechanism
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_connection_get_type (void) G_GNUC_CONST;
function g_socket_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_connection_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_connection_is_connected (GSocketConnection *connection);
function g_socket_connection_is_connected(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_connection_is_connected
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_connection_connect (GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GError **error);
function g_socket_connection_connect(connection, address, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_connection_connect
  type(c_ptr), value :: connection
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_socket_connection_connect_async (GSocketConnection *connection, GSocketAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_connection_connect_async(connection, address, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_connection_connect_finish (GSocketConnection *connection, GAsyncResult *result, GError **error);
function g_socket_connection_connect_finish(connection, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_connection_connect_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocket *g_socket_connection_get_socket (GSocketConnection *connection);
function g_socket_connection_get_socket(connection) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connection_get_socket
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_socket_connection_get_local_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_local_address(connection, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connection_get_local_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_socket_connection_get_remote_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_remote_address(connection, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connection_get_remote_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_connection_factory_register_type (GType g_type, GSocketFamily family, GSocketType type, gint protocol);
subroutine g_socket_connection_factory_register_type(g_type, family, type,&
& protocol) bind(c)
  import :: c_size_t, c_int
  integer(c_size_t), value :: g_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_socket_connection_factory_lookup_type (GSocketFamily family, GSocketType type, gint protocol_id);
function g_socket_connection_factory_lookup_type(family, type, protocol_id)&
& bind(c)
  import :: c_size_t, c_int
  integer(c_size_t) :: g_socket_connection_factory_lookup_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol_id
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection *g_socket_connection_factory_create_connection (GSocket *socket);
function g_socket_connection_factory_create_connection(socket) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connection_factory_create_connection
  type(c_ptr), value :: socket
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsfiledatabase.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_file_database_get_type (void) G_GNUC_CONST;
function g_tls_file_database_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_file_database_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsDatabase* g_tls_file_database_new (const gchar *anchors, GError **error);
function g_tls_file_database_new(anchors, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_file_database_new
  character(kind=c_char), dimension(*) :: anchors
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpropertyaction.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_38
!GType g_property_action_get_type (void) G_GNUC_CONST;
function g_property_action_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_property_action_get_type
end function

! GLIB_AVAILABLE_IN_2_38
!GPropertyAction * g_property_action_new (const gchar *name, gpointer object, const gchar *property_name);
function g_property_action_new(name, object, property_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_property_action_new
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusmethodinvocation.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_method_invocation_get_type (void) G_GNUC_CONST;
function g_dbus_method_invocation_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_method_invocation_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_method_invocation_get_sender (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_sender(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_sender
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_method_invocation_get_object_path (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_object_path(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_object_path
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_method_invocation_get_interface_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_interface_name(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_interface_name
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_method_invocation_get_method_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_name(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_name
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!const GDBusMethodInfo *g_dbus_method_invocation_get_method_info (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_info(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_info
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_2_38
!const GDBusPropertyInfo *g_dbus_method_invocation_get_property_info (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_property_info(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_property_info
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_method_invocation_get_connection (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_connection(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_connection
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_method_invocation_get_message (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_message(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_message
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_method_invocation_get_parameters (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_parameters(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_parameters
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_dbus_method_invocation_get_user_data (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_user_data(invocation) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_user_data
  type(c_ptr), value :: invocation
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_value (GDBusMethodInvocation *invocation, GVariant *parameters);
subroutine g_dbus_method_invocation_return_value(invocation, parameters)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: parameters
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_value_with_unix_fd_list (GDBusMethodInvocation *invocation, GVariant *parameters, GUnixFDList *fd_list);
subroutine g_dbus_method_invocation_return_value_with_unix_fd_list(invocation,&
& parameters, fd_list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: parameters
  type(c_ptr), value :: fd_list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_error_valist (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args) G_GNUC_PRINTF(4, 0);
subroutine g_dbus_method_invocation_return_error_valist(invocation, domain,&
& code, format, var_args) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_error_literal (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
subroutine g_dbus_method_invocation_return_error_literal(invocation, domain,&
& code, message) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_gerror (GDBusMethodInvocation *invocation, const GError *error);
subroutine g_dbus_method_invocation_return_gerror(invocation, error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: error
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_take_error (GDBusMethodInvocation *invocation, GError *error);
subroutine g_dbus_method_invocation_take_error(invocation, error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: error
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_invocation_return_dbus_error (GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
subroutine g_dbus_method_invocation_return_dbus_error(invocation, error_name,&
& error_message) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: invocation
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsettings.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_settings_get_type (void);
function g_settings_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_settings_get_type
end function

! GLIB_DEPRECATED_IN_2_40_FOR(g_settings_schema_source_list_schemas)
!const gchar * const * g_settings_list_schemas (void);
function g_settings_list_schemas() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_list_schemas
end function

! GLIB_DEPRECATED_IN_2_40_FOR(g_settings_schema_source_list_schemas)
!const gchar * const * g_settings_list_relocatable_schemas (void);
function g_settings_list_relocatable_schemas() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_list_relocatable_schemas
end function

! GLIB_AVAILABLE_IN_ALL
!GSettings * g_settings_new (const gchar *schema_id);
function g_settings_new(schema_id) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_new
  character(kind=c_char), dimension(*) :: schema_id
end function

! GLIB_AVAILABLE_IN_ALL
!GSettings * g_settings_new_with_path (const gchar *schema_id, const gchar *path);
function g_settings_new_with_path(schema_id, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_path
  character(kind=c_char), dimension(*) :: schema_id
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_ALL
!GSettings * g_settings_new_with_backend (const gchar *schema_id, GSettingsBackend *backend);
function g_settings_new_with_backend(schema_id, backend) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend
  character(kind=c_char), dimension(*) :: schema_id
  type(c_ptr), value :: backend
end function

! GLIB_AVAILABLE_IN_ALL
!GSettings * g_settings_new_with_backend_and_path (const gchar *schema_id, GSettingsBackend *backend, const gchar *path);
function g_settings_new_with_backend_and_path(schema_id, backend, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend_and_path
  character(kind=c_char), dimension(*) :: schema_id
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_2_32
!GSettings * g_settings_new_full (GSettingsSchema *schema, GSettingsBackend *backend, const gchar *path);
function g_settings_new_full(schema, backend, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_new_full
  type(c_ptr), value :: schema
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_settings_list_children (GSettings *settings);
function g_settings_list_children(settings) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_list_children
  type(c_ptr), value :: settings
end function

! GLIB_DEPRECATED_IN_2_46_FOR(g_settings_schema_list_keys)
!gchar ** g_settings_list_keys (GSettings *settings);
function g_settings_list_keys(settings) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_list_keys
  type(c_ptr), value :: settings
end function

! GLIB_DEPRECATED_IN_2_40_FOR(g_settings_schema_key_get_range)
!GVariant * g_settings_get_range (GSettings *settings, const gchar *key);
function g_settings_get_range(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_range
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_DEPRECATED_IN_2_40_FOR(g_settings_schema_key_range_check)
!gboolean g_settings_range_check (GSettings *settings, const gchar *key, GVariant *value);
function g_settings_range_check(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_range_check
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_value (GSettings *settings, const gchar *key, GVariant *value);
function g_settings_set_value(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_settings_get_value (GSettings *settings, const gchar *key);
function g_settings_get_value(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_settings_get_user_value (GSettings *settings, const gchar *key);
function g_settings_get_user_value(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_user_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_40
!GVariant * g_settings_get_default_value (GSettings *settings, const gchar *key);
function g_settings_get_default_value(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_default_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!void g_settings_reset (GSettings *settings, const gchar *key);
subroutine g_settings_reset(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_settings_get_int (GSettings *settings, const gchar *key);
function g_settings_get_int(settings, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_int (GSettings *settings, const gchar *key, gint value);
function g_settings_set_int(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_2_50
!gint64 g_settings_get_int64 (GSettings *settings, const gchar *key);
function g_settings_get_int64(settings, key) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_settings_get_int64
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_settings_set_int64 (GSettings *settings, const gchar *key, gint64 value);
function g_settings_set_int64(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_settings_set_int64
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end function

! GLIB_AVAILABLE_IN_2_32
!guint g_settings_get_uint (GSettings *settings, const gchar *key);
function g_settings_get_uint(settings, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_uint
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_settings_set_uint (GSettings *settings, const gchar *key, guint value);
function g_settings_set_uint(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_uint
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_2_50
!guint64 g_settings_get_uint64 (GSettings *settings, const gchar *key);
function g_settings_get_uint64(settings, key) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_settings_get_uint64
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_settings_set_uint64 (GSettings *settings, const gchar *key, guint64 value);
function g_settings_set_uint64(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_settings_set_uint64
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_settings_get_string (GSettings *settings, const gchar *key);
function g_settings_get_string(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_string (GSettings *settings, const gchar *key, const gchar *value);
function g_settings_set_string(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_get_boolean (GSettings *settings, const gchar *key);
function g_settings_get_boolean(settings, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_boolean (GSettings *settings, const gchar *key, gboolean value);
function g_settings_set_boolean(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gdouble g_settings_get_double (GSettings *settings, const gchar *key);
function g_settings_get_double(settings, key) bind(c)
  import :: c_double, c_ptr, c_char
  real(c_double) :: g_settings_get_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_double (GSettings *settings, const gchar *key, gdouble value);
function g_settings_set_double(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char, c_double
  integer(c_int) :: g_settings_set_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_settings_get_strv (GSettings *settings, const gchar *key);
function g_settings_get_strv(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_strv (GSettings *settings, const gchar *key, const gchar *const *value);
function g_settings_set_strv(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_settings_get_enum (GSettings *settings, const gchar *key);
function g_settings_get_enum(settings, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_enum (GSettings *settings, const gchar *key, gint value);
function g_settings_set_enum(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_settings_get_flags (GSettings *settings, const gchar *key);
function g_settings_get_flags(settings, key) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_set_flags (GSettings *settings, const gchar *key, guint value);
function g_settings_set_flags(settings, key, value) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GSettings * g_settings_get_child (GSettings *settings, const gchar *name);
function g_settings_get_child(settings, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_get_child
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_is_writable (GSettings *settings, const gchar *name);
function g_settings_is_writable(settings, name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_is_writable
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_settings_delay (GSettings *settings);
subroutine g_settings_delay(settings) bind(c)
  import :: c_ptr
  type(c_ptr), value :: settings
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_apply (GSettings *settings);
subroutine g_settings_apply(settings) bind(c)
  import :: c_ptr
  type(c_ptr), value :: settings
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_revert (GSettings *settings);
subroutine g_settings_revert(settings) bind(c)
  import :: c_ptr
  type(c_ptr), value :: settings
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_settings_get_has_unapplied (GSettings *settings);
function g_settings_get_has_unapplied(settings) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_settings_get_has_unapplied
  type(c_ptr), value :: settings
end function

! GLIB_AVAILABLE_IN_ALL
!void g_settings_sync (void);
subroutine g_settings_sync() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_bind (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
subroutine g_settings_bind(settings, key, object, property, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_bind_with_mapping (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
subroutine g_settings_bind_with_mapping(settings, key, object, property, flags,&
& get_mapping, set_mapping, user_data, destroy) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
  type(c_funptr), value :: get_mapping
  type(c_funptr), value :: set_mapping
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_bind_writable (GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
subroutine g_settings_bind_writable(settings, key, object, property, inverted)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: inverted
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_unbind (gpointer object, const gchar *property);
subroutine g_settings_unbind(object, property) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GAction * g_settings_create_action (GSettings *settings, const gchar *key);
function g_settings_create_action(settings, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_settings_create_action
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_settings_get_mapped (GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
function g_settings_get_mapped(settings, key, mapping, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_settings_get_mapped
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_funptr), value :: mapping
  type(c_ptr), value :: user_data
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gcancellable.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_cancellable_get_type (void) G_GNUC_CONST;
function g_cancellable_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_cancellable_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GCancellable *g_cancellable_new (void);
function g_cancellable_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_cancellable_new
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_cancellable_is_cancelled (GCancellable *cancellable);
function g_cancellable_is_cancelled(cancellable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_cancellable_is_cancelled
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_cancellable_set_error_if_cancelled (GCancellable *cancellable, GError **error);
function g_cancellable_set_error_if_cancelled(cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_cancellable_set_error_if_cancelled
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!int g_cancellable_get_fd (GCancellable *cancellable);
function g_cancellable_get_fd(cancellable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_cancellable_get_fd
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_cancellable_make_pollfd (GCancellable *cancellable, GPollFD *pollfd);
function g_cancellable_make_pollfd(cancellable, pollfd) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_cancellable_make_pollfd
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: pollfd
end function

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_release_fd (GCancellable *cancellable);
subroutine g_cancellable_release_fd(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSource * g_cancellable_source_new (GCancellable *cancellable);
function g_cancellable_source_new(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_cancellable_source_new
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!GCancellable *g_cancellable_get_current (void);
function g_cancellable_get_current() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_cancellable_get_current
end function

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_push_current (GCancellable *cancellable);
subroutine g_cancellable_push_current(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_pop_current (GCancellable *cancellable);
subroutine g_cancellable_pop_current(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_reset (GCancellable *cancellable);
subroutine g_cancellable_reset(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gulong g_cancellable_connect (GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
function g_cancellable_connect(cancellable, callback, data, data_destroy_func)&
& bind(c)
  import :: c_long, c_ptr, c_funptr
  integer(c_long) :: g_cancellable_connect
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: data
  type(c_funptr), value :: data_destroy_func
end function

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_disconnect (GCancellable *cancellable, gulong handler_id);
subroutine g_cancellable_disconnect(cancellable, handler_id) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: cancellable
  integer(c_long), value :: handler_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cancellable_cancel (GCancellable *cancellable);
subroutine g_cancellable_cancel(cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_connection_get_type (void) G_GNUC_CONST;
function g_tls_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_connection_get_type
end function

! GLIB_DEPRECATED
!void g_tls_connection_set_use_system_certdb (GTlsConnection *conn, gboolean use_system_certdb);
subroutine g_tls_connection_set_use_system_certdb(conn, use_system_certdb)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: use_system_certdb
end subroutine

! GLIB_DEPRECATED
!gboolean g_tls_connection_get_use_system_certdb (GTlsConnection *conn);
function g_tls_connection_get_use_system_certdb(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_use_system_certdb
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_connection_set_database (GTlsConnection *conn, GTlsDatabase *database);
subroutine g_tls_connection_set_database(conn, database) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: database
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsDatabase * g_tls_connection_get_database (GTlsConnection *conn);
function g_tls_connection_get_database(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_database
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_connection_set_certificate (GTlsConnection *conn, GTlsCertificate *certificate);
subroutine g_tls_connection_set_certificate(conn, certificate) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: certificate
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_connection_get_certificate (GTlsConnection *conn);
function g_tls_connection_get_certificate(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_certificate
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_connection_set_interaction (GTlsConnection *conn, GTlsInteraction *interaction);
subroutine g_tls_connection_set_interaction(conn, interaction) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: interaction
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsInteraction * g_tls_connection_get_interaction (GTlsConnection *conn);
function g_tls_connection_get_interaction(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_interaction
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_connection_get_peer_certificate (GTlsConnection *conn);
function g_tls_connection_get_peer_certificate(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_peer_certificate
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors (GTlsConnection *conn);
function g_tls_connection_get_peer_certificate_errors(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_peer_certificate_errors
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_connection_set_require_close_notify (GTlsConnection *conn, gboolean require_close_notify);
subroutine g_tls_connection_set_require_close_notify(conn,&
& require_close_notify) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: require_close_notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tls_connection_get_require_close_notify (GTlsConnection *conn);
function g_tls_connection_get_require_close_notify(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_require_close_notify
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_60
!void g_tls_connection_set_advertised_protocols (GTlsConnection *conn, const gchar * const *protocols);
subroutine g_tls_connection_set_advertised_protocols(conn, protocols) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: conn
  character(kind=c_char), dimension(*) :: protocols
end subroutine

! GLIB_AVAILABLE_IN_2_60
!const gchar * g_tls_connection_get_negotiated_protocol (GTlsConnection *conn);
function g_tls_connection_get_negotiated_protocol(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_negotiated_protocol
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_tls_connection_get_channel_binding_data (GTlsConnection *conn, GTlsChannelBindingType type, GByteArray *data, GError **error);
function g_tls_connection_get_channel_binding_data(conn, type, data, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_channel_binding_data
  type(c_ptr), value :: conn
  integer(c_int), value :: type
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tls_connection_handshake (GTlsConnection *conn, GCancellable *cancellable, GError **error);
function g_tls_connection_handshake(conn, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_handshake
  type(c_ptr), value :: conn
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_connection_handshake_async (GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_connection_handshake_async(conn, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: conn
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tls_connection_handshake_finish (GTlsConnection *conn, GAsyncResult *result, GError **error);
function g_tls_connection_handshake_finish(conn, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_handshake_finish
  type(c_ptr), value :: conn
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_70
!GTlsProtocolVersion g_tls_connection_get_protocol_version (GTlsConnection *conn);
function g_tls_connection_get_protocol_version(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_protocol_version
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_70
!gchar * g_tls_connection_get_ciphersuite_name (GTlsConnection *conn);
function g_tls_connection_get_ciphersuite_name(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_connection_get_ciphersuite_name
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_tls_error_quark (void);
function g_tls_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_tls_error_quark
end function

! GLIB_AVAILABLE_IN_2_66
!GQuark g_tls_channel_binding_error_quark (void);
function g_tls_channel_binding_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_tls_channel_binding_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tls_connection_emit_accept_certificate (GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
function g_tls_connection_emit_accept_certificate(conn, peer_cert, errors)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_connection_emit_accept_certificate
  type(c_ptr), value :: conn
  type(c_ptr), value :: peer_cert
  integer(c_int), value :: errors
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfilemonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_monitor_get_type (void) G_GNUC_CONST;
function g_file_monitor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_monitor_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_monitor_cancel (GFileMonitor *monitor);
function g_file_monitor_cancel(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_monitor_cancel
  type(c_ptr), value :: monitor
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_monitor_is_cancelled (GFileMonitor *monitor);
function g_file_monitor_is_cancelled(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_monitor_is_cancelled
  type(c_ptr), value :: monitor
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_monitor_set_rate_limit (GFileMonitor *monitor, gint limit_msecs);
subroutine g_file_monitor_set_rate_limit(monitor, limit_msecs) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: monitor
  integer(c_int), value :: limit_msecs
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_monitor_emit_event (GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
subroutine g_file_monitor_emit_event(monitor, child, other_file, event_type)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: monitor
  type(c_ptr), value :: child
  type(c_ptr), value :: other_file
  integer(c_int), value :: event_type
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmemorymonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_64
!GMemoryMonitor *g_memory_monitor_dup_default (void);
function g_memory_monitor_dup_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_monitor_dup_default
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gasyncinitable.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_async_initable_get_type (void) G_GNUC_CONST;
function g_async_initable_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_async_initable_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_async_initable_init_async (GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_init_async(initable, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: initable
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_async_initable_init_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_init_finish(initable, res, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_initable_init_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties and g_async_initable_init_async)
!void g_async_initable_newv_async (GType object_type, guint n_parameters, GParameter *parameters, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_newv_async(object_type, n_parameters, parameters,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_size_t, c_int, c_ptr, c_funptr
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_async_initable_new_valist_async (GType object_type, const gchar *first_property_name, va_list var_args, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_new_valist_async(object_type, first_property_name,&
& var_args, io_priority, cancellable, callback, user_data) bind(c)
  import :: c_size_t, c_char, c_ptr, c_int, c_funptr
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GObject *g_async_initable_new_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_new_finish(initable, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_initable_new_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfilteroutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_filter_output_stream_get_type (void) G_GNUC_CONST;
function g_filter_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_filter_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream * g_filter_output_stream_get_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_base_stream(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_filter_output_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_filter_output_stream_get_close_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_close_base_stream(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_filter_output_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_filter_output_stream_set_close_base_stream (GFilterOutputStream *stream, gboolean close_base);
subroutine g_filter_output_stream_set_close_base_stream(stream, close_base)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: close_base
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_manager_client_get_type (void) G_GNUC_CONST;
function g_dbus_object_manager_client_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_manager_client_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_manager_client_new (GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_object_manager_client_new(connection, flags, name,&
& object_path, get_proxy_type_func, get_proxy_type_user_data,&
& get_proxy_type_destroy_notify, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_char, c_funptr
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  type(c_funptr), value :: get_proxy_type_func
  type(c_ptr), value :: get_proxy_type_user_data
  type(c_funptr), value :: get_proxy_type_destroy_notify
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManager *g_dbus_object_manager_client_new_finish (GAsyncResult *res, GError **error);
function g_dbus_object_manager_client_new_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_client_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManager *g_dbus_object_manager_client_new_sync (GDBusConnection *connection, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
function g_dbus_object_manager_client_new_sync(connection, flags, name,&
& object_path, get_proxy_type_func, get_proxy_type_user_data,&
& get_proxy_type_destroy_notify, cancellable, error) bind(c)
  import :: c_ptr, c_int, c_char, c_funptr
  type(c_ptr) :: g_dbus_object_manager_client_new_sync
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  type(c_funptr), value :: get_proxy_type_func
  type(c_ptr), value :: get_proxy_type_user_data
  type(c_funptr), value :: get_proxy_type_destroy_notify
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_manager_client_new_for_bus (GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_object_manager_client_new_for_bus(bus_type, flags, name,&
& object_path, get_proxy_type_func, get_proxy_type_user_data,&
& get_proxy_type_destroy_notify, cancellable, callback, user_data) bind(c)
  import :: c_int, c_char, c_funptr, c_ptr
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  type(c_funptr), value :: get_proxy_type_func
  type(c_ptr), value :: get_proxy_type_user_data
  type(c_funptr), value :: get_proxy_type_destroy_notify
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_finish (GAsyncResult *res, GError **error);
function g_dbus_object_manager_client_new_for_bus_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_client_new_for_bus_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_sync (GBusType bus_type, GDBusObjectManagerClientFlags flags, const gchar *name, const gchar *object_path, GDBusProxyTypeFunc get_proxy_type_func, gpointer get_proxy_type_user_data, GDestroyNotify get_proxy_type_destroy_notify, GCancellable *cancellable, GError **error);
function g_dbus_object_manager_client_new_for_bus_sync(bus_type, flags, name,&
& object_path, get_proxy_type_func, get_proxy_type_user_data,&
& get_proxy_type_destroy_notify, cancellable, error) bind(c)
  import :: c_ptr, c_int, c_char, c_funptr
  type(c_ptr) :: g_dbus_object_manager_client_new_for_bus_sync
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  type(c_funptr), value :: get_proxy_type_func
  type(c_ptr), value :: get_proxy_type_user_data
  type(c_funptr), value :: get_proxy_type_destroy_notify
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_object_manager_client_get_connection (GDBusObjectManagerClient *manager);
function g_dbus_object_manager_client_get_connection(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_client_get_connection
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManagerClientFlags g_dbus_object_manager_client_get_flags (GDBusObjectManagerClient *manager);
function g_dbus_object_manager_client_get_flags(manager) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_object_manager_client_get_flags
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_object_manager_client_get_name (GDBusObjectManagerClient *manager);
function g_dbus_object_manager_client_get_name(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_client_get_name
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_object_manager_client_get_name_owner (GDBusObjectManagerClient *manager);
function g_dbus_object_manager_client_get_name_owner(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_client_get_name_owner
  type(c_ptr), value :: manager
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gaction.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_30
!GType g_action_get_type (void) G_GNUC_CONST;
function g_action_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_action_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_action_get_name (GAction *action);
function g_action_get_name(action) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_get_name
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_action_get_parameter_type (GAction *action);
function g_action_get_parameter_type(action) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_get_parameter_type
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_action_get_state_type (GAction *action);
function g_action_get_state_type(action) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_get_state_type
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_action_get_state_hint (GAction *action);
function g_action_get_state_hint(action) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_get_state_hint
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_action_get_enabled (GAction *action);
function g_action_get_enabled(action) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_action_get_enabled
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_action_get_state (GAction *action);
function g_action_get_state(action) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_get_state
  type(c_ptr), value :: action
end function

! GLIB_AVAILABLE_IN_ALL
!void g_action_change_state (GAction *action, GVariant *value);
subroutine g_action_change_state(action, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_activate (GAction *action, GVariant *parameter);
subroutine g_action_activate(action, parameter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: parameter
end subroutine

! GLIB_AVAILABLE_IN_2_28
!gboolean g_action_name_is_valid (const gchar *action_name);
function g_action_name_is_valid(action_name) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_action_name_is_valid
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_2_38
!gboolean g_action_parse_detailed_name (const gchar *detailed_name, gchar **action_name, GVariant **target_value, GError **error);
function g_action_parse_detailed_name(detailed_name, action_name, target_value,&
& error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_action_parse_detailed_name
  character(kind=c_char), dimension(*) :: detailed_name
  type(c_ptr), dimension(*) :: action_name
  type(c_ptr), value :: target_value
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!gchar * g_action_print_detailed_name (const gchar *action_name, GVariant *target_value);
function g_action_print_detailed_name(action_name, target_value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_print_detailed_name
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: target_value
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketclient.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_client_get_type (void) G_GNUC_CONST;
function g_socket_client_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_client_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketClient *g_socket_client_new (void);
function g_socket_client_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_new
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketFamily g_socket_client_get_family (GSocketClient *client);
function g_socket_client_get_family(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_family
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_family (GSocketClient *client, GSocketFamily family);
subroutine g_socket_client_set_family(client, family) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: family
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketType g_socket_client_get_socket_type (GSocketClient *client);
function g_socket_client_get_socket_type(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_socket_type
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_socket_type (GSocketClient *client, GSocketType type);
subroutine g_socket_client_set_socket_type(client, type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketProtocol g_socket_client_get_protocol (GSocketClient *client);
function g_socket_client_get_protocol(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_protocol
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_protocol (GSocketClient *client, GSocketProtocol protocol);
subroutine g_socket_client_set_protocol(client, protocol) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: protocol
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_socket_client_get_local_address (GSocketClient *client);
function g_socket_client_get_local_address(client) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_get_local_address
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_local_address (GSocketClient *client, GSocketAddress *address);
subroutine g_socket_client_set_local_address(client, address) bind(c)
  import :: c_ptr
  type(c_ptr), value :: client
  type(c_ptr), value :: address
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_socket_client_get_timeout (GSocketClient *client);
function g_socket_client_get_timeout(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_timeout
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_timeout (GSocketClient *client, guint timeout);
subroutine g_socket_client_set_timeout(client, timeout) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: timeout
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_client_get_enable_proxy (GSocketClient *client);
function g_socket_client_get_enable_proxy(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_enable_proxy
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_set_enable_proxy (GSocketClient *client, gboolean enable);
subroutine g_socket_client_set_enable_proxy(client, enable) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: enable
end subroutine

! GLIB_AVAILABLE_IN_2_28
!gboolean g_socket_client_get_tls (GSocketClient *client);
function g_socket_client_get_tls(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_tls
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_2_28
!void g_socket_client_set_tls (GSocketClient *client, gboolean tls);
subroutine g_socket_client_set_tls(client, tls) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: tls
end subroutine

! GLIB_DEPRECATED_IN_2_72
!GTlsCertificateFlags g_socket_client_get_tls_validation_flags (GSocketClient *client);
function g_socket_client_get_tls_validation_flags(client) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_tls_validation_flags
  type(c_ptr), value :: client
end function

! GLIB_DEPRECATED_IN_2_72
!void g_socket_client_set_tls_validation_flags (GSocketClient *client, GTlsCertificateFlags flags);
subroutine g_socket_client_set_tls_validation_flags(client, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_36
!GProxyResolver *g_socket_client_get_proxy_resolver (GSocketClient *client);
function g_socket_client_get_proxy_resolver(client) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_get_proxy_resolver
  type(c_ptr), value :: client
end function

! GLIB_AVAILABLE_IN_2_36
!void g_socket_client_set_proxy_resolver (GSocketClient *client, GProxyResolver *proxy_resolver);
subroutine g_socket_client_set_proxy_resolver(client, proxy_resolver) bind(c)
  import :: c_ptr
  type(c_ptr), value :: client
  type(c_ptr), value :: proxy_resolver
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
function g_socket_client_connect(client, connectable, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_connect
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_to_host (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_host(client, host_and_port, default_port,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_host
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_to_service (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_service(client, domain, service,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_socket_client_connect_to_service
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_26
!GSocketConnection * g_socket_client_connect_to_uri (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_uri(client, uri, default_port, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_uri
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_connect_async (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_async(client, connectable, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_finish(client, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_connect_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_connect_to_host_async (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_host_async(client, host_and_port,&
& default_port, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_to_host_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_host_finish(client, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_host_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_connect_to_service_async (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_service_async(client, domain, service,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_to_service_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_service_finish(client, result, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_service_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_connect_to_uri_async (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_uri_async(client, uri, default_port,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_client_connect_to_uri_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_uri_finish(client, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_uri_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_client_add_application_proxy (GSocketClient *client, const gchar *protocol);
subroutine g_socket_client_add_application_proxy(client, protocol) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: protocol
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_icon_get_type (void) G_GNUC_CONST;
function g_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_icon_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_icon_hash (gconstpointer icon);
function g_icon_hash(icon) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_icon_hash
  type(c_ptr), value :: icon
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_icon_equal (GIcon *icon1, GIcon *icon2);
function g_icon_equal(icon1, icon2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_icon_equal
  type(c_ptr), value :: icon1
  type(c_ptr), value :: icon2
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_icon_to_string (GIcon *icon);
function g_icon_to_string(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_icon_to_string
  type(c_ptr), value :: icon
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_icon_new_for_string (const gchar *str, GError **error);
function g_icon_new_for_string(str, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_icon_new_for_string
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!GVariant * g_icon_serialize (GIcon *icon);
function g_icon_serialize(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_icon_serialize
  type(c_ptr), value :: icon
end function

! GLIB_AVAILABLE_IN_2_38
!GIcon * g_icon_deserialize (GVariant *value);
function g_icon_deserialize(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_icon_deserialize
  type(c_ptr), value :: value
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimpleiostream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_44
!GType g_simple_io_stream_get_type (void) G_GNUC_CONST;
function g_simple_io_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_io_stream_get_type
end function

! GLIB_AVAILABLE_IN_2_44
!GIOStream *g_simple_io_stream_new (GInputStream *input_stream, GOutputStream *output_stream);
function g_simple_io_stream_new(input_stream, output_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_simple_io_stream_new
  type(c_ptr), value :: input_stream
  type(c_ptr), value :: output_stream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gproxyaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_proxy_address_get_type (void) G_GNUC_CONST;
function g_proxy_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_proxy_address_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_proxy_address_new (GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
function g_proxy_address_new(inetaddr, port, protocol, dest_hostname,&
& dest_port, username, password) bind(c)
  import :: c_ptr, c_int16_t, c_char
  type(c_ptr) :: g_proxy_address_new
  type(c_ptr), value :: inetaddr
  integer(c_int16_t), value :: port
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: dest_hostname
  integer(c_int16_t), value :: dest_port
  character(kind=c_char), dimension(*) :: username
  character(kind=c_char), dimension(*) :: password
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_proxy_address_get_protocol (GProxyAddress *proxy);
function g_proxy_address_get_protocol(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_protocol
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_2_34
!const gchar *g_proxy_address_get_destination_protocol (GProxyAddress *proxy);
function g_proxy_address_get_destination_protocol(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_destination_protocol
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_proxy_address_get_destination_hostname (GProxyAddress *proxy);
function g_proxy_address_get_destination_hostname(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_destination_hostname
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_proxy_address_get_destination_port (GProxyAddress *proxy);
function g_proxy_address_get_destination_port(proxy) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_proxy_address_get_destination_port
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_proxy_address_get_username (GProxyAddress *proxy);
function g_proxy_address_get_username(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_username
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_proxy_address_get_password (GProxyAddress *proxy);
function g_proxy_address_get_password(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_password
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_2_34
!const gchar *g_proxy_address_get_uri (GProxyAddress *proxy);
function g_proxy_address_get_uri(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_address_get_uri
  type(c_ptr), value :: proxy
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimplepermission.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_simple_permission_get_type (void);
function g_simple_permission_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_permission_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GPermission * g_simple_permission_new (gboolean allowed);
function g_simple_permission_new(allowed) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_simple_permission_new
  integer(c_int), value :: allowed
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlscertificate.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_certificate_get_type (void) G_GNUC_CONST;
function g_tls_certificate_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_certificate_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_certificate_new_from_pem (const gchar *data, gssize length, GError **error);
function g_tls_certificate_new_from_pem(data, length, error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_tls_certificate_new_from_pem
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_72
!GTlsCertificate *g_tls_certificate_new_from_pkcs12 (const guint8 *data, gsize length, const gchar *password, GError **error);
function g_tls_certificate_new_from_pkcs12(data, length, password, error)&
& bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_tls_certificate_new_from_pkcs12
  type(c_ptr), value :: data
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: password
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_72
!GTlsCertificate *g_tls_certificate_new_from_file_with_password (const gchar *file, const gchar *password, GError **error);
function g_tls_certificate_new_from_file_with_password(file, password, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_file_with_password
  character(kind=c_char), dimension(*) :: file
  character(kind=c_char), dimension(*) :: password
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_certificate_new_from_file (const gchar *file, GError **error);
function g_tls_certificate_new_from_file(file, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_certificate_new_from_files (const gchar *cert_file, const gchar *key_file, GError **error);
function g_tls_certificate_new_from_files(cert_file, key_file, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_files
  character(kind=c_char), dimension(*) :: cert_file
  character(kind=c_char), dimension(*) :: key_file
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_68
!GTlsCertificate *g_tls_certificate_new_from_pkcs11_uris (const gchar *pkcs11_uri, const gchar *private_key_pkcs11_uri, GError **error);
function g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri,&
& private_key_pkcs11_uri, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_pkcs11_uris
  character(kind=c_char), dimension(*) :: pkcs11_uri
  character(kind=c_char), dimension(*) :: private_key_pkcs11_uri
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_tls_certificate_list_new_from_file (const gchar *file, GError **error);
function g_tls_certificate_list_new_from_file(file, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_list_new_from_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate *g_tls_certificate_get_issuer (GTlsCertificate *cert);
function g_tls_certificate_get_issuer(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_issuer
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificateFlags g_tls_certificate_verify (GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca);
function g_tls_certificate_verify(cert, identity, trusted_ca) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_certificate_verify
  type(c_ptr), value :: cert
  type(c_ptr), value :: identity
  type(c_ptr), value :: trusted_ca
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_tls_certificate_is_same (GTlsCertificate *cert_one, GTlsCertificate *cert_two);
function g_tls_certificate_is_same(cert_one, cert_two) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_certificate_is_same
  type(c_ptr), value :: cert_one
  type(c_ptr), value :: cert_two
end function

! GLIB_AVAILABLE_IN_2_70
!GDateTime *g_tls_certificate_get_not_valid_before (GTlsCertificate *cert);
function g_tls_certificate_get_not_valid_before(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_not_valid_before
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_2_70
!GDateTime *g_tls_certificate_get_not_valid_after (GTlsCertificate *cert);
function g_tls_certificate_get_not_valid_after(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_not_valid_after
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_2_70
!gchar *g_tls_certificate_get_subject_name (GTlsCertificate *cert);
function g_tls_certificate_get_subject_name(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_subject_name
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_2_70
!gchar *g_tls_certificate_get_issuer_name (GTlsCertificate *cert);
function g_tls_certificate_get_issuer_name(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_issuer_name
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_2_70
!GPtrArray *g_tls_certificate_get_dns_names (GTlsCertificate *cert);
function g_tls_certificate_get_dns_names(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_dns_names
  type(c_ptr), value :: cert
end function

! GLIB_AVAILABLE_IN_2_70
!GPtrArray *g_tls_certificate_get_ip_addresses (GTlsCertificate *cert);
function g_tls_certificate_get_ip_addresses(cert) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_certificate_get_ip_addresses
  type(c_ptr), value :: cert
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gcontenttype.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_content_type_equals (const gchar *type1, const gchar *type2);
function g_content_type_equals(type1, type2) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_content_type_equals
  character(kind=c_char), dimension(*) :: type1
  character(kind=c_char), dimension(*) :: type2
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_content_type_is_a (const gchar *type, const gchar *supertype);
function g_content_type_is_a(type, supertype) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_content_type_is_a
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: supertype
end function

! GLIB_AVAILABLE_IN_2_52
!gboolean g_content_type_is_mime_type (const gchar *type, const gchar *mime_type);
function g_content_type_is_mime_type(type, mime_type) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_content_type_is_mime_type
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: mime_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_content_type_is_unknown (const gchar *type);
function g_content_type_is_unknown(type) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_content_type_is_unknown
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_content_type_get_description (const gchar *type);
function g_content_type_get_description(type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_description
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_content_type_get_mime_type (const gchar *type);
function g_content_type_get_mime_type(type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_mime_type
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_content_type_get_icon (const gchar *type);
function g_content_type_get_icon(type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_icon
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_2_34
!GIcon * g_content_type_get_symbolic_icon (const gchar *type);
function g_content_type_get_symbolic_icon(type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_symbolic_icon
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_2_34
!gchar * g_content_type_get_generic_icon_name (const gchar *type);
function g_content_type_get_generic_icon_name(type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_generic_icon_name
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_content_type_can_be_executable (const gchar *type);
function g_content_type_can_be_executable(type) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_content_type_can_be_executable
  character(kind=c_char), dimension(*) :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_content_type_from_mime_type (const gchar *mime_type);
function g_content_type_from_mime_type(mime_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_content_type_from_mime_type
  character(kind=c_char), dimension(*) :: mime_type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_content_type_guess (const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
function g_content_type_guess(filename, data, data_size, result_uncertain)&
& bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_content_type_guess
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: result_uncertain
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_content_type_guess_for_tree (GFile *root);
function g_content_type_guess_for_tree(root) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_content_type_guess_for_tree
  type(c_ptr), value :: root
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_content_types_get_registered (void);
function g_content_types_get_registered() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_content_types_get_registered
end function

! GLIB_AVAILABLE_IN_2_60
!const gchar * const *g_content_type_get_mime_dirs (void);
function g_content_type_get_mime_dirs() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_content_type_get_mime_dirs
end function

! GLIB_AVAILABLE_IN_2_60
!void g_content_type_set_mime_dirs (const gchar * const *dirs);
subroutine g_content_type_set_mime_dirs(dirs) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: dirs
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnativesocketaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_46
!GType g_native_socket_address_get_type (void) G_GNUC_CONST;
function g_native_socket_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_native_socket_address_get_type
end function

! GLIB_AVAILABLE_IN_2_46
!GSocketAddress *g_native_socket_address_new (gpointer native, gsize len);
function g_native_socket_address_new(native, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_native_socket_address_new
  type(c_ptr), value :: native
  integer(c_size_t), value :: len
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gresolver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_resolver_get_type (void) G_GNUC_CONST;
function g_resolver_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_resolver_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GResolver *g_resolver_get_default (void);
function g_resolver_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_get_default
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_set_default (GResolver *resolver);
subroutine g_resolver_set_default(resolver) bind(c)
  import :: c_ptr
  type(c_ptr), value :: resolver
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList *g_resolver_lookup_by_name (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_name(resolver, hostname, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_by_name
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_lookup_by_name_async (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_name_async(resolver, hostname, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList *g_resolver_lookup_by_name_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_name_finish(resolver, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_name_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!void g_resolver_lookup_by_name_with_flags_async (GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_name_with_flags_async(resolver, hostname,&
& flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_60
!GList *g_resolver_lookup_by_name_with_flags_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_name_with_flags_finish(resolver, result, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_name_with_flags_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!GList *g_resolver_lookup_by_name_with_flags (GResolver *resolver, const gchar *hostname, GResolverNameLookupFlags flags, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_name_with_flags(resolver, hostname, flags,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resolver_lookup_by_name_with_flags
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_free_addresses (GList *addresses);
subroutine g_resolver_free_addresses(addresses) bind(c)
  import :: c_ptr
  type(c_ptr), value :: addresses
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_resolver_lookup_by_address (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_address(resolver, address, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_lookup_by_address_async (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_address_async(resolver, address, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_resolver_lookup_by_address_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_address_finish(resolver, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_resolver_lookup_service (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
function g_resolver_lookup_service(resolver, service, protocol, domain,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_service
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_lookup_service_async (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_service_async(resolver, service, protocol, domain,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList *g_resolver_lookup_service_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_service_finish(resolver, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_service_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!GList *g_resolver_lookup_records (GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GError **error);
function g_resolver_lookup_records(resolver, rrname, record_type, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resolver_lookup_records
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: rrname
  integer(c_int), value :: record_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!void g_resolver_lookup_records_async (GResolver *resolver, const gchar *rrname, GResolverRecordType record_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_records_async(resolver, rrname, record_type,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: rrname
  integer(c_int), value :: record_type
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_34
!GList *g_resolver_lookup_records_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_records_finish(resolver, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resolver_lookup_records_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_resolver_free_targets (GList *targets);
subroutine g_resolver_free_targets(targets) bind(c)
  import :: c_ptr
  type(c_ptr), value :: targets
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GQuark g_resolver_error_quark (void);
function g_resolver_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_resolver_error_quark
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gloadableicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_loadable_icon_get_type (void) G_GNUC_CONST;
function g_loadable_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_loadable_icon_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream *g_loadable_icon_load (GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
function g_loadable_icon_load(icon, size, type, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_loadable_icon_load
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  type(c_ptr), dimension(*) :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_loadable_icon_load_async (GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_loadable_icon_load_async(icon, size, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GInputStream *g_loadable_icon_load_finish (GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
function g_loadable_icon_load_finish(icon, res, type, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_loadable_icon_load_finish
  type(c_ptr), value :: icon
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: type
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gthemedicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_themed_icon_get_type (void) G_GNUC_CONST;
function g_themed_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_themed_icon_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_themed_icon_new (const char *iconname);
function g_themed_icon_new(iconname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new
  character(kind=c_char), dimension(*) :: iconname
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_themed_icon_new_with_default_fallbacks (const char *iconname);
function g_themed_icon_new_with_default_fallbacks(iconname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new_with_default_fallbacks
  character(kind=c_char), dimension(*) :: iconname
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_themed_icon_new_from_names (char **iconnames, int len);
function g_themed_icon_new_from_names(iconnames, len) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_themed_icon_new_from_names
  type(c_ptr), dimension(*) :: iconnames
  integer(c_int), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!void g_themed_icon_prepend_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_prepend_name(icon, iconname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_themed_icon_append_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_append_name(icon, iconname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar* const * g_themed_icon_get_names (GThemedIcon *icon);
function g_themed_icon_get_names(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_themed_icon_get_names
  type(c_ptr), value :: icon
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/ginputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_input_stream_get_type (void) G_GNUC_CONST;
function g_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_input_stream_read (GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_read(stream, buffer, count, cancellable, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_read_all (GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
function g_input_stream_read_all(stream, buffer, count, bytes_read,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_input_stream_read_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!GBytes *g_input_stream_read_bytes (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_read_bytes(stream, count, cancellable, error) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_input_stream_read_bytes
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_input_stream_skip (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_skip(stream, count, cancellable, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_close (GInputStream *stream, GCancellable *cancellable, GError **error);
function g_input_stream_close(stream, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_input_stream_read_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_read_async(stream, buffer, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gssize g_input_stream_read_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_read_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_44
!void g_input_stream_read_all_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_read_all_async(stream, buffer, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_44
!gboolean g_input_stream_read_all_finish (GInputStream *stream, GAsyncResult *result, gsize *bytes_read, GError **error);
function g_input_stream_read_all_finish(stream, result, bytes_read, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_read_all_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!void g_input_stream_read_bytes_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_read_bytes_async(stream, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_34
!GBytes *g_input_stream_read_bytes_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_read_bytes_finish(stream, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_input_stream_read_bytes_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_input_stream_skip_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_skip_async(stream, count, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gssize g_input_stream_skip_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_skip_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_input_stream_close_async (GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_close_async(stream, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_close_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_close_finish(stream, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_is_closed (GInputStream *stream);
function g_input_stream_is_closed(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_is_closed
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_has_pending (GInputStream *stream);
function g_input_stream_has_pending(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_has_pending
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_input_stream_set_pending (GInputStream *stream, GError **error);
function g_input_stream_set_pending(stream, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_input_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_input_stream_clear_pending (GInputStream *stream);
subroutine g_input_stream_clear_pending(stream) bind(c)
  import :: c_ptr
  type(c_ptr), value :: stream
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileiostream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_io_stream_get_type (void) G_GNUC_CONST;
function g_file_io_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_io_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_io_stream_query_info (GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_io_stream_query_info(stream, attributes, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_io_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_io_stream_query_info_async (GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_io_stream_query_info_async(stream, attributes, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_io_stream_query_info_finish (GFileIOStream *stream, GAsyncResult *result, GError **error);
function g_file_io_stream_query_info_finish(stream, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_io_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_io_stream_get_etag (GFileIOStream *stream);
function g_file_io_stream_get_etag(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_io_stream_get_etag
  type(c_ptr), value :: stream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketconnectable.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_connectable_get_type (void) G_GNUC_CONST;
function g_socket_connectable_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_connectable_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddressEnumerator *g_socket_connectable_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_enumerate(connectable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connectable_enumerate
  type(c_ptr), value :: connectable
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_proxy_enumerate(connectable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connectable_proxy_enumerate
  type(c_ptr), value :: connectable
end function

! GLIB_AVAILABLE_IN_2_48
!gchar *g_socket_connectable_to_string (GSocketConnectable *connectable);
function g_socket_connectable_to_string(connectable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_connectable_to_string
  type(c_ptr), value :: connectable
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtestdbus.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_34
!GType g_test_dbus_get_type (void) G_GNUC_CONST;
function g_test_dbus_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_test_dbus_get_type
end function

! GLIB_AVAILABLE_IN_2_34
!GTestDBus * g_test_dbus_new (GTestDBusFlags flags);
function g_test_dbus_new(flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_test_dbus_new
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_34
!GTestDBusFlags g_test_dbus_get_flags (GTestDBus *self);
function g_test_dbus_get_flags(self) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_test_dbus_get_flags
  type(c_ptr), value :: self
end function

! GLIB_AVAILABLE_IN_2_34
!const gchar * g_test_dbus_get_bus_address (GTestDBus *self);
function g_test_dbus_get_bus_address(self) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_test_dbus_get_bus_address
  type(c_ptr), value :: self
end function

! GLIB_AVAILABLE_IN_2_34
!void g_test_dbus_add_service_dir (GTestDBus *self, const gchar *path);
subroutine g_test_dbus_add_service_dir(self, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_dbus_up (GTestDBus *self);
subroutine g_test_dbus_up(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_dbus_stop (GTestDBus *self);
subroutine g_test_dbus_stop(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_dbus_down (GTestDBus *self);
subroutine g_test_dbus_down(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_34
!void g_test_dbus_unset (void);
subroutine g_test_dbus_unset() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gunixconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_unix_connection_send_fd (GUnixConnection *connection, gint fd, GCancellable *cancellable, GError **error);
function g_unix_connection_send_fd(connection, fd, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_connection_send_fd
  type(c_ptr), value :: connection
  integer(c_int), value :: fd
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_unix_connection_receive_fd (GUnixConnection *connection, GCancellable *cancellable, GError **error);
function g_unix_connection_receive_fd(connection, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_connection_receive_fd
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unix_connection_send_credentials (GUnixConnection *connection, GCancellable *cancellable, GError **error);
function g_unix_connection_send_credentials(connection, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_connection_send_credentials
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_unix_connection_send_credentials_async (GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_unix_connection_send_credentials_async(connection, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_unix_connection_send_credentials_finish (GUnixConnection *connection, GAsyncResult *result, GError **error);
function g_unix_connection_send_credentials_finish(connection, result, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_connection_send_credentials_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GCredentials *g_unix_connection_receive_credentials (GUnixConnection *connection, GCancellable *cancellable, GError **error);
function g_unix_connection_receive_credentials(connection, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_connection_receive_credentials
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_unix_connection_receive_credentials_async (GUnixConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_unix_connection_receive_credentials_async(connection, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GCredentials *g_unix_connection_receive_credentials_finish (GUnixConnection *connection, GAsyncResult *result, GError **error);
function g_unix_connection_receive_credentials_finish(connection, result,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_connection_receive_credentials_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusnameowning.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!guint g_bus_own_name (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name(bus_type, name, flags, bus_acquired_handler,&
& name_acquired_handler, name_lost_handler, user_data, user_data_free_func)&
& bind(c)
  import :: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_own_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: bus_acquired_handler
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_own_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name_on_connection(connection, name, flags,&
& name_acquired_handler, name_lost_handler, user_data, user_data_free_func)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_own_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_own_name_with_closures (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_with_closures(bus_type, name, flags,&
& bus_acquired_closure, name_acquired_closure, name_lost_closure) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_own_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: bus_acquired_closure
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_own_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_on_connection_with_closures(connection, name, flags,&
& name_acquired_closure, name_lost_closure) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_own_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bus_unown_name (guint owner_id);
subroutine g_bus_unown_name(owner_id) bind(c)
  import :: c_int
  integer(c_int), value :: owner_id
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusinterface.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_interface_get_type (void) G_GNUC_CONST;
function g_dbus_interface_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_interface_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceInfo *g_dbus_interface_get_info (GDBusInterface *interface_);
function g_dbus_interface_get_info(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_get_info
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObject *g_dbus_interface_get_object (GDBusInterface *interface_);
function g_dbus_interface_get_object(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_get_object
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_set_object (GDBusInterface *interface_, GDBusObject *object);
subroutine g_dbus_interface_set_object(interface_, object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: interface_
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GDBusObject *g_dbus_interface_dup_object (GDBusInterface *interface_);
function g_dbus_interface_dup_object(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_dup_object
  type(c_ptr), value :: interface_
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusintrospection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_annotation_info_lookup (GDBusAnnotationInfo **annotations, const gchar *name);
function g_dbus_annotation_info_lookup(annotations, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_annotation_info_lookup
  type(c_ptr), value :: annotations
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMethodInfo *g_dbus_interface_info_lookup_method (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_method(info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_method
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusSignalInfo *g_dbus_interface_info_lookup_signal (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_signal(info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_signal
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusPropertyInfo *g_dbus_interface_info_lookup_property (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_property(info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_property
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_info_cache_build (GDBusInterfaceInfo *info);
subroutine g_dbus_interface_info_cache_build(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_info_cache_release (GDBusInterfaceInfo *info);
subroutine g_dbus_interface_info_cache_release(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_info_generate_xml (GDBusInterfaceInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_interface_info_generate_xml(info, indent, string_builder)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusNodeInfo *g_dbus_node_info_new_for_xml (const gchar *xml_data, GError **error);
function g_dbus_node_info_new_for_xml(xml_data, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_new_for_xml
  character(kind=c_char), dimension(*) :: xml_data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceInfo *g_dbus_node_info_lookup_interface (GDBusNodeInfo *info, const gchar *name);
function g_dbus_node_info_lookup_interface(info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_lookup_interface
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_node_info_generate_xml (GDBusNodeInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_node_info_generate_xml(info, indent, string_builder) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusNodeInfo *g_dbus_node_info_ref (GDBusNodeInfo *info);
function g_dbus_node_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_node_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceInfo *g_dbus_interface_info_ref (GDBusInterfaceInfo *info);
function g_dbus_interface_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMethodInfo *g_dbus_method_info_ref (GDBusMethodInfo *info);
function g_dbus_method_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_method_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusSignalInfo *g_dbus_signal_info_ref (GDBusSignalInfo *info);
function g_dbus_signal_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_signal_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusPropertyInfo *g_dbus_property_info_ref (GDBusPropertyInfo *info);
function g_dbus_property_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_property_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusArgInfo *g_dbus_arg_info_ref (GDBusArgInfo *info);
function g_dbus_arg_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_arg_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusAnnotationInfo *g_dbus_annotation_info_ref (GDBusAnnotationInfo *info);
function g_dbus_annotation_info_ref(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_annotation_info_ref
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_node_info_unref (GDBusNodeInfo *info);
subroutine g_dbus_node_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_info_unref (GDBusInterfaceInfo *info);
subroutine g_dbus_interface_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_method_info_unref (GDBusMethodInfo *info);
subroutine g_dbus_method_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_signal_info_unref (GDBusSignalInfo *info);
subroutine g_dbus_signal_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_property_info_unref (GDBusPropertyInfo *info);
subroutine g_dbus_property_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_arg_info_unref (GDBusArgInfo *info);
subroutine g_dbus_arg_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_annotation_info_unref (GDBusAnnotationInfo *info);
subroutine g_dbus_annotation_info_unref(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_node_info_get_type (void) G_GNUC_CONST;
function g_dbus_node_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_node_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_interface_info_get_type (void) G_GNUC_CONST;
function g_dbus_interface_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_interface_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_method_info_get_type (void) G_GNUC_CONST;
function g_dbus_method_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_method_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_signal_info_get_type (void) G_GNUC_CONST;
function g_dbus_signal_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_signal_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_property_info_get_type (void) G_GNUC_CONST;
function g_dbus_property_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_property_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_arg_info_get_type (void) G_GNUC_CONST;
function g_dbus_arg_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_arg_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_annotation_info_get_type (void) G_GNUC_CONST;
function g_dbus_annotation_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_annotation_info_get_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdataoutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_data_output_stream_get_type (void) G_GNUC_CONST;
function g_data_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_data_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDataOutputStream * g_data_output_stream_new (GOutputStream *base_stream);
function g_data_output_stream_new(base_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_output_stream_new
  type(c_ptr), value :: base_stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_data_output_stream_set_byte_order (GDataOutputStream *stream, GDataStreamByteOrder order);
subroutine g_data_output_stream_set_byte_order(stream, order) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDataStreamByteOrder g_data_output_stream_get_byte_order (GDataOutputStream *stream);
function g_data_output_stream_get_byte_order(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_data_output_stream_get_byte_order
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_byte (GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_byte(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int8_t
  integer(c_int) :: g_data_output_stream_put_byte
  type(c_ptr), value :: stream
  integer(kind=c_int8_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_int16 (GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int16(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_data_output_stream_put_int16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_uint16 (GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint16(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_data_output_stream_put_uint16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_int32 (GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int32(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_data_output_stream_put_int32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_uint32 (GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint32(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_data_output_stream_put_uint32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_int64 (GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int64(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_data_output_stream_put_int64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_uint64 (GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint64(stream, data, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_data_output_stream_put_uint64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_data_output_stream_put_string (GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_string(stream, str, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_data_output_stream_put_string
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gzlibdecompressor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_zlib_decompressor_get_type (void) G_GNUC_CONST;
function g_zlib_decompressor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_zlib_decompressor_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GZlibDecompressor *g_zlib_decompressor_new (GZlibCompressorFormat format);
function g_zlib_decompressor_new(format) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_zlib_decompressor_new
  integer(c_int), value :: format
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_zlib_decompressor_get_file_info (GZlibDecompressor *decompressor);
function g_zlib_decompressor_get_file_info(decompressor) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_zlib_decompressor_get_file_info
  type(c_ptr), value :: decompressor
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfilterinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_filter_input_stream_get_type (void) G_GNUC_CONST;
function g_filter_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_filter_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream * g_filter_input_stream_get_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_base_stream(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_filter_input_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_filter_input_stream_get_close_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_close_base_stream(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_filter_input_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_filter_input_stream_set_close_base_stream (GFilterInputStream *stream, gboolean close_base);
subroutine g_filter_input_stream_set_close_base_stream(stream, close_base)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: close_base
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gappinfo.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_app_info_get_type (void) G_GNUC_CONST;
function g_app_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_app_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GAppInfo * g_app_info_create_from_commandline (const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
function g_app_info_create_from_commandline(commandline, application_name,&
& flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_app_info_create_from_commandline
  character(kind=c_char), dimension(*) :: commandline
  character(kind=c_char), dimension(*) :: application_name
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GAppInfo * g_app_info_dup (GAppInfo *appinfo);
function g_app_info_dup(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_dup
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_equal (GAppInfo *appinfo1, GAppInfo *appinfo2);
function g_app_info_equal(appinfo1, appinfo2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_equal
  type(c_ptr), value :: appinfo1
  type(c_ptr), value :: appinfo2
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_id (GAppInfo *appinfo);
function g_app_info_get_id(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_id
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_name (GAppInfo *appinfo);
function g_app_info_get_name(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_name
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_display_name (GAppInfo *appinfo);
function g_app_info_get_display_name(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_display_name
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_description (GAppInfo *appinfo);
function g_app_info_get_description(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_description
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_executable (GAppInfo *appinfo);
function g_app_info_get_executable(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_executable
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!const char *g_app_info_get_commandline (GAppInfo *appinfo);
function g_app_info_get_commandline(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_commandline
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_app_info_get_icon (GAppInfo *appinfo);
function g_app_info_get_icon(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_icon
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_launch (GAppInfo *appinfo, GList *files, GAppLaunchContext *context, GError **error);
function g_app_info_launch(appinfo, files, context, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_launch
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: files
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_supports_uris (GAppInfo *appinfo);
function g_app_info_supports_uris(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_supports_uris
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_supports_files (GAppInfo *appinfo);
function g_app_info_supports_files(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_supports_files
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_launch_uris (GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GError **error);
function g_app_info_launch_uris(appinfo, uris, context, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_launch_uris
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: uris
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!void g_app_info_launch_uris_async (GAppInfo *appinfo, GList *uris, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_app_info_launch_uris_async(appinfo, uris, context, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: uris
  type(c_ptr), value :: context
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_60
!gboolean g_app_info_launch_uris_finish (GAppInfo *appinfo, GAsyncResult *result, GError **error);
function g_app_info_launch_uris_finish(appinfo, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_launch_uris_finish
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_should_show (GAppInfo *appinfo);
function g_app_info_should_show(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_should_show
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_set_as_default_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_set_as_default_for_type(appinfo, content_type, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_default_for_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_set_as_default_for_extension (GAppInfo *appinfo, const char *extension, GError **error);
function g_app_info_set_as_default_for_extension(appinfo, extension, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_default_for_extension
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: extension
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_add_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_add_supports_type(appinfo, content_type, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_add_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_can_remove_supports_type (GAppInfo *appinfo);
function g_app_info_can_remove_supports_type(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_can_remove_supports_type
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_remove_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_remove_supports_type(appinfo, content_type, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_remove_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!const char **g_app_info_get_supported_types (GAppInfo *appinfo);
function g_app_info_get_supported_types(appinfo) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_supported_types
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_can_delete (GAppInfo *appinfo);
function g_app_info_can_delete(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_can_delete
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_delete (GAppInfo *appinfo);
function g_app_info_delete(appinfo) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_delete
  type(c_ptr), value :: appinfo
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_set_as_last_used_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_set_as_last_used_for_type(appinfo, content_type, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_last_used_for_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_app_info_get_all (void);
function g_app_info_get_all() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_get_all
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_app_info_get_all_for_type (const char *content_type);
function g_app_info_get_all_for_type(content_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_all_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_app_info_get_recommended_for_type (const gchar *content_type);
function g_app_info_get_recommended_for_type(content_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_recommended_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_app_info_get_fallback_for_type (const gchar *content_type);
function g_app_info_get_fallback_for_type(content_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_fallback_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_app_info_reset_type_associations (const char *content_type);
subroutine g_app_info_reset_type_associations(content_type) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GAppInfo *g_app_info_get_default_for_type (const char *content_type, gboolean must_support_uris);
function g_app_info_get_default_for_type(content_type, must_support_uris)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_app_info_get_default_for_type
  character(kind=c_char), dimension(*) :: content_type
  integer(c_int), value :: must_support_uris
end function

! GLIB_AVAILABLE_IN_ALL
!GAppInfo *g_app_info_get_default_for_uri_scheme (const char *uri_scheme);
function g_app_info_get_default_for_uri_scheme(uri_scheme) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_default_for_uri_scheme
  character(kind=c_char), dimension(*) :: uri_scheme
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_app_info_launch_default_for_uri (const char *uri, GAppLaunchContext *context, GError **error);
function g_app_info_launch_default_for_uri(uri, context, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_app_info_launch_default_for_uri
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_50
!void g_app_info_launch_default_for_uri_async (const char *uri, GAppLaunchContext *context, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_app_info_launch_default_for_uri_async(uri, context, cancellable,&
& callback, user_data) bind(c)
  import :: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: context
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_50
!gboolean g_app_info_launch_default_for_uri_finish (GAsyncResult *result, GError **error);
function g_app_info_launch_default_for_uri_finish(result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_app_info_launch_default_for_uri_finish
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_app_launch_context_get_type (void) G_GNUC_CONST;
function g_app_launch_context_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_app_launch_context_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GAppLaunchContext *g_app_launch_context_new (void);
function g_app_launch_context_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_launch_context_new
end function

! GLIB_AVAILABLE_IN_2_32
!void g_app_launch_context_setenv (GAppLaunchContext *context, const char *variable, const char *value);
subroutine g_app_launch_context_setenv(context, variable, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: variable
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_app_launch_context_unsetenv (GAppLaunchContext *context, const char *variable);
subroutine g_app_launch_context_unsetenv(context, variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: variable
end subroutine

! GLIB_AVAILABLE_IN_2_32
!char ** g_app_launch_context_get_environment (GAppLaunchContext *context);
function g_app_launch_context_get_environment(context) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_launch_context_get_environment
  type(c_ptr), value :: context
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_app_launch_context_get_display (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_display(context, info, files) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_launch_context_get_display
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_app_launch_context_get_startup_notify_id (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_startup_notify_id(context, info, files)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_launch_context_get_startup_notify_id
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! GLIB_AVAILABLE_IN_ALL
!void g_app_launch_context_launch_failed (GAppLaunchContext *context, const char * startup_notify_id);
subroutine g_app_launch_context_launch_failed(context, startup_notify_id)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: startup_notify_id
end subroutine

! GLIB_AVAILABLE_IN_2_40
!GType g_app_info_monitor_get_type (void);
function g_app_info_monitor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_app_info_monitor_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GAppInfoMonitor * g_app_info_monitor_get (void);
function g_app_info_monitor_get() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_app_info_monitor_get
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnotification.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_40
!GType g_notification_get_type (void) G_GNUC_CONST;
function g_notification_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_notification_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GNotification * g_notification_new (const gchar *title);
function g_notification_new(title) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_notification_new
  character(kind=c_char), dimension(*) :: title
end function

! GLIB_AVAILABLE_IN_2_40
!void g_notification_set_title (GNotification *notification, const gchar *title);
subroutine g_notification_set_title(notification, title) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: title
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_set_body (GNotification *notification, const gchar *body);
subroutine g_notification_set_body(notification, body) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: body
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_set_icon (GNotification *notification, GIcon *icon);
subroutine g_notification_set_icon(notification, icon) bind(c)
  import :: c_ptr
  type(c_ptr), value :: notification
  type(c_ptr), value :: icon
end subroutine

! GLIB_DEPRECATED_IN_2_42_FOR(g_notification_set_priority)
!void g_notification_set_urgent (GNotification *notification, gboolean urgent);
subroutine g_notification_set_urgent(notification, urgent) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: notification
  integer(c_int), value :: urgent
end subroutine

! GLIB_AVAILABLE_IN_2_42
!void g_notification_set_priority (GNotification *notification, GNotificationPriority priority);
subroutine g_notification_set_priority(notification, priority) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: notification
  integer(c_int), value :: priority
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_notification_set_category (GNotification *notification, const gchar *category);
subroutine g_notification_set_category(notification, category) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: category
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_add_button (GNotification *notification, const gchar *label, const gchar *detailed_action);
subroutine g_notification_add_button(notification, label, detailed_action)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_add_button_with_target_value (GNotification *notification, const gchar *label, const gchar *action, GVariant *target);
subroutine g_notification_add_button_with_target_value(notification, label,&
& action, target) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: action
  type(c_ptr), value :: target
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_set_default_action (GNotification *notification, const gchar *detailed_action);
subroutine g_notification_set_default_action(notification, detailed_action)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_notification_set_default_action_and_target_value (GNotification *notification, const gchar *action, GVariant *target);
subroutine g_notification_set_default_action_and_target_value(notification,&
& action, target) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: notification
  character(kind=c_char), dimension(*) :: action
  type(c_ptr), value :: target
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gapplication.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_application_get_type (void) G_GNUC_CONST;
function g_application_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_application_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_application_id_is_valid (const gchar *application_id);
function g_application_id_is_valid(application_id) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_application_id_is_valid
  character(kind=c_char), dimension(*) :: application_id
end function

! GLIB_AVAILABLE_IN_ALL
!GApplication * g_application_new (const gchar *application_id, GApplicationFlags flags);
function g_application_new(application_id, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_application_new
  character(kind=c_char), dimension(*) :: application_id
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_application_get_application_id (GApplication *application);
function g_application_get_application_id(application) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_get_application_id
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!void g_application_set_application_id (GApplication *application, const gchar *application_id);
subroutine g_application_set_application_id(application, application_id)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: application_id
end subroutine

! GLIB_AVAILABLE_IN_2_34
!GDBusConnection * g_application_get_dbus_connection (GApplication *application);
function g_application_get_dbus_connection(application) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_get_dbus_connection
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_2_34
!const gchar * g_application_get_dbus_object_path (GApplication *application);
function g_application_get_dbus_object_path(application) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_get_dbus_object_path
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_application_get_inactivity_timeout (GApplication *application);
function g_application_get_inactivity_timeout(application) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_get_inactivity_timeout
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!void g_application_set_inactivity_timeout (GApplication *application, guint inactivity_timeout);
subroutine g_application_set_inactivity_timeout(application,&
& inactivity_timeout) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: application
  integer(c_int), value :: inactivity_timeout
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GApplicationFlags g_application_get_flags (GApplication *application);
function g_application_get_flags(application) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_get_flags
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!void g_application_set_flags (GApplication *application, GApplicationFlags flags);
subroutine g_application_set_flags(application, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: application
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_42
!const gchar * g_application_get_resource_base_path (GApplication *application);
function g_application_get_resource_base_path(application) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_get_resource_base_path
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_2_42
!void g_application_set_resource_base_path (GApplication *application, const gchar *resource_path);
subroutine g_application_set_resource_base_path(application, resource_path)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: resource_path
end subroutine

! GLIB_DEPRECATED
!void g_application_set_action_group (GApplication *application, GActionGroup *action_group);
subroutine g_application_set_action_group(application, action_group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
  type(c_ptr), value :: action_group
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_application_add_main_option_entries (GApplication *application, const GOptionEntry *entries);
subroutine g_application_add_main_option_entries(application, entries) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
  type(c_ptr), value :: entries
end subroutine

! GLIB_AVAILABLE_IN_2_42
!void g_application_add_main_option (GApplication *application, const char *long_name, char short_name, GOptionFlags flags, GOptionArg arg, const char *description, const char *arg_description);
subroutine g_application_add_main_option(application, long_name, short_name,&
& flags, arg, description, arg_description) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: long_name
  character(kind=c_char), value :: short_name
  integer(c_int), value :: flags
  integer(c_int), value :: arg
  character(kind=c_char), dimension(*) :: description
  character(kind=c_char), dimension(*) :: arg_description
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_application_add_option_group (GApplication *application, GOptionGroup *group);
subroutine g_application_add_option_group(application, group) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
  type(c_ptr), value :: group
end subroutine

! GLIB_AVAILABLE_IN_2_56
!void g_application_set_option_context_parameter_string (GApplication *application, const gchar *parameter_string);
subroutine g_application_set_option_context_parameter_string(application,&
& parameter_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: parameter_string
end subroutine

! GLIB_AVAILABLE_IN_2_56
!void g_application_set_option_context_summary (GApplication *application, const gchar *summary);
subroutine g_application_set_option_context_summary(application, summary)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: summary
end subroutine

! GLIB_AVAILABLE_IN_2_56
!void g_application_set_option_context_description (GApplication *application, const gchar *description);
subroutine g_application_set_option_context_description(application,&
& description) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: description
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_application_get_is_registered (GApplication *application);
function g_application_get_is_registered(application) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_get_is_registered
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_application_get_is_remote (GApplication *application);
function g_application_get_is_remote(application) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_get_is_remote
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_application_register (GApplication *application, GCancellable *cancellable, GError **error);
function g_application_register(application, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_register
  type(c_ptr), value :: application
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_application_hold (GApplication *application);
subroutine g_application_hold(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_application_release (GApplication *application);
subroutine g_application_release(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_application_activate (GApplication *application);
subroutine g_application_activate(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_application_open (GApplication *application, GFile **files, gint n_files, const gchar *hint);
subroutine g_application_open(application, files, n_files, hint) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: application
  type(c_ptr), value :: files
  integer(c_int), value :: n_files
  character(kind=c_char), dimension(*) :: hint
end subroutine

! GLIB_AVAILABLE_IN_ALL
!int g_application_run (GApplication *application, int argc, char **argv);
function g_application_run(application, argc, argv) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_run
  type(c_ptr), value :: application
  integer(c_int), value :: argc
  type(c_ptr), dimension(*) :: argv
end function

! GLIB_AVAILABLE_IN_2_32
!void g_application_quit (GApplication *application);
subroutine g_application_quit(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GApplication * g_application_get_default (void);
function g_application_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_get_default
end function

! GLIB_AVAILABLE_IN_2_32
!void g_application_set_default (GApplication *application);
subroutine g_application_set_default(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_application_mark_busy (GApplication *application);
subroutine g_application_mark_busy(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_application_unmark_busy (GApplication *application);
subroutine g_application_unmark_busy(application) bind(c)
  import :: c_ptr
  type(c_ptr), value :: application
end subroutine

! GLIB_AVAILABLE_IN_2_44
!gboolean g_application_get_is_busy (GApplication *application);
function g_application_get_is_busy(application) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_get_is_busy
  type(c_ptr), value :: application
end function

! GLIB_AVAILABLE_IN_2_40
!void g_application_send_notification (GApplication *application, const gchar *id, GNotification *notification);
subroutine g_application_send_notification(application, id, notification)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: id
  type(c_ptr), value :: notification
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_application_withdraw_notification (GApplication *application, const gchar *id);
subroutine g_application_withdraw_notification(application, id) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: id
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_application_bind_busy_property (GApplication *application, gpointer object, const gchar *property);
subroutine g_application_bind_busy_property(application, object, property)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_application_unbind_busy_property (GApplication *application, gpointer object, const gchar *property);
subroutine g_application_unbind_busy_property(application, object, property)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: application
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/giostream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_io_stream_get_type (void) G_GNUC_CONST;
function g_io_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_io_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream * g_io_stream_get_input_stream (GIOStream *stream);
function g_io_stream_get_input_stream(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_stream_get_input_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream *g_io_stream_get_output_stream (GIOStream *stream);
function g_io_stream_get_output_stream(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_stream_get_output_stream
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_stream_splice_async (GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_io_stream_splice_async(stream1, stream2, flags, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream1
  type(c_ptr), value :: stream2
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_splice_finish (GAsyncResult *result, GError **error);
function g_io_stream_splice_finish(result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_splice_finish
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_close (GIOStream *stream, GCancellable *cancellable, GError **error);
function g_io_stream_close(stream, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_stream_close_async (GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_io_stream_close_async(stream, io_priority, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_close_finish (GIOStream *stream, GAsyncResult *result, GError **error);
function g_io_stream_close_finish(stream, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_is_closed (GIOStream *stream);
function g_io_stream_is_closed(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_is_closed
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_has_pending (GIOStream *stream);
function g_io_stream_has_pending(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_has_pending
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_io_stream_set_pending (GIOStream *stream, GError **error);
function g_io_stream_set_pending(stream, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_stream_clear_pending (GIOStream *stream);
subroutine g_io_stream_clear_pending(stream) bind(c)
  import :: c_ptr
  type(c_ptr), value :: stream
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_connection_get_type (void) G_GNUC_CONST;
function g_dbus_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_connection_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bus_get (GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_bus_get(bus_type, cancellable, callback, user_data) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_bus_get_finish (GAsyncResult *res, GError **error);
function g_bus_get_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bus_get_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_bus_get_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_bus_get_sync(bus_type, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_bus_get_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_new (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new(stream, guid, flags, observer, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_connection_new_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_connection_new_sync (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_sync
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_new_for_address (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new_for_address(address, flags, observer,&
& cancellable, callback, user_data) bind(c)
  import :: c_char, c_int, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_connection_new_for_address_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_for_address_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_new_for_address_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_connection_new_for_address_sync (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_for_address_sync(address, flags, observer,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_for_address_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_start_message_processing (GDBusConnection *connection);
subroutine g_dbus_connection_start_message_processing(connection) bind(c)
  import :: c_ptr
  type(c_ptr), value :: connection
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_is_closed (GDBusConnection *connection);
function g_dbus_connection_is_closed(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_is_closed
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_dbus_connection_get_stream (GDBusConnection *connection);
function g_dbus_connection_get_stream(connection) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_get_stream
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_connection_get_guid (GDBusConnection *connection);
function g_dbus_connection_get_guid(connection) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_get_guid
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_connection_get_unique_name (GDBusConnection *connection);
function g_dbus_connection_get_unique_name(connection) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_get_unique_name
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!GCredentials *g_dbus_connection_get_peer_credentials (GDBusConnection *connection);
function g_dbus_connection_get_peer_credentials(connection) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_get_peer_credentials
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_2_34
!guint32 g_dbus_connection_get_last_serial (GDBusConnection *connection);
function g_dbus_connection_get_last_serial(connection) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_connection_get_last_serial
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_get_exit_on_close (GDBusConnection *connection);
function g_dbus_connection_get_exit_on_close(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_exit_on_close
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_set_exit_on_close (GDBusConnection *connection, gboolean exit_on_close);
subroutine g_dbus_connection_set_exit_on_close(connection, exit_on_close)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: exit_on_close
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusCapabilityFlags g_dbus_connection_get_capabilities (GDBusConnection *connection);
function g_dbus_connection_get_capabilities(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_capabilities
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_2_60
!GDBusConnectionFlags g_dbus_connection_get_flags (GDBusConnection *connection);
function g_dbus_connection_get_flags(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_flags
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_close (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_close(connection, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_close_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_close_finish(connection, res, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_close_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_close_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_close_sync(connection, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_close_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_flush (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_flush(connection, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_flush_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_flush_finish(connection, res, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_flush_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_flush_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_flush_sync(connection, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_flush_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_send_message (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
function g_dbus_connection_send_message(connection, message, flags, out_serial,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_send_message
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_send_message_with_reply (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_send_message_with_reply(connection, message,&
& flags, timeout_msec, out_serial, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_connection_send_message_with_reply_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_send_message_with_reply_finish(connection, res,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_connection_send_message_with_reply_sync (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
function g_dbus_connection_send_message_with_reply_sync(connection, message,&
& flags, timeout_msec, out_serial, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_emit_signal (GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
function g_dbus_connection_emit_signal(connection, destination_bus_name,&
& object_path, interface_name, signal_name, parameters, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_connection_emit_signal
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: destination_bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: signal_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_call (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_call(connection, bus_name, object_path,&
& interface_name, method_name, parameters, reply_type, flags, timeout_msec,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_connection_call_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_call_finish(connection, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_call_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_connection_call_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_connection_call_sync(connection, bus_name, object_path,&
& interface_name, method_name, parameters, reply_type, flags, timeout_msec,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_call_sync
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!void g_dbus_connection_call_with_unix_fd_list (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_call_with_unix_fd_list(connection, bus_name,&
& object_path, interface_name, method_name, parameters, reply_type, flags,&
& timeout_msec, fd_list, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: fd_list
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_30
!GVariant *g_dbus_connection_call_with_unix_fd_list_finish (GDBusConnection *connection, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
function g_dbus_connection_call_with_unix_fd_list_finish(connection,&
& out_fd_list, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_connection_call_with_unix_fd_list_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: out_fd_list
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!GVariant *g_dbus_connection_call_with_unix_fd_list_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
function g_dbus_connection_call_with_unix_fd_list_sync(connection, bus_name,&
& object_path, interface_name, method_name, parameters, reply_type, flags,&
& timeout_msec, fd_list, out_fd_list, cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_call_with_unix_fd_list_sync
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: fd_list
  type(c_ptr), value :: out_fd_list
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_dbus_connection_register_object (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_object(connection, object_path,&
& interface_info, vtable, user_data, user_data_free_func, error) bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_object
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: interface_info
  type(c_ptr), value :: vtable
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_46
!guint g_dbus_connection_register_object_with_closures (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, GClosure *method_call_closure, GClosure *get_property_closure, GClosure *set_property_closure, GError **error);
function g_dbus_connection_register_object_with_closures(connection,&
& object_path, interface_info, method_call_closure, get_property_closure,&
& set_property_closure, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_connection_register_object_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: interface_info
  type(c_ptr), value :: method_call_closure
  type(c_ptr), value :: get_property_closure
  type(c_ptr), value :: set_property_closure
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_unregister_object (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_object(connection, registration_id)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_unregister_object
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_dbus_connection_register_subtree (GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_subtree(connection, object_path, vtable,&
& flags, user_data, user_data_free_func, error) bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_subtree
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: vtable
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_connection_unregister_subtree (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_subtree(connection, registration_id)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_unregister_subtree
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_dbus_connection_signal_subscribe (GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_signal_subscribe(connection, sender, interface_name,&
& member, object_path, arg0, flags, callback, user_data, user_data_free_func)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_signal_subscribe
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: sender
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: member
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: arg0
  integer(c_int), value :: flags
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_signal_unsubscribe (GDBusConnection *connection, guint subscription_id);
subroutine g_dbus_connection_signal_unsubscribe(connection, subscription_id)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: subscription_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_dbus_connection_add_filter (GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_add_filter(connection, filter_function, user_data,&
& user_data_free_func) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_dbus_connection_add_filter
  type(c_ptr), value :: connection
  type(c_funptr), value :: filter_function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_connection_remove_filter (GDBusConnection *connection, guint filter_id);
subroutine g_dbus_connection_remove_filter(connection, filter_id) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: filter_id
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsserverconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_server_connection_get_type (void) G_GNUC_CONST;
function g_tls_server_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_server_connection_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream * g_tls_server_connection_new (GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error);
function g_tls_server_connection_new(base_io_stream, certificate, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_server_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: certificate
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpollableutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GSource *g_pollable_source_new (GObject *pollable_stream);
function g_pollable_source_new(pollable_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_pollable_source_new
  type(c_ptr), value :: pollable_stream
end function

! GLIB_AVAILABLE_IN_2_34
!GSource *g_pollable_source_new_full (gpointer pollable_stream, GSource *child_source, GCancellable *cancellable);
function g_pollable_source_new_full(pollable_stream, child_source, cancellable)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_pollable_source_new_full
  type(c_ptr), value :: pollable_stream
  type(c_ptr), value :: child_source
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_2_34
!gssize g_pollable_stream_read (GInputStream *stream, void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
function g_pollable_stream_read(stream, buffer, count, blocking, cancellable,&
& error) bind(c)
  import :: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_pollable_stream_read
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!gssize g_pollable_stream_write (GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, GCancellable *cancellable, GError **error);
function g_pollable_stream_write(stream, buffer, count, blocking, cancellable,&
& error) bind(c)
  import :: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_pollable_stream_write
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_pollable_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gboolean blocking, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_pollable_stream_write_all(stream, buffer, count, blocking,&
& bytes_written, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_pollable_stream_write_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: blocking
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmenumodel.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_menu_model_get_type (void) G_GNUC_CONST;
function g_menu_model_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_menu_model_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_menu_model_is_mutable (GMenuModel *model);
function g_menu_model_is_mutable(model) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_model_is_mutable
  type(c_ptr), value :: model
end function

! GLIB_AVAILABLE_IN_2_32
!gint g_menu_model_get_n_items (GMenuModel *model);
function g_menu_model_get_n_items(model) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_model_get_n_items
  type(c_ptr), value :: model
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuAttributeIter * g_menu_model_iterate_item_attributes (GMenuModel *model, gint item_index);
function g_menu_model_iterate_item_attributes(model, item_index) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_menu_model_iterate_item_attributes
  type(c_ptr), value :: model
  integer(c_int), value :: item_index
end function

! GLIB_AVAILABLE_IN_2_32
!GVariant * g_menu_model_get_item_attribute_value (GMenuModel *model, gint item_index, const gchar *attribute, const GVariantType *expected_type);
function g_menu_model_get_item_attribute_value(model, item_index, attribute,&
& expected_type) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_menu_model_get_item_attribute_value
  type(c_ptr), value :: model
  integer(c_int), value :: item_index
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: expected_type
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuLinkIter * g_menu_model_iterate_item_links (GMenuModel *model, gint item_index);
function g_menu_model_iterate_item_links(model, item_index) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_menu_model_iterate_item_links
  type(c_ptr), value :: model
  integer(c_int), value :: item_index
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuModel * g_menu_model_get_item_link (GMenuModel *model, gint item_index, const gchar *link);
function g_menu_model_get_item_link(model, item_index, link) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_menu_model_get_item_link
  type(c_ptr), value :: model
  integer(c_int), value :: item_index
  character(kind=c_char), dimension(*) :: link
end function

! GLIB_AVAILABLE_IN_2_32
!void g_menu_model_items_changed (GMenuModel *model, gint position, gint removed, gint added);
subroutine g_menu_model_items_changed(model, position, removed, added) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: model
  integer(c_int), value :: position
  integer(c_int), value :: removed
  integer(c_int), value :: added
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GType g_menu_attribute_iter_get_type (void) G_GNUC_CONST;
function g_menu_attribute_iter_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_menu_attribute_iter_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_menu_attribute_iter_get_next (GMenuAttributeIter *iter, const gchar **out_name, GVariant **value);
function g_menu_attribute_iter_get_next(iter, out_name, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_attribute_iter_get_next
  type(c_ptr), value :: iter
  type(c_ptr), dimension(*) :: out_name
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_menu_attribute_iter_next (GMenuAttributeIter *iter);
function g_menu_attribute_iter_next(iter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_attribute_iter_next
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_2_32
!const gchar * g_menu_attribute_iter_get_name (GMenuAttributeIter *iter);
function g_menu_attribute_iter_get_name(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_menu_attribute_iter_get_name
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_2_32
!GVariant * g_menu_attribute_iter_get_value (GMenuAttributeIter *iter);
function g_menu_attribute_iter_get_value(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_menu_attribute_iter_get_value
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_2_32
!GType g_menu_link_iter_get_type (void) G_GNUC_CONST;
function g_menu_link_iter_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_menu_link_iter_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_menu_link_iter_get_next (GMenuLinkIter *iter, const gchar **out_link, GMenuModel **value);
function g_menu_link_iter_get_next(iter, out_link, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_link_iter_get_next
  type(c_ptr), value :: iter
  type(c_ptr), dimension(*) :: out_link
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_menu_link_iter_next (GMenuLinkIter *iter);
function g_menu_link_iter_next(iter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_menu_link_iter_next
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_2_32
!const gchar * g_menu_link_iter_get_name (GMenuLinkIter *iter);
function g_menu_link_iter_get_name(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_menu_link_iter_get_name
  type(c_ptr), value :: iter
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuModel * g_menu_link_iter_get_value (GMenuLinkIter *iter);
function g_menu_link_iter_get_value(iter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_menu_link_iter_get_value
  type(c_ptr), value :: iter
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocket.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_get_type (void) G_GNUC_CONST;
function g_socket_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocket * g_socket_new (GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
function g_socket_new(family, type, protocol, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_socket_new
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocket * g_socket_new_from_fd (gint fd, GError **error);
function g_socket_new_from_fd(fd, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_socket_new_from_fd
  integer(c_int), value :: fd
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!int g_socket_get_fd (GSocket *socket);
function g_socket_get_fd(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_fd
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketFamily g_socket_get_family (GSocket *socket);
function g_socket_get_family(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_family
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketType g_socket_get_socket_type (GSocket *socket);
function g_socket_get_socket_type(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_socket_type
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketProtocol g_socket_get_protocol (GSocket *socket);
function g_socket_get_protocol(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_protocol
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress * g_socket_get_local_address (GSocket *socket, GError **error);
function g_socket_get_local_address(socket, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_get_local_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress * g_socket_get_remote_address (GSocket *socket, GError **error);
function g_socket_get_remote_address(socket, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_get_remote_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_set_blocking (GSocket *socket, gboolean blocking);
subroutine g_socket_set_blocking(socket, blocking) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: blocking
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_get_blocking (GSocket *socket);
function g_socket_get_blocking(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_blocking
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_set_keepalive (GSocket *socket, gboolean keepalive);
subroutine g_socket_set_keepalive(socket, keepalive) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: keepalive
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_get_keepalive (GSocket *socket);
function g_socket_get_keepalive(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_keepalive
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_socket_get_listen_backlog (GSocket *socket);
function g_socket_get_listen_backlog(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_listen_backlog
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_set_listen_backlog (GSocket *socket, gint backlog);
subroutine g_socket_set_listen_backlog(socket, backlog) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: backlog
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_socket_get_timeout (GSocket *socket);
function g_socket_get_timeout(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_timeout
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_set_timeout (GSocket *socket, guint timeout);
subroutine g_socket_set_timeout(socket, timeout) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: timeout
end subroutine

! GLIB_AVAILABLE_IN_2_32
!guint g_socket_get_ttl (GSocket *socket);
function g_socket_get_ttl(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_ttl
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_2_32
!void g_socket_set_ttl (GSocket *socket, guint ttl);
subroutine g_socket_set_ttl(socket, ttl) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: ttl
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_get_broadcast (GSocket *socket);
function g_socket_get_broadcast(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_broadcast
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_2_32
!void g_socket_set_broadcast (GSocket *socket, gboolean broadcast);
subroutine g_socket_set_broadcast(socket, broadcast) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: broadcast
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_get_multicast_loopback (GSocket *socket);
function g_socket_get_multicast_loopback(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_multicast_loopback
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_2_32
!void g_socket_set_multicast_loopback (GSocket *socket, gboolean loopback);
subroutine g_socket_set_multicast_loopback(socket, loopback) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: loopback
end subroutine

! GLIB_AVAILABLE_IN_2_32
!guint g_socket_get_multicast_ttl (GSocket *socket);
function g_socket_get_multicast_ttl(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_multicast_ttl
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_2_32
!void g_socket_set_multicast_ttl (GSocket *socket, guint ttl);
subroutine g_socket_set_multicast_ttl(socket, ttl) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: ttl
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_is_connected (GSocket *socket);
function g_socket_is_connected(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_is_connected
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_bind (GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
function g_socket_bind(socket, address, allow_reuse, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_bind
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  integer(c_int), value :: allow_reuse
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_join_multicast_group (GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
function g_socket_join_multicast_group(socket, group, source_specific, iface,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_socket_join_multicast_group
  type(c_ptr), value :: socket
  type(c_ptr), value :: group
  integer(c_int), value :: source_specific
  character(kind=c_char), dimension(*) :: iface
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_leave_multicast_group (GSocket *socket, GInetAddress *group, gboolean source_specific, const gchar *iface, GError **error);
function g_socket_leave_multicast_group(socket, group, source_specific, iface,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_socket_leave_multicast_group
  type(c_ptr), value :: socket
  type(c_ptr), value :: group
  integer(c_int), value :: source_specific
  character(kind=c_char), dimension(*) :: iface
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_56
!gboolean g_socket_join_multicast_group_ssm (GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
function g_socket_join_multicast_group_ssm(socket, group, source_specific,&
& iface, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_socket_join_multicast_group_ssm
  type(c_ptr), value :: socket
  type(c_ptr), value :: group
  type(c_ptr), value :: source_specific
  character(kind=c_char), dimension(*) :: iface
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_56
!gboolean g_socket_leave_multicast_group_ssm (GSocket *socket, GInetAddress *group, GInetAddress *source_specific, const gchar *iface, GError **error);
function g_socket_leave_multicast_group_ssm(socket, group, source_specific,&
& iface, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_socket_leave_multicast_group_ssm
  type(c_ptr), value :: socket
  type(c_ptr), value :: group
  type(c_ptr), value :: source_specific
  character(kind=c_char), dimension(*) :: iface
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_connect (GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
function g_socket_connect(socket, address, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_connect
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_check_connect_result (GSocket *socket, GError **error);
function g_socket_check_connect_result(socket, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_check_connect_result
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_get_available_bytes (GSocket *socket);
function g_socket_get_available_bytes(socket) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_get_available_bytes
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GIOCondition g_socket_condition_check (GSocket *socket, GIOCondition condition);
function g_socket_condition_check(socket, condition) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_condition_check
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_condition_wait (GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
function g_socket_condition_wait(socket, condition, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_condition_wait
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_socket_condition_timed_wait (GSocket *socket, GIOCondition condition, gint64 timeout_us, GCancellable *cancellable, GError **error);
function g_socket_condition_timed_wait(socket, condition, timeout_us,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_socket_condition_timed_wait
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  integer(c_int64_t), value :: timeout_us
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocket * g_socket_accept (GSocket *socket, GCancellable *cancellable, GError **error);
function g_socket_accept(socket, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_accept
  type(c_ptr), value :: socket
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_listen (GSocket *socket, GError **error);
function g_socket_listen(socket, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_listen
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_receive (GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive(socket, buffer, size, cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_receive_from (GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive_from(socket, address, buffer, size, cancellable,&
& error) bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive_from
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_send (GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send(socket, buffer, size, cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_send_to (GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send_to(socket, address, buffer, size, cancellable, error)&
& bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send_to
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_receive_message (GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
function g_socket_receive_message(socket, address, vectors, num_vectors,&
& messages, num_messages, flags, cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_receive_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  type(c_ptr), value :: num_messages
  type(c_ptr), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_send_message (GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
function g_socket_send_message(socket, address, vectors, num_vectors, messages,&
& num_messages, flags, cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_send_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!gint g_socket_receive_messages (GSocket *socket, GInputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
function g_socket_receive_messages(socket, messages, num_messages, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_receive_messages
  type(c_ptr), value :: socket
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_44
!gint g_socket_send_messages (GSocket *socket, GOutputMessage *messages, guint num_messages, gint flags, GCancellable *cancellable, GError **error);
function g_socket_send_messages(socket, messages, num_messages, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_send_messages
  type(c_ptr), value :: socket
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_close (GSocket *socket, GError **error);
function g_socket_close(socket, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_close
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_shutdown (GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
function g_socket_shutdown(socket, shutdown_read, shutdown_write, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_shutdown
  type(c_ptr), value :: socket
  integer(c_int), value :: shutdown_read
  integer(c_int), value :: shutdown_write
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_is_closed (GSocket *socket);
function g_socket_is_closed(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_is_closed
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GSource * g_socket_create_source (GSocket *socket, GIOCondition condition, GCancellable *cancellable);
function g_socket_create_source(socket, condition, cancellable) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_socket_create_source
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_speaks_ipv4 (GSocket *socket);
function g_socket_speaks_ipv4(socket) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_speaks_ipv4
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GCredentials *g_socket_get_credentials (GSocket *socket, GError **error);
function g_socket_get_credentials(socket, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_get_credentials
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_receive_with_blocking (GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_receive_with_blocking(socket, buffer, size, blocking,&
& cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_socket_receive_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_send_with_blocking (GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_send_with_blocking(socket, buffer, size, blocking,&
& cancellable, error) bind(c)
  import :: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_socket_send_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!GPollableReturn g_socket_send_message_with_timeout (GSocket *socket, GSocketAddress *address, const GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, gint64 timeout_us, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_socket_send_message_with_timeout(socket, address, vectors,&
& num_vectors, messages, num_messages, flags, timeout_us, bytes_written,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_socket_send_message_with_timeout
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  integer(c_int64_t), value :: timeout_us
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_socket_get_option (GSocket *socket, gint level, gint optname, gint *value, GError **error);
function g_socket_get_option(socket, level, optname, value, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_get_option
  type(c_ptr), value :: socket
  integer(c_int), value :: level
  integer(c_int), value :: optname
  type(c_ptr), value :: value
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_socket_set_option (GSocket *socket, gint level, gint optname, gint value, GError **error);
function g_socket_set_option(socket, level, optname, value, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_set_option
  type(c_ptr), value :: socket
  integer(c_int), value :: level
  integer(c_int), value :: optname
  integer(c_int), value :: value
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gbytesicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_38
!GType g_bytes_icon_get_type (void) G_GNUC_CONST;
function g_bytes_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_bytes_icon_get_type
end function

! GLIB_AVAILABLE_IN_2_38
!GIcon * g_bytes_icon_new (GBytes *bytes);
function g_bytes_icon_new(bytes) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_icon_new
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_2_38
!GBytes * g_bytes_icon_get_bytes (GBytesIcon *icon);
function g_bytes_icon_get_bytes(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_bytes_icon_get_bytes
  type(c_ptr), value :: icon
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileenumerator.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_enumerator_get_type (void) G_GNUC_CONST;
function g_file_enumerator_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_enumerator_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_enumerator_next_file (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_next_file(enumerator, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_enumerator_next_file
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_enumerator_close (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_close(enumerator, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_close
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_enumerator_next_files_async (GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_next_files_async(enumerator, num_files,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: num_files
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList * g_file_enumerator_next_files_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_next_files_finish(enumerator, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_enumerator_next_files_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_enumerator_close_async (GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_close_async(enumerator, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_enumerator_close_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_close_finish(enumerator, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_close_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_enumerator_is_closed (GFileEnumerator *enumerator);
function g_file_enumerator_is_closed(enumerator) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_is_closed
  type(c_ptr), value :: enumerator
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_enumerator_has_pending (GFileEnumerator *enumerator);
function g_file_enumerator_has_pending(enumerator) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_has_pending
  type(c_ptr), value :: enumerator
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_enumerator_set_pending (GFileEnumerator *enumerator, gboolean pending);
subroutine g_file_enumerator_set_pending(enumerator, pending) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: enumerator
  integer(c_int), value :: pending
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_enumerator_get_container (GFileEnumerator *enumerator);
function g_file_enumerator_get_container(enumerator) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_enumerator_get_container
  type(c_ptr), value :: enumerator
end function

! GLIB_AVAILABLE_IN_2_36
!GFile * g_file_enumerator_get_child (GFileEnumerator *enumerator, GFileInfo *info);
function g_file_enumerator_get_child(enumerator, info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_enumerator_get_child
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_2_44
!gboolean g_file_enumerator_iterate (GFileEnumerator *direnum, GFileInfo **out_info, GFile **out_child, GCancellable *cancellable, GError **error);
function g_file_enumerator_iterate(direnum, out_info, out_child, cancellable,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_iterate
  type(c_ptr), value :: direnum
  type(c_ptr), value :: out_info
  type(c_ptr), value :: out_child
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/ginitable.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_initable_get_type (void) G_GNUC_CONST;
function g_initable_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_initable_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_initable_init (GInitable *initable, GCancellable *cancellable, GError **error);
function g_initable_init(initable, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_initable_init
  type(c_ptr), value :: initable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties and g_initable_init)
!gpointer g_initable_newv (GType object_type, guint n_parameters, GParameter *parameters, GCancellable *cancellable, GError **error);
function g_initable_newv(object_type, n_parameters, parameters, cancellable,&
& error) bind(c)
  import :: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_initable_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GObject* g_initable_new_valist (GType object_type, const gchar *first_property_name, va_list var_args, GCancellable *cancellable, GError **error);
function g_initable_new_valist(object_type, first_property_name, var_args,&
& cancellable, error) bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_initable_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnetworkmonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_network_monitor_get_type (void) G_GNUC_CONST;
function g_network_monitor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_network_monitor_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GNetworkMonitor *g_network_monitor_get_default (void);
function g_network_monitor_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_monitor_get_default
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_network_monitor_get_network_available (GNetworkMonitor *monitor);
function g_network_monitor_get_network_available(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_network_monitor_get_network_available
  type(c_ptr), value :: monitor
end function

! GLIB_AVAILABLE_IN_2_46
!gboolean g_network_monitor_get_network_metered (GNetworkMonitor *monitor);
function g_network_monitor_get_network_metered(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_network_monitor_get_network_metered
  type(c_ptr), value :: monitor
end function

! GLIB_AVAILABLE_IN_2_44
!GNetworkConnectivity g_network_monitor_get_connectivity (GNetworkMonitor *monitor);
function g_network_monitor_get_connectivity(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_network_monitor_get_connectivity
  type(c_ptr), value :: monitor
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_network_monitor_can_reach (GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
function g_network_monitor_can_reach(monitor, connectable, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_network_monitor_can_reach
  type(c_ptr), value :: monitor
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_network_monitor_can_reach_async (GNetworkMonitor *monitor, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_network_monitor_can_reach_async(monitor, connectable, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: monitor
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_network_monitor_can_reach_finish (GNetworkMonitor *monitor, GAsyncResult *result, GError **error);
function g_network_monitor_can_reach_finish(monitor, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_network_monitor_can_reach_finish
  type(c_ptr), value :: monitor
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gconverter.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_converter_get_type (void) G_GNUC_CONST;
function g_converter_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_converter_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GConverterResult g_converter_convert (GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
function g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size,&
& flags, bytes_read, bytes_written, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_converter_convert
  type(c_ptr), value :: converter
  type(c_ptr), value :: inbuf
  integer(c_size_t), value :: inbuf_size
  type(c_ptr), value :: outbuf
  integer(c_size_t), value :: outbuf_size
  integer(c_int), value :: flags
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_converter_reset (GConverter *converter);
subroutine g_converter_reset(converter) bind(c)
  import :: c_ptr
  type(c_ptr), value :: converter
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobjectmanager.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_manager_get_type (void) G_GNUC_CONST;
function g_dbus_object_manager_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_manager_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_object_manager_get_object_path (GDBusObjectManager *manager);
function g_dbus_object_manager_get_object_path(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_get_object_path
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_dbus_object_manager_get_objects (GDBusObjectManager *manager);
function g_dbus_object_manager_get_objects(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_get_objects
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObject *g_dbus_object_manager_get_object (GDBusObjectManager *manager, const gchar *object_path);
function g_dbus_object_manager_get_object(manager, object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_manager_get_object
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: object_path
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterface *g_dbus_object_manager_get_interface (GDBusObjectManager *manager, const gchar *object_path, const gchar *interface_name);
function g_dbus_object_manager_get_interface(manager, object_path,&
& interface_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_manager_get_interface
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmenu.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_menu_get_type (void) G_GNUC_CONST;
function g_menu_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_menu_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GMenu * g_menu_new (void);
function g_menu_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_menu_new
end function

! GLIB_AVAILABLE_IN_2_32
!void g_menu_freeze (GMenu *menu);
subroutine g_menu_freeze(menu) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_insert_item (GMenu *menu, gint position, GMenuItem *item);
subroutine g_menu_insert_item(menu, position, item) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: menu
  integer(c_int), value :: position
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_prepend_item (GMenu *menu, GMenuItem *item);
subroutine g_menu_prepend_item(menu, item) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_append_item (GMenu *menu, GMenuItem *item);
subroutine g_menu_append_item(menu, item) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: item
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_remove (GMenu *menu, gint position);
subroutine g_menu_remove(menu, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: menu
  integer(c_int), value :: position
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_menu_remove_all (GMenu *menu);
subroutine g_menu_remove_all(menu) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_insert (GMenu *menu, gint position, const gchar *label, const gchar *detailed_action);
subroutine g_menu_insert(menu, position, label, detailed_action) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: menu
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_prepend (GMenu *menu, const gchar *label, const gchar *detailed_action);
subroutine g_menu_prepend(menu, label, detailed_action) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_append (GMenu *menu, const gchar *label, const gchar *detailed_action);
subroutine g_menu_append(menu, label, detailed_action) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_insert_section (GMenu *menu, gint position, const gchar *label, GMenuModel *section);
subroutine g_menu_insert_section(menu, position, label, section) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: menu
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: section
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_prepend_section (GMenu *menu, const gchar *label, GMenuModel *section);
subroutine g_menu_prepend_section(menu, label, section) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: section
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_append_section (GMenu *menu, const gchar *label, GMenuModel *section);
subroutine g_menu_append_section(menu, label, section) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: section
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_insert_submenu (GMenu *menu, gint position, const gchar *label, GMenuModel *submenu);
subroutine g_menu_insert_submenu(menu, position, label, submenu) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: menu
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: submenu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_prepend_submenu (GMenu *menu, const gchar *label, GMenuModel *submenu);
subroutine g_menu_prepend_submenu(menu, label, submenu) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: submenu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_append_submenu (GMenu *menu, const gchar *label, GMenuModel *submenu);
subroutine g_menu_append_submenu(menu, label, submenu) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: submenu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GType g_menu_item_get_type (void) G_GNUC_CONST;
function g_menu_item_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_menu_item_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuItem * g_menu_item_new (const gchar *label, const gchar *detailed_action);
function g_menu_item_new(label, detailed_action) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_menu_item_new
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: detailed_action
end function

! GLIB_AVAILABLE_IN_2_34
!GMenuItem * g_menu_item_new_from_model (GMenuModel *model, gint item_index);
function g_menu_item_new_from_model(model, item_index) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_menu_item_new_from_model
  type(c_ptr), value :: model
  integer(c_int), value :: item_index
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuItem * g_menu_item_new_submenu (const gchar *label, GMenuModel *submenu);
function g_menu_item_new_submenu(label, submenu) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_menu_item_new_submenu
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: submenu
end function

! GLIB_AVAILABLE_IN_2_32
!GMenuItem * g_menu_item_new_section (const gchar *label, GMenuModel *section);
function g_menu_item_new_section(label, section) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_menu_item_new_section
  character(kind=c_char), dimension(*) :: label
  type(c_ptr), value :: section
end function

! GLIB_AVAILABLE_IN_2_34
!GVariant * g_menu_item_get_attribute_value (GMenuItem *menu_item, const gchar *attribute, const GVariantType *expected_type);
function g_menu_item_get_attribute_value(menu_item, attribute, expected_type)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_menu_item_get_attribute_value
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: expected_type
end function

! GLIB_AVAILABLE_IN_2_34
!GMenuModel *g_menu_item_get_link (GMenuItem *menu_item, const gchar *link);
function g_menu_item_get_link(menu_item, link) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_menu_item_get_link
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: link
end function

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_attribute_value (GMenuItem *menu_item, const gchar *attribute, GVariant *value);
subroutine g_menu_item_set_attribute_value(menu_item, attribute, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_link (GMenuItem *menu_item, const gchar *link, GMenuModel *model);
subroutine g_menu_item_set_link(menu_item, link, model) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: link
  type(c_ptr), value :: model
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_label (GMenuItem *menu_item, const gchar *label);
subroutine g_menu_item_set_label(menu_item, label) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: label
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_submenu (GMenuItem *menu_item, GMenuModel *submenu);
subroutine g_menu_item_set_submenu(menu_item, submenu) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu_item
  type(c_ptr), value :: submenu
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_section (GMenuItem *menu_item, GMenuModel *section);
subroutine g_menu_item_set_section(menu_item, section) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu_item
  type(c_ptr), value :: section
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_action_and_target_value (GMenuItem *menu_item, const gchar *action, GVariant *target_value);
subroutine g_menu_item_set_action_and_target_value(menu_item, action,&
& target_value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: action
  type(c_ptr), value :: target_value
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_menu_item_set_detailed_action (GMenuItem *menu_item, const gchar *detailed_action);
subroutine g_menu_item_set_detailed_action(menu_item, detailed_action) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: detailed_action
end subroutine

! GLIB_AVAILABLE_IN_2_38
!void g_menu_item_set_icon (GMenuItem *menu_item, GIcon *icon);
subroutine g_menu_item_set_icon(menu_item, icon) bind(c)
  import :: c_ptr
  type(c_ptr), value :: menu_item
  type(c_ptr), value :: icon
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsubprocesslauncher.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_40
!GType g_subprocess_launcher_get_type (void) G_GNUC_CONST;
function g_subprocess_launcher_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_subprocess_launcher_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GSubprocessLauncher * g_subprocess_launcher_new (GSubprocessFlags flags);
function g_subprocess_launcher_new(flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_subprocess_launcher_new
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_40
!GSubprocess * g_subprocess_launcher_spawnv (GSubprocessLauncher *self, const gchar * const *argv, GError **error);
function g_subprocess_launcher_spawnv(self, argv, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_subprocess_launcher_spawnv
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: argv
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_environ (GSubprocessLauncher *self, gchar **env);
subroutine g_subprocess_launcher_set_environ(self, env) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
  type(c_ptr), dimension(*) :: env
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_setenv (GSubprocessLauncher *self, const gchar *variable, const gchar *value, gboolean overwrite);
subroutine g_subprocess_launcher_setenv(self, variable, value, overwrite)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: variable
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: overwrite
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_unsetenv (GSubprocessLauncher *self, const gchar *variable);
subroutine g_subprocess_launcher_unsetenv(self, variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: variable
end subroutine

! GLIB_AVAILABLE_IN_2_40
!const gchar * g_subprocess_launcher_getenv (GSubprocessLauncher *self, const gchar *variable);
function g_subprocess_launcher_getenv(self, variable) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_subprocess_launcher_getenv
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: variable
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_cwd (GSubprocessLauncher *self, const gchar *cwd);
subroutine g_subprocess_launcher_set_cwd(self, cwd) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: cwd
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_flags (GSubprocessLauncher *self, GSubprocessFlags flags);
subroutine g_subprocess_launcher_set_flags(self, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_stdin_file_path (GSubprocessLauncher *self, const gchar *path);
subroutine g_subprocess_launcher_set_stdin_file_path(self, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_take_stdin_fd (GSubprocessLauncher *self, gint fd);
subroutine g_subprocess_launcher_take_stdin_fd(self, fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_stdout_file_path (GSubprocessLauncher *self, const gchar *path);
subroutine g_subprocess_launcher_set_stdout_file_path(self, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_take_stdout_fd (GSubprocessLauncher *self, gint fd);
subroutine g_subprocess_launcher_take_stdout_fd(self, fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_stderr_file_path (GSubprocessLauncher *self, const gchar *path);
subroutine g_subprocess_launcher_set_stderr_file_path(self, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_take_stderr_fd (GSubprocessLauncher *self, gint fd);
subroutine g_subprocess_launcher_take_stderr_fd(self, fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: fd
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_take_fd (GSubprocessLauncher *self, gint source_fd, gint target_fd);
subroutine g_subprocess_launcher_take_fd(self, source_fd, target_fd) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: source_fd
  integer(c_int), value :: target_fd
end subroutine

! GLIB_AVAILABLE_IN_2_68
!void g_subprocess_launcher_close (GSubprocessLauncher *self);
subroutine g_subprocess_launcher_close(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_launcher_set_child_setup (GSubprocessLauncher *self, GSpawnChildSetupFunc child_setup, gpointer user_data, GDestroyNotify destroy_notify);
subroutine g_subprocess_launcher_set_child_setup(self, child_setup, user_data,&
& destroy_notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: self
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_notify
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gproxyresolver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_proxy_resolver_get_type (void) G_GNUC_CONST;
function g_proxy_resolver_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_proxy_resolver_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GProxyResolver *g_proxy_resolver_get_default (void);
function g_proxy_resolver_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_resolver_get_default
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_proxy_resolver_is_supported (GProxyResolver *resolver);
function g_proxy_resolver_is_supported(resolver) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_proxy_resolver_is_supported
  type(c_ptr), value :: resolver
end function

! GLIB_AVAILABLE_IN_ALL
!gchar **g_proxy_resolver_lookup (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
function g_proxy_resolver_lookup(resolver, uri, cancellable, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_proxy_resolver_lookup
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_proxy_resolver_lookup_async (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar **g_proxy_resolver_lookup_finish (GProxyResolver *resolver, GAsyncResult *result, GError **error);
function g_proxy_resolver_lookup_finish(resolver, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_resolver_lookup_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnetworkservice.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_network_service_get_type (void) G_GNUC_CONST;
function g_network_service_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_network_service_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnectable *g_network_service_new (const gchar *service, const gchar *protocol, const gchar *domain);
function g_network_service_new(service, protocol, domain) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_network_service_new
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_service_get_service (GNetworkService *srv);
function g_network_service_get_service(srv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_service_get_service
  type(c_ptr), value :: srv
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_service_get_protocol (GNetworkService *srv);
function g_network_service_get_protocol(srv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_service_get_protocol
  type(c_ptr), value :: srv
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_service_get_domain (GNetworkService *srv);
function g_network_service_get_domain(srv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_service_get_domain
  type(c_ptr), value :: srv
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_service_get_scheme (GNetworkService *srv);
function g_network_service_get_scheme(srv) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_service_get_scheme
  type(c_ptr), value :: srv
end function

! GLIB_AVAILABLE_IN_ALL
!void g_network_service_set_scheme (GNetworkService *srv, const gchar *scheme);
subroutine g_network_service_set_scheme(srv, scheme) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: srv
  character(kind=c_char), dimension(*) :: scheme
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmemoryoutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_memory_output_stream_get_type (void) G_GNUC_CONST;
function g_memory_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_memory_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream *g_memory_output_stream_new (gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
function g_memory_output_stream_new(data, size, realloc_function,&
& destroy_function) bind(c)
  import :: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_output_stream_new
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  type(c_funptr), value :: realloc_function
  type(c_funptr), value :: destroy_function
end function

! GLIB_AVAILABLE_IN_2_36
!GOutputStream *g_memory_output_stream_new_resizable (void);
function g_memory_output_stream_new_resizable() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_output_stream_new_resizable
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_memory_output_stream_get_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data(ostream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_output_stream_get_data
  type(c_ptr), value :: ostream
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_memory_output_stream_get_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_size(ostream) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_size
  type(c_ptr), value :: ostream
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_memory_output_stream_get_data_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data_size(ostream) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_data_size
  type(c_ptr), value :: ostream
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_memory_output_stream_steal_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_steal_data(ostream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_output_stream_steal_data
  type(c_ptr), value :: ostream
end function

! GLIB_AVAILABLE_IN_2_34
!GBytes * g_memory_output_stream_steal_as_bytes (GMemoryOutputStream *ostream);
function g_memory_output_stream_steal_as_bytes(ostream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_output_stream_steal_as_bytes
  type(c_ptr), value :: ostream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusactiongroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_action_group_get_type (void) G_GNUC_CONST;
function g_dbus_action_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_action_group_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GDBusActionGroup * g_dbus_action_group_get (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
function g_dbus_action_group_get(connection, bus_name, object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_action_group_get
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_36
!gchar *g_dbus_address_escape_value (const gchar *string);
function g_dbus_address_escape_value(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_address_escape_value
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_address (const gchar *string);
function g_dbus_is_address(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_address
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_supported_address (const gchar *string, GError **error);
function g_dbus_is_supported_address(string, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_dbus_is_supported_address
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_address_get_stream (const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_address_get_stream(address, cancellable, callback, user_data)&
& bind(c)
  import :: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_dbus_address_get_stream_finish (GAsyncResult *res, gchar **out_guid, GError **error);
function g_dbus_address_get_stream_finish(res, out_guid, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_address_get_stream_finish
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: out_guid
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_dbus_address_get_stream_sync (const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
function g_dbus_address_get_stream_sync(address, out_guid, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_address_get_stream_sync
  character(kind=c_char), dimension(*) :: address
  type(c_ptr), dimension(*) :: out_guid
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_address_get_for_bus_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_dbus_address_get_for_bus_sync(bus_type, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_dbus_address_get_for_bus_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobjectskeleton.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_skeleton_get_type (void) G_GNUC_CONST;
function g_dbus_object_skeleton_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_skeleton_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectSkeleton *g_dbus_object_skeleton_new (const gchar *object_path);
function g_dbus_object_skeleton_new(object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_skeleton_new
  character(kind=c_char), dimension(*) :: object_path
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_skeleton_flush (GDBusObjectSkeleton *object);
subroutine g_dbus_object_skeleton_flush(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_skeleton_add_interface (GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
subroutine g_dbus_object_skeleton_add_interface(object, interface_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: interface_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_skeleton_remove_interface (GDBusObjectSkeleton *object, GDBusInterfaceSkeleton *interface_);
subroutine g_dbus_object_skeleton_remove_interface(object, interface_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: interface_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_skeleton_remove_interface_by_name (GDBusObjectSkeleton *object, const gchar *interface_name);
subroutine g_dbus_object_skeleton_remove_interface_by_name(object,&
& interface_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: interface_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_skeleton_set_object_path (GDBusObjectSkeleton *object, const gchar *object_path);
subroutine g_dbus_object_skeleton_set_object_path(object, object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: object_path
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmountoperation.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_mount_operation_get_type (void) G_GNUC_CONST;
function g_mount_operation_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_mount_operation_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GMountOperation * g_mount_operation_new (void);
function g_mount_operation_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_operation_new
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_mount_operation_get_username (GMountOperation *op);
function g_mount_operation_get_username(op) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_operation_get_username
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_username (GMountOperation *op, const char *username);
subroutine g_mount_operation_set_username(op, username) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: username
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const char * g_mount_operation_get_password (GMountOperation *op);
function g_mount_operation_get_password(op) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_operation_get_password
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_password (GMountOperation *op, const char *password);
subroutine g_mount_operation_set_password(op, password) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: password
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_mount_operation_get_anonymous (GMountOperation *op);
function g_mount_operation_get_anonymous(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_anonymous
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_anonymous (GMountOperation *op, gboolean anonymous);
subroutine g_mount_operation_set_anonymous(op, anonymous) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: anonymous
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const char * g_mount_operation_get_domain (GMountOperation *op);
function g_mount_operation_get_domain(op) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_mount_operation_get_domain
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_domain (GMountOperation *op, const char *domain);
subroutine g_mount_operation_set_domain(op, domain) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: domain
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GPasswordSave g_mount_operation_get_password_save (GMountOperation *op);
function g_mount_operation_get_password_save(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_password_save
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_password_save (GMountOperation *op, GPasswordSave save);
subroutine g_mount_operation_set_password_save(op, save) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: save
end subroutine

! GLIB_AVAILABLE_IN_ALL
!int g_mount_operation_get_choice (GMountOperation *op);
function g_mount_operation_get_choice(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_choice
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_set_choice (GMountOperation *op, int choice);
subroutine g_mount_operation_set_choice(op, choice) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: choice
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_mount_operation_reply (GMountOperation *op, GMountOperationResult result);
subroutine g_mount_operation_reply(op, result) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gboolean g_mount_operation_get_is_tcrypt_hidden_volume (GMountOperation *op);
function g_mount_operation_get_is_tcrypt_hidden_volume(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_is_tcrypt_hidden_volume
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_2_58
!void g_mount_operation_set_is_tcrypt_hidden_volume (GMountOperation *op, gboolean hidden_volume);
subroutine g_mount_operation_set_is_tcrypt_hidden_volume(op, hidden_volume)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: hidden_volume
end subroutine

! GLIB_AVAILABLE_IN_2_58
!gboolean g_mount_operation_get_is_tcrypt_system_volume (GMountOperation *op);
function g_mount_operation_get_is_tcrypt_system_volume(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_is_tcrypt_system_volume
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_2_58
!void g_mount_operation_set_is_tcrypt_system_volume (GMountOperation *op, gboolean system_volume);
subroutine g_mount_operation_set_is_tcrypt_system_volume(op, system_volume)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: system_volume
end subroutine

! GLIB_AVAILABLE_IN_2_58
!guint g_mount_operation_get_pim (GMountOperation *op);
function g_mount_operation_get_pim(op) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_pim
  type(c_ptr), value :: op
end function

! GLIB_AVAILABLE_IN_2_58
!void g_mount_operation_set_pim (GMountOperation *op, guint pim);
subroutine g_mount_operation_set_pim(op, pim) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: pim
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpermission.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_permission_get_type (void);
function g_permission_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_permission_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_acquire (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_acquire(permission, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_acquire
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_permission_acquire_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_acquire_async(permission, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_acquire_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_acquire_finish(permission, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_acquire_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_release (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_release(permission, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_release
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_permission_release_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_release_async(permission, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_release_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_release_finish(permission, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_release_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_get_allowed (GPermission *permission);
function g_permission_get_allowed(permission) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_get_allowed
  type(c_ptr), value :: permission
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_get_can_acquire (GPermission *permission);
function g_permission_get_can_acquire(permission) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_get_can_acquire
  type(c_ptr), value :: permission
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_permission_get_can_release (GPermission *permission);
function g_permission_get_can_release(permission) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_permission_get_can_release
  type(c_ptr), value :: permission
end function

! GLIB_AVAILABLE_IN_ALL
!void g_permission_impl_update (GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
subroutine g_permission_impl_update(permission, allowed, can_acquire,&
& can_release) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: permission
  integer(c_int), value :: allowed
  integer(c_int), value :: can_acquire
  integer(c_int), value :: can_release
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobject.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_get_type (void) G_GNUC_CONST;
function g_dbus_object_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_object_get_object_path (GDBusObject *object);
function g_dbus_object_get_object_path(object) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_get_object_path
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_dbus_object_get_interfaces (GDBusObject *object);
function g_dbus_object_get_interfaces(object) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_get_interfaces
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterface *g_dbus_object_get_interface (GDBusObject *object, const gchar *interface_name);
function g_dbus_object_get_interface(object, interface_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_get_interface
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: interface_name
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gemblemedicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_emblemed_icon_get_type (void) G_GNUC_CONST;
function g_emblemed_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_emblemed_icon_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_emblemed_icon_new (GIcon *icon, GEmblem *emblem);
function g_emblemed_icon_new(icon, emblem) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_emblemed_icon_new
  type(c_ptr), value :: icon
  type(c_ptr), value :: emblem
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_emblemed_icon_get_icon (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_icon(emblemed) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_icon
  type(c_ptr), value :: emblemed
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_emblemed_icon_get_emblems (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_emblems(emblemed) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_emblems
  type(c_ptr), value :: emblemed
end function

! GLIB_AVAILABLE_IN_ALL
!void g_emblemed_icon_add_emblem (GEmblemedIcon *emblemed, GEmblem *emblem);
subroutine g_emblemed_icon_add_emblem(emblemed, emblem) bind(c)
  import :: c_ptr
  type(c_ptr), value :: emblemed
  type(c_ptr), value :: emblem
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_emblemed_icon_clear_emblems (GEmblemedIcon *emblemed);
subroutine g_emblemed_icon_clear_emblems(emblemed) bind(c)
  import :: c_ptr
  type(c_ptr), value :: emblemed
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gresource.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GQuark g_resource_error_quark (void);
function g_resource_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_resource_error_quark
end function

! GLIB_AVAILABLE_IN_2_32
!GType g_resource_get_type (void) G_GNUC_CONST;
function g_resource_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_resource_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GResource * g_resource_new_from_data (GBytes *data, GError **error);
function g_resource_new_from_data(data, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resource_new_from_data
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GResource * g_resource_ref (GResource *resource);
function g_resource_ref(resource) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_resource_ref
  type(c_ptr), value :: resource
end function

! GLIB_AVAILABLE_IN_2_32
!void g_resource_unref (GResource *resource);
subroutine g_resource_unref(resource) bind(c)
  import :: c_ptr
  type(c_ptr), value :: resource
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GResource * g_resource_load (const gchar *filename, GError **error);
function g_resource_load(filename, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_resource_load
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GInputStream *g_resource_open_stream (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resource_open_stream(resource, path, lookup_flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resource_open_stream
  type(c_ptr), value :: resource
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GBytes * g_resource_lookup_data (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resource_lookup_data(resource, path, lookup_flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resource_lookup_data
  type(c_ptr), value :: resource
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!char ** g_resource_enumerate_children (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resource_enumerate_children(resource, path, lookup_flags, error)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resource_enumerate_children
  type(c_ptr), value :: resource
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_resource_get_info (GResource *resource, const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
function g_resource_get_info(resource, path, lookup_flags, size, flags, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_resource_get_info
  type(c_ptr), value :: resource
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: size
  type(c_ptr), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_resources_register (GResource *resource);
subroutine g_resources_register(resource) bind(c)
  import :: c_ptr
  type(c_ptr), value :: resource
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_resources_unregister (GResource *resource);
subroutine g_resources_unregister(resource) bind(c)
  import :: c_ptr
  type(c_ptr), value :: resource
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GInputStream *g_resources_open_stream (const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resources_open_stream(path, lookup_flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resources_open_stream
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GBytes * g_resources_lookup_data (const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resources_lookup_data(path, lookup_flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resources_lookup_data
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!char ** g_resources_enumerate_children (const char *path, GResourceLookupFlags lookup_flags, GError **error);
function g_resources_enumerate_children(path, lookup_flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_resources_enumerate_children
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_resources_get_info (const char *path, GResourceLookupFlags lookup_flags, gsize *size, guint32 *flags, GError **error);
function g_resources_get_info(path, lookup_flags, size, flags, error) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_resources_get_info
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: lookup_flags
  type(c_ptr), value :: size
  type(c_ptr), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_static_resource_init (GStaticResource *static_resource);
subroutine g_static_resource_init(static_resource) bind(c)
  import :: c_ptr
  type(c_ptr), value :: static_resource
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_static_resource_fini (GStaticResource *static_resource);
subroutine g_static_resource_fini(static_resource) bind(c)
  import :: c_ptr
  type(c_ptr), value :: static_resource
end subroutine

! GLIB_AVAILABLE_IN_2_32
!GResource *g_static_resource_get_resource (GStaticResource *static_resource);
function g_static_resource_get_resource(static_resource) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_static_resource_get_resource
  type(c_ptr), value :: static_resource
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gproxyaddressenumerator.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_proxy_address_enumerator_get_type (void) G_GNUC_CONST;
function g_proxy_address_enumerator_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_proxy_address_enumerator_get_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusmessage.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_message_get_type (void) G_GNUC_CONST;
function g_dbus_message_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_message_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new (void);
function g_dbus_message_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_new
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_signal (const gchar *path, const gchar *interface_, const gchar *signal);
function g_dbus_message_new_signal(path, interface_, signal) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_signal
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: signal
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_method_call (const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
function g_dbus_message_new_method_call(name, path, interface_, method) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_call
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: method
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_method_reply (GDBusMessage *method_call_message);
function g_dbus_message_new_method_reply(method_call_message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_new_method_reply
  type(c_ptr), value :: method_call_message
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_method_error_valist (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args);
function g_dbus_message_new_method_error_valist(method_call_message,&
& error_name, error_message_format, var_args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_valist
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message_format
  type(c_ptr), value :: var_args
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_method_error_literal (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
function g_dbus_message_new_method_error_literal(method_call_message,&
& error_name, error_message) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_literal
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_message_print (GDBusMessage *message, guint indent);
function g_dbus_message_print(message, indent) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_print
  type(c_ptr), value :: message
  integer(c_int), value :: indent
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_message_get_locked (GDBusMessage *message);
function g_dbus_message_get_locked(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_locked
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_lock (GDBusMessage *message);
subroutine g_dbus_message_lock(message) bind(c)
  import :: c_ptr
  type(c_ptr), value :: message
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_copy (GDBusMessage *message, GError **error);
function g_dbus_message_copy(message, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_copy
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessageByteOrder g_dbus_message_get_byte_order (GDBusMessage *message);
function g_dbus_message_get_byte_order(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_byte_order
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_byte_order (GDBusMessage *message, GDBusMessageByteOrder byte_order);
subroutine g_dbus_message_set_byte_order(message, byte_order) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: byte_order
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusMessageType g_dbus_message_get_message_type (GDBusMessage *message);
function g_dbus_message_get_message_type(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_message_type
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_message_type (GDBusMessage *message, GDBusMessageType type);
subroutine g_dbus_message_set_message_type(message, type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusMessageFlags g_dbus_message_get_flags (GDBusMessage *message);
function g_dbus_message_get_flags(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_flags
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_flags (GDBusMessage *message, GDBusMessageFlags flags);
subroutine g_dbus_message_set_flags(message, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint32 g_dbus_message_get_serial (GDBusMessage *message);
function g_dbus_message_get_serial(message) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_serial
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_serial (GDBusMessage *message, guint32 serial);
subroutine g_dbus_message_set_serial(message, serial) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: serial
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_message_get_header (GDBusMessage *message, GDBusMessageHeaderField header_field);
function g_dbus_message_get_header(message, header_field) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_get_header
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_header (GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
subroutine g_dbus_message_set_header(message, header_field, value) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guchar *g_dbus_message_get_header_fields (GDBusMessage *message);
function g_dbus_message_get_header_fields(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_header_fields
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_message_get_body (GDBusMessage *message);
function g_dbus_message_get_body(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_body
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_body (GDBusMessage *message, GVariant *body);
subroutine g_dbus_message_set_body(message, body) bind(c)
  import :: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: body
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GUnixFDList *g_dbus_message_get_unix_fd_list (GDBusMessage *message);
function g_dbus_message_get_unix_fd_list(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_unix_fd_list
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_unix_fd_list (GDBusMessage *message, GUnixFDList *fd_list);
subroutine g_dbus_message_set_unix_fd_list(message, fd_list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: fd_list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint32 g_dbus_message_get_reply_serial (GDBusMessage *message);
function g_dbus_message_get_reply_serial(message) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_reply_serial
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_reply_serial (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_reply_serial(message, value) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_interface (GDBusMessage *message);
function g_dbus_message_get_interface(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_interface
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_interface (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_interface(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_member (GDBusMessage *message);
function g_dbus_message_get_member(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_member
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_member (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_member(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_path (GDBusMessage *message);
function g_dbus_message_get_path(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_path
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_path (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_path(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_sender (GDBusMessage *message);
function g_dbus_message_get_sender(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_sender
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_sender (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_sender(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_destination (GDBusMessage *message);
function g_dbus_message_get_destination(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_destination
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_destination (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_destination(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_error_name (GDBusMessage *message);
function g_dbus_message_get_error_name(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_error_name
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_error_name (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_error_name(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_signature (GDBusMessage *message);
function g_dbus_message_get_signature(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_signature
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_signature (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_signature(message, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint32 g_dbus_message_get_num_unix_fds (GDBusMessage *message);
function g_dbus_message_get_num_unix_fds(message) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_num_unix_fds
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_message_set_num_unix_fds (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_num_unix_fds(message, value) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_message_get_arg0 (GDBusMessage *message);
function g_dbus_message_get_arg0(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_message_get_arg0
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMessage *g_dbus_message_new_from_blob (guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_new_from_blob(blob, blob_len, capabilities, error)&
& bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_dbus_message_new_from_blob
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_dbus_message_bytes_needed (guchar *blob, gsize blob_len, GError **error);
function g_dbus_message_bytes_needed(blob, blob_len, error) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_dbus_message_bytes_needed
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guchar *g_dbus_message_to_blob (GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_to_blob(message, out_size, capabilities, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_to_blob
  type(c_ptr), value :: message
  type(c_ptr), value :: out_size
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_message_to_gerror (GDBusMessage *message, GError **error);
function g_dbus_message_to_gerror(message, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_message_to_gerror
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimpleactiongroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_simple_action_group_get_type (void) G_GNUC_CONST;
function g_simple_action_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_action_group_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSimpleActionGroup * g_simple_action_group_new (void);
function g_simple_action_group_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_simple_action_group_new
end function

! GLIB_DEPRECATED_IN_2_38_FOR (g_action_map_lookup_action)
!GAction * g_simple_action_group_lookup (GSimpleActionGroup *simple, const gchar *action_name);
function g_simple_action_group_lookup(simple, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_simple_action_group_lookup
  type(c_ptr), value :: simple
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_DEPRECATED_IN_2_38_FOR (g_action_map_add_action)
!void g_simple_action_group_insert (GSimpleActionGroup *simple, GAction *action);
subroutine g_simple_action_group_insert(simple, action) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: action
end subroutine

! GLIB_DEPRECATED_IN_2_38_FOR (g_action_map_remove_action)
!void g_simple_action_group_remove (GSimpleActionGroup *simple, const gchar *action_name);
subroutine g_simple_action_group_remove(simple, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: simple
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! GLIB_DEPRECATED_IN_2_38_FOR (g_action_map_add_action_entries)
!void g_simple_action_group_add_entries (GSimpleActionGroup *simple, const GActionEntry *entries, gint n_entries, gpointer user_data);
subroutine g_simple_action_group_add_entries(simple, entries, n_entries,&
& user_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: simple
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gproxy.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_proxy_get_type (void) G_GNUC_CONST;
function g_proxy_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_proxy_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GProxy *g_proxy_get_default_for_protocol (const gchar *protocol);
function g_proxy_get_default_for_protocol(protocol) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_proxy_get_default_for_protocol
  character(kind=c_char), dimension(*) :: protocol
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_proxy_connect (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
function g_proxy_connect(proxy, connection, proxy_address, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_connect
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_proxy_connect_async (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_connect_async(proxy, connection, proxy_address, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_proxy_connect_finish (GProxy *proxy, GAsyncResult *result, GError **error);
function g_proxy_connect_finish(proxy, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_proxy_connect_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_proxy_supports_hostname (GProxy *proxy);
function g_proxy_supports_hostname(proxy) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_proxy_supports_hostname
  type(c_ptr), value :: proxy
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gbufferedoutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_buffered_output_stream_get_type (void) G_GNUC_CONST;
function g_buffered_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_buffered_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream* g_buffered_output_stream_new (GOutputStream *base_stream);
function g_buffered_output_stream_new(base_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_buffered_output_stream_new
  type(c_ptr), value :: base_stream
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream* g_buffered_output_stream_new_sized (GOutputStream *base_stream, gsize size);
function g_buffered_output_stream_new_sized(base_stream, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_output_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_buffered_output_stream_get_buffer_size (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_buffer_size(stream) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_output_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_buffered_output_stream_set_buffer_size (GBufferedOutputStream *stream, gsize size);
subroutine g_buffered_output_stream_set_buffer_size(stream, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_buffered_output_stream_get_auto_grow (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_auto_grow(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_buffered_output_stream_get_auto_grow
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_buffered_output_stream_set_auto_grow (GBufferedOutputStream *stream, gboolean auto_grow);
subroutine g_buffered_output_stream_set_auto_grow(stream, auto_grow) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: auto_grow
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gioenumtypes.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gio/gactionmap.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_action_map_get_type (void) G_GNUC_CONST;
function g_action_map_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_action_map_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GAction * g_action_map_lookup_action (GActionMap *action_map, const gchar *action_name);
function g_action_map_lookup_action(action_map, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_map_lookup_action
  type(c_ptr), value :: action_map
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_2_32
!void g_action_map_add_action (GActionMap *action_map, GAction *action);
subroutine g_action_map_add_action(action_map, action) bind(c)
  import :: c_ptr
  type(c_ptr), value :: action_map
  type(c_ptr), value :: action
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_action_map_remove_action (GActionMap *action_map, const gchar *action_name);
subroutine g_action_map_remove_action(action_map, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_map
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_action_map_add_action_entries (GActionMap *action_map, const GActionEntry *entries, gint n_entries, gpointer user_data);
subroutine g_action_map_add_action_entries(action_map, entries, n_entries,&
& user_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: action_map
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnetworking.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_36
!void g_networking_init (void);
subroutine g_networking_init() bind(c)
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gconverterinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_converter_input_stream_get_type (void) G_GNUC_CONST;
function g_converter_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_converter_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream *g_converter_input_stream_new (GInputStream *base_stream, GConverter *converter);
function g_converter_input_stream_new(base_stream, converter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_converter_input_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GLIB_AVAILABLE_IN_ALL
!GConverter *g_converter_input_stream_get_converter (GConverterInputStream *converter_stream);
function g_converter_input_stream_get_converter(converter_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_converter_input_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsubprocess.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_40
!GType g_subprocess_get_type (void) G_GNUC_CONST;
function g_subprocess_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_subprocess_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GSubprocess * g_subprocess_newv (const gchar * const *argv, GSubprocessFlags flags, GError **error);
function g_subprocess_newv(argv, flags, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_subprocess_newv
  character(kind=c_char), dimension(*) :: argv
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!GOutputStream * g_subprocess_get_stdin_pipe (GSubprocess *subprocess);
function g_subprocess_get_stdin_pipe(subprocess) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_subprocess_get_stdin_pipe
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!GInputStream * g_subprocess_get_stdout_pipe (GSubprocess *subprocess);
function g_subprocess_get_stdout_pipe(subprocess) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_subprocess_get_stdout_pipe
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!GInputStream * g_subprocess_get_stderr_pipe (GSubprocess *subprocess);
function g_subprocess_get_stderr_pipe(subprocess) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_subprocess_get_stderr_pipe
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!const gchar * g_subprocess_get_identifier (GSubprocess *subprocess);
function g_subprocess_get_identifier(subprocess) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_subprocess_get_identifier
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_send_signal (GSubprocess *subprocess, gint signal_num);
subroutine g_subprocess_send_signal(subprocess, signal_num) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: subprocess
  integer(c_int), value :: signal_num
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_force_exit (GSubprocess *subprocess);
subroutine g_subprocess_force_exit(subprocess) bind(c)
  import :: c_ptr
  type(c_ptr), value :: subprocess
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_wait (GSubprocess *subprocess, GCancellable *cancellable, GError **error);
function g_subprocess_wait(subprocess, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_wait
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_wait_async (GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_subprocess_wait_async(subprocess, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_wait_finish (GSubprocess *subprocess, GAsyncResult *result, GError **error);
function g_subprocess_wait_finish(subprocess, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_wait_finish
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_wait_check (GSubprocess *subprocess, GCancellable *cancellable, GError **error);
function g_subprocess_wait_check(subprocess, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_wait_check
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_wait_check_async (GSubprocess *subprocess, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_subprocess_wait_check_async(subprocess, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_wait_check_finish (GSubprocess *subprocess, GAsyncResult *result, GError **error);
function g_subprocess_wait_check_finish(subprocess, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_wait_check_finish
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gint g_subprocess_get_status (GSubprocess *subprocess);
function g_subprocess_get_status(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_status
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_get_successful (GSubprocess *subprocess);
function g_subprocess_get_successful(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_successful
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_get_if_exited (GSubprocess *subprocess);
function g_subprocess_get_if_exited(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_if_exited
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gint g_subprocess_get_exit_status (GSubprocess *subprocess);
function g_subprocess_get_exit_status(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_exit_status
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_get_if_signaled (GSubprocess *subprocess);
function g_subprocess_get_if_signaled(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_if_signaled
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gint g_subprocess_get_term_sig (GSubprocess *subprocess);
function g_subprocess_get_term_sig(subprocess) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_get_term_sig
  type(c_ptr), value :: subprocess
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_communicate (GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
function g_subprocess_communicate(subprocess, stdin_buf, cancellable,&
& stdout_buf, stderr_buf, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_communicate
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: stdin_buf
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: stdout_buf
  type(c_ptr), value :: stderr_buf
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_communicate_async (GSubprocess *subprocess, GBytes *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_subprocess_communicate_async(subprocess, stdin_buf, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: stdin_buf
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_communicate_finish (GSubprocess *subprocess, GAsyncResult *result, GBytes **stdout_buf, GBytes **stderr_buf, GError **error);
function g_subprocess_communicate_finish(subprocess, result, stdout_buf,&
& stderr_buf, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_communicate_finish
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: result
  type(c_ptr), value :: stdout_buf
  type(c_ptr), value :: stderr_buf
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_communicate_utf8 (GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, char **stdout_buf, char **stderr_buf, GError **error);
function g_subprocess_communicate_utf8(subprocess, stdin_buf, cancellable,&
& stdout_buf, stderr_buf, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_subprocess_communicate_utf8
  type(c_ptr), value :: subprocess
  character(kind=c_char), dimension(*) :: stdin_buf
  type(c_ptr), value :: cancellable
  type(c_ptr), dimension(*) :: stdout_buf
  type(c_ptr), dimension(*) :: stderr_buf
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_subprocess_communicate_utf8_async (GSubprocess *subprocess, const char *stdin_buf, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_subprocess_communicate_utf8_async(subprocess, stdin_buf,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: subprocess
  character(kind=c_char), dimension(*) :: stdin_buf
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!gboolean g_subprocess_communicate_utf8_finish (GSubprocess *subprocess, GAsyncResult *result, char **stdout_buf, char **stderr_buf, GError **error);
function g_subprocess_communicate_utf8_finish(subprocess, result, stdout_buf,&
& stderr_buf, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_subprocess_communicate_utf8_finish
  type(c_ptr), value :: subprocess
  type(c_ptr), value :: result
  type(c_ptr), dimension(*) :: stdout_buf
  type(c_ptr), dimension(*) :: stderr_buf
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gvolumemonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_volume_monitor_get_type (void) G_GNUC_CONST;
function g_volume_monitor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_volume_monitor_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GVolumeMonitor *g_volume_monitor_get (void);
function g_volume_monitor_get() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_monitor_get
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_volume_monitor_get_connected_drives (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_connected_drives(volume_monitor) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_monitor_get_connected_drives
  type(c_ptr), value :: volume_monitor
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_volume_monitor_get_volumes (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_volumes(volume_monitor) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_monitor_get_volumes
  type(c_ptr), value :: volume_monitor
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_volume_monitor_get_mounts (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_mounts(volume_monitor) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_monitor_get_mounts
  type(c_ptr), value :: volume_monitor
end function

! GLIB_AVAILABLE_IN_ALL
!GVolume * g_volume_monitor_get_volume_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_volume_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

! GLIB_AVAILABLE_IN_ALL
!GMount * g_volume_monitor_get_mount_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_mount_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

! GLIB_DEPRECATED
!GVolume * g_volume_monitor_adopt_orphan_mount (GMount *mount);
function g_volume_monitor_adopt_orphan_mount(mount) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_monitor_adopt_orphan_mount
  type(c_ptr), value :: mount
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gunixcredentialsmessage.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GSocketControlMessage *g_unix_credentials_message_new (void);
function g_unix_credentials_message_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_credentials_message_new
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketControlMessage *g_unix_credentials_message_new_with_credentials (GCredentials *credentials);
function g_unix_credentials_message_new_with_credentials(credentials) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_credentials_message_new_with_credentials
  type(c_ptr), value :: credentials
end function

! GLIB_AVAILABLE_IN_ALL
!GCredentials *g_unix_credentials_message_get_credentials (GUnixCredentialsMessage *message);
function g_unix_credentials_message_get_credentials(message) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_credentials_message_get_credentials
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unix_credentials_message_is_supported (void);
function g_unix_credentials_message_is_supported() bind(c)
  import :: c_int
  integer(c_int) :: g_unix_credentials_message_is_supported
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gmenuexporter.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!guint g_dbus_connection_export_menu_model (GDBusConnection *connection, const gchar *object_path, GMenuModel *menu, GError **error);
function g_dbus_connection_export_menu_model(connection, object_path, menu,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_connection_export_menu_model
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: menu
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_dbus_connection_unexport_menu_model (GDBusConnection *connection, guint export_id);
subroutine g_dbus_connection_unexport_menu_model(connection, export_id) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: export_id
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpollableinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_pollable_input_stream_get_type (void) G_GNUC_CONST;
function g_pollable_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_pollable_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pollable_input_stream_can_poll (GPollableInputStream *stream);
function g_pollable_input_stream_can_poll(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pollable_input_stream_can_poll
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pollable_input_stream_is_readable (GPollableInputStream *stream);
function g_pollable_input_stream_is_readable(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pollable_input_stream_is_readable
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_pollable_input_stream_create_source (GPollableInputStream *stream, GCancellable *cancellable);
function g_pollable_input_stream_create_source(stream, cancellable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_pollable_input_stream_create_source
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_pollable_input_stream_read_nonblocking (GPollableInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_pollable_input_stream_read_nonblocking(stream, buffer, count,&
& cancellable, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_pollable_input_stream_read_nonblocking
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileattribute.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_attribute_info_list_get_type (void);
function g_file_attribute_info_list_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_attribute_info_list_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeInfoList * g_file_attribute_info_list_new (void);
function g_file_attribute_info_list_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_new
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeInfoList * g_file_attribute_info_list_ref (GFileAttributeInfoList *list);
function g_file_attribute_info_list_ref(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_ref
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_attribute_info_list_unref (GFileAttributeInfoList *list);
subroutine g_file_attribute_info_list_unref(list) bind(c)
  import :: c_ptr
  type(c_ptr), value :: list
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeInfoList * g_file_attribute_info_list_dup (GFileAttributeInfoList *list);
function g_file_attribute_info_list_dup(list) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_dup
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_ALL
!const GFileAttributeInfo *g_file_attribute_info_list_lookup (GFileAttributeInfoList *list, const char *name);
function g_file_attribute_info_list_lookup(list, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_info_list_lookup
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_attribute_info_list_add (GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
subroutine g_file_attribute_info_list_add(list, name, type, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: type
  integer(c_int), value :: flags
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketlistener.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_listener_get_type (void) G_GNUC_CONST;
function g_socket_listener_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_listener_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketListener * g_socket_listener_new (void);
function g_socket_listener_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_listener_new
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_listener_set_backlog (GSocketListener *listener, int listen_backlog);
subroutine g_socket_listener_set_backlog(listener, listen_backlog) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: listener
  integer(c_int), value :: listen_backlog
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_listener_add_socket (GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
function g_socket_listener_add_socket(listener, socket, source_object, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_listener_add_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: socket
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_listener_add_address (GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
function g_socket_listener_add_address(listener, address, type, protocol,&
& source_object, effective_address, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_listener_add_address
  type(c_ptr), value :: listener
  type(c_ptr), value :: address
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: source_object
  type(c_ptr), value :: effective_address
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_listener_add_inet_port (GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
function g_socket_listener_add_inet_port(listener, port, source_object, error)&
& bind(c)
  import :: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_socket_listener_add_inet_port
  type(c_ptr), value :: listener
  integer(c_int16_t), value :: port
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_socket_listener_add_any_inet_port (GSocketListener *listener, GObject *source_object, GError **error);
function g_socket_listener_add_any_inet_port(listener, source_object, error)&
& bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_socket_listener_add_any_inet_port
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocket * g_socket_listener_accept_socket (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept_socket(listener, source_object, cancellable,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_listener_accept_socket_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_socket_async(listener, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocket * g_socket_listener_accept_socket_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_socket_finish(listener, result,&
& source_object, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_listener_accept (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept(listener, source_object, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_listener_accept
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_listener_accept_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_async(listener, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection * g_socket_listener_accept_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_finish(listener, result, source_object,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_socket_listener_accept_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_listener_close (GSocketListener *listener);
subroutine g_socket_listener_close(listener) bind(c)
  import :: c_ptr
  type(c_ptr), value :: listener
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gactiongroupexporter.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!guint g_dbus_connection_export_action_group (GDBusConnection *connection, const gchar *object_path, GActionGroup *action_group, GError **error);
function g_dbus_connection_export_action_group(connection, object_path,&
& action_group, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_connection_export_action_group
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: action_group
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!void g_dbus_connection_unexport_action_group (GDBusConnection *connection, guint export_id);
subroutine g_dbus_connection_unexport_action_group(connection, export_id)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: export_id
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gapplicationcommandline.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_application_command_line_get_type (void) G_GNUC_CONST;
function g_application_command_line_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_application_command_line_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_application_command_line_get_arguments (GApplicationCommandLine *cmdline, int *argc);
function g_application_command_line_get_arguments(cmdline, argc) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_arguments
  type(c_ptr), value :: cmdline
  type(c_ptr), value :: argc
end function

! GLIB_AVAILABLE_IN_2_40
!GVariantDict * g_application_command_line_get_options_dict (GApplicationCommandLine *cmdline);
function g_application_command_line_get_options_dict(cmdline) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_options_dict
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_2_36
!GInputStream * g_application_command_line_get_stdin (GApplicationCommandLine *cmdline);
function g_application_command_line_get_stdin(cmdline) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_stdin
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * const * g_application_command_line_get_environ (GApplicationCommandLine *cmdline);
function g_application_command_line_get_environ(cmdline) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_environ
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_application_command_line_getenv (GApplicationCommandLine *cmdline, const gchar *name);
function g_application_command_line_getenv(cmdline, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_application_command_line_getenv
  type(c_ptr), value :: cmdline
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_application_command_line_get_cwd (GApplicationCommandLine *cmdline);
function g_application_command_line_get_cwd(cmdline) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_cwd
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_application_command_line_get_is_remote (GApplicationCommandLine *cmdline);
function g_application_command_line_get_is_remote(cmdline) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_command_line_get_is_remote
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_ALL
!int g_application_command_line_get_exit_status (GApplicationCommandLine *cmdline);
function g_application_command_line_get_exit_status(cmdline) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_application_command_line_get_exit_status
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_ALL
!void g_application_command_line_set_exit_status (GApplicationCommandLine *cmdline, int exit_status);
subroutine g_application_command_line_set_exit_status(cmdline, exit_status)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: cmdline
  integer(c_int), value :: exit_status
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_application_command_line_get_platform_data (GApplicationCommandLine *cmdline);
function g_application_command_line_get_platform_data(cmdline) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_application_command_line_get_platform_data
  type(c_ptr), value :: cmdline
end function

! GLIB_AVAILABLE_IN_2_36
!GFile * g_application_command_line_create_file_for_arg (GApplicationCommandLine *cmdline, const gchar *arg);
function g_application_command_line_create_file_for_arg(cmdline, arg) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_application_command_line_create_file_for_arg
  type(c_ptr), value :: cmdline
  character(kind=c_char), dimension(*) :: arg
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gseekable.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_seekable_get_type (void) G_GNUC_CONST;
function g_seekable_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_seekable_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!goffset g_seekable_tell (GSeekable *seekable);
function g_seekable_tell(seekable) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_seekable_tell
  type(c_ptr), value :: seekable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_seekable_can_seek (GSeekable *seekable);
function g_seekable_can_seek(seekable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_seekable_can_seek
  type(c_ptr), value :: seekable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_seekable_seek (GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
function g_seekable_seek(seekable, offset, type, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_seekable_seek
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  integer(c_int), value :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_seekable_can_truncate (GSeekable *seekable);
function g_seekable_can_truncate(seekable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_seekable_can_truncate
  type(c_ptr), value :: seekable
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_seekable_truncate (GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
function g_seekable_truncate(seekable, offset, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_seekable_truncate
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gremoteactiongroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_remote_action_group_get_type (void) G_GNUC_CONST;
function g_remote_action_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_remote_action_group_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!void g_remote_action_group_activate_action_full (GRemoteActionGroup *remote, const gchar *action_name, GVariant *parameter, GVariant *platform_data);
subroutine g_remote_action_group_activate_action_full(remote, action_name,&
& parameter, platform_data) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: remote
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: parameter
  type(c_ptr), value :: platform_data
end subroutine

! GLIB_AVAILABLE_IN_2_32
!void g_remote_action_group_change_action_state_full (GRemoteActionGroup *remote, const gchar *action_name, GVariant *value, GVariant *platform_data);
subroutine g_remote_action_group_change_action_state_full(remote, action_name,&
& value, platform_data) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: remote
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: value
  type(c_ptr), value :: platform_data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketcontrolmessage.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_control_message_get_type (void) G_GNUC_CONST;
function g_socket_control_message_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_control_message_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_socket_control_message_get_size (GSocketControlMessage *message);
function g_socket_control_message_get_size(message) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_control_message_get_size
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!int g_socket_control_message_get_level (GSocketControlMessage *message);
function g_socket_control_message_get_level(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_level
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!int g_socket_control_message_get_msg_type (GSocketControlMessage *message);
function g_socket_control_message_get_msg_type(message) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_msg_type
  type(c_ptr), value :: message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_socket_control_message_serialize (GSocketControlMessage *message, gpointer data);
subroutine g_socket_control_message_serialize(message, data) bind(c)
  import :: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketControlMessage *g_socket_control_message_deserialize (int level, int type, gsize size, gpointer data);
function g_socket_control_message_deserialize(level, type, size, data) bind(c)
  import :: c_ptr, c_int, c_size_t
  type(c_ptr) :: g_socket_control_message_deserialize
  integer(c_int), value :: level
  integer(c_int), value :: type
  integer(c_size_t), value :: size
  type(c_ptr), value :: data
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gactiongroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_action_group_get_type (void) G_GNUC_CONST;
function g_action_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_action_group_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_action_group_has_action (GActionGroup *action_group, const gchar *action_name);
function g_action_group_has_action(action_group, action_name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_action_group_has_action
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar ** g_action_group_list_actions (GActionGroup *action_group);
function g_action_group_list_actions(action_group) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_action_group_list_actions
  type(c_ptr), value :: action_group
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_action_group_get_action_parameter_type (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_parameter_type(action_group, action_name)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_parameter_type
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!const GVariantType * g_action_group_get_action_state_type (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state_type(action_group, action_name)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state_type
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_action_group_get_action_state_hint (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state_hint(action_group, action_name)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state_hint
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_action_group_get_action_enabled (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_enabled(action_group, action_name) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_action_group_get_action_enabled
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant * g_action_group_get_action_state (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state(action_group, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_change_action_state (GActionGroup *action_group, const gchar *action_name, GVariant *value);
subroutine g_action_group_change_action_state(action_group, action_name, value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_activate_action (GActionGroup *action_group, const gchar *action_name, GVariant *parameter);
subroutine g_action_group_activate_action(action_group, action_name, parameter)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: parameter
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_action_added (GActionGroup *action_group, const gchar *action_name);
subroutine g_action_group_action_added(action_group, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_action_removed (GActionGroup *action_group, const gchar *action_name);
subroutine g_action_group_action_removed(action_group, action_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_action_enabled_changed (GActionGroup *action_group, const gchar *action_name, gboolean enabled);
subroutine g_action_group_action_enabled_changed(action_group, action_name,&
& enabled) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  integer(c_int), value :: enabled
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_action_group_action_state_changed (GActionGroup *action_group, const gchar *action_name, GVariant *state);
subroutine g_action_group_action_state_changed(action_group, action_name,&
& state) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: state
end subroutine

! GLIB_AVAILABLE_IN_2_32
!gboolean g_action_group_query_action (GActionGroup *action_group, const gchar *action_name, gboolean *enabled, const GVariantType **parameter_type, const GVariantType **state_type, GVariant **state_hint, GVariant **state);
function g_action_group_query_action(action_group, action_name, enabled,&
& parameter_type, state_type, state_hint, state) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_action_group_query_action
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: enabled
  type(c_ptr), value :: parameter_type
  type(c_ptr), value :: state_type
  type(c_ptr), value :: state_hint
  type(c_ptr), value :: state
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimpleasyncresult.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_simple_async_result_get_type (void) G_GNUC_CONST;
function g_simple_async_result_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_async_result_get_type
end function

! GLIB_DEPRECATED_IN_2_46_FOR(g_task_new)
!GSimpleAsyncResult *g_simple_async_result_new (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
function g_simple_async_result_new(source_object, callback, user_data,&
& source_tag) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: source_tag
end function

! GLIB_DEPRECATED_IN_2_46_FOR(g_task_new)
!GSimpleAsyncResult *g_simple_async_result_new_from_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
function g_simple_async_result_new_from_error(source_object, callback,&
& user_data, error) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new_from_error
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_46_FOR(g_task_new)
!GSimpleAsyncResult *g_simple_async_result_new_take_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
function g_simple_async_result_new_take_error(source_object, callback,&
& user_data, error) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new_take_error
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_op_res_gpointer (GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
subroutine g_simple_async_result_set_op_res_gpointer(simple, op_res,&
& destroy_op_res) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: op_res
  type(c_funptr), value :: destroy_op_res
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gpointer g_simple_async_result_get_op_res_gpointer (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gpointer(simple) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_simple_async_result_get_op_res_gpointer
  type(c_ptr), value :: simple
end function

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_op_res_gssize (GSimpleAsyncResult *simple, gssize op_res);
subroutine g_simple_async_result_set_op_res_gssize(simple, op_res) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: simple
  integer(c_size_t), value :: op_res
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gssize g_simple_async_result_get_op_res_gssize (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gssize(simple) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_simple_async_result_get_op_res_gssize
  type(c_ptr), value :: simple
end function

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_op_res_gboolean (GSimpleAsyncResult *simple, gboolean op_res);
subroutine g_simple_async_result_set_op_res_gboolean(simple, op_res) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: op_res
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gboolean g_simple_async_result_get_op_res_gboolean (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gboolean(simple) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_get_op_res_gboolean
  type(c_ptr), value :: simple
end function

! GLIB_AVAILABLE_IN_2_32 /* Also deprecated, but can't mark something both AVAILABLE and DEPRECATED */
!void g_simple_async_result_set_check_cancellable (GSimpleAsyncResult *simple, GCancellable *check_cancellable);
subroutine g_simple_async_result_set_check_cancellable(simple,&
& check_cancellable) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: check_cancellable
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gpointer g_simple_async_result_get_source_tag (GSimpleAsyncResult *simple);
function g_simple_async_result_get_source_tag(simple) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_simple_async_result_get_source_tag
  type(c_ptr), value :: simple
end function

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_handle_cancellation (GSimpleAsyncResult *simple, gboolean handle_cancellation);
subroutine g_simple_async_result_set_handle_cancellation(simple,&
& handle_cancellation) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: handle_cancellation
end subroutine

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_complete (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete(simple) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
end subroutine

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_complete_in_idle (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete_in_idle(simple) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
end subroutine

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_run_in_thread (GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
subroutine g_simple_async_result_run_in_thread(simple, func, io_priority,&
& cancellable) bind(c)
  import :: c_ptr, c_funptr, c_int
  type(c_ptr), value :: simple
  type(c_funptr), value :: func
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_from_error (GSimpleAsyncResult *simple, const GError *error);
subroutine g_simple_async_result_set_from_error(simple, error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: error
end subroutine

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_take_error (GSimpleAsyncResult *simple, GError *error);
subroutine g_simple_async_result_take_error(simple, error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: error
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gboolean g_simple_async_result_propagate_error (GSimpleAsyncResult *simple, GError **dest);
function g_simple_async_result_propagate_error(simple, dest) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_propagate_error
  type(c_ptr), value :: simple
  type(c_ptr), value :: dest
end function

! GLIB_DEPRECATED_IN_2_46
!void g_simple_async_result_set_error_va (GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args) G_GNUC_PRINTF(4, 0);
subroutine g_simple_async_result_set_error_va(simple, domain, code, format,&
& args) bind(c)
  import :: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: simple
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLIB_DEPRECATED_IN_2_46
!gboolean g_simple_async_result_is_valid (GAsyncResult *result, GObject *source, gpointer source_tag);
function g_simple_async_result_is_valid(result, source, source_tag) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_is_valid
  type(c_ptr), value :: result
  type(c_ptr), value :: source
  type(c_ptr), value :: source_tag
end function

! GLIB_DEPRECATED_IN_2_46_FOR(g_task_report_error)
!void g_simple_async_report_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
subroutine g_simple_async_report_gerror_in_idle(object, callback, user_data,&
& error) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end subroutine

! GLIB_DEPRECATED_IN_2_46_FOR(g_task_report_error)
!void g_simple_async_report_take_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
subroutine g_simple_async_report_take_gerror_in_idle(object, callback,&
& user_data, error) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gbufferedinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_buffered_input_stream_get_type (void) G_GNUC_CONST;
function g_buffered_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_buffered_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream* g_buffered_input_stream_new (GInputStream *base_stream);
function g_buffered_input_stream_new(base_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_buffered_input_stream_new
  type(c_ptr), value :: base_stream
end function

! GLIB_AVAILABLE_IN_ALL
!GInputStream* g_buffered_input_stream_new_sized (GInputStream *base_stream, gsize size);
function g_buffered_input_stream_new_sized(base_stream, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_input_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_buffered_input_stream_get_buffer_size (GBufferedInputStream *stream);
function g_buffered_input_stream_get_buffer_size(stream) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_buffered_input_stream_set_buffer_size (GBufferedInputStream *stream, gsize size);
subroutine g_buffered_input_stream_set_buffer_size(stream, size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gsize g_buffered_input_stream_get_available (GBufferedInputStream *stream);
function g_buffered_input_stream_get_available(stream) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_available
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_buffered_input_stream_peek (GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
function g_buffered_input_stream_peek(stream, buffer, offset, count) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_peek
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: offset
  integer(c_size_t), value :: count
end function

! GLIB_AVAILABLE_IN_ALL
!const void* g_buffered_input_stream_peek_buffer (GBufferedInputStream *stream, gsize *count);
function g_buffered_input_stream_peek_buffer(stream, count) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_buffered_input_stream_peek_buffer
  type(c_ptr), value :: stream
  type(c_ptr), value :: count
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_buffered_input_stream_fill (GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_fill(stream, count, cancellable, error)&
& bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_buffered_input_stream_fill_async (GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_buffered_input_stream_fill_async(stream, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gssize g_buffered_input_stream_fill_finish (GBufferedInputStream *stream, GAsyncResult *result, GError **error);
function g_buffered_input_stream_fill_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!int g_buffered_input_stream_read_byte (GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_read_byte(stream, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_buffered_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gioscheduler.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_36_FOR ("GThreadPool or g_task_run_in_thread")
!void g_io_scheduler_push_job (GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
subroutine g_io_scheduler_push_job(job_func, user_data, notify, io_priority,&
& cancellable) bind(c)
  import :: c_funptr, c_ptr, c_int
  type(c_funptr), value :: job_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! GLIB_DEPRECATED_IN_2_36
!void g_io_scheduler_cancel_all_jobs (void);
subroutine g_io_scheduler_cancel_all_jobs() bind(c)
end subroutine

! GLIB_DEPRECATED_IN_2_36_FOR (g_main_context_invoke)
!gboolean g_io_scheduler_job_send_to_mainloop (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
function g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify)&
& bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_io_scheduler_job_send_to_mainloop
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GLIB_DEPRECATED_IN_2_36_FOR (g_main_context_invoke)
!void g_io_scheduler_job_send_to_mainloop_async (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
subroutine g_io_scheduler_job_send_to_mainloop_async(job, func, user_data,&
& notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusmenumodel.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_menu_model_get_type (void) G_GNUC_CONST;
function g_dbus_menu_model_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_menu_model_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusMenuModel * g_dbus_menu_model_get (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path);
function g_dbus_menu_model_get(connection, bus_name, object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_menu_model_get
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gioenums.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusproxy.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_proxy_get_type (void) G_GNUC_CONST;
function g_dbus_proxy_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_proxy_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_new (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new(connection, flags, info, name, object_path,&
& interface_name, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_char, c_funptr
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusProxy *g_dbus_proxy_new_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusProxy *g_dbus_proxy_new_sync (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_sync(connection, flags, info, name, object_path,&
& interface_name, cancellable, error) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_sync
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_new_for_bus (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path,&
& interface_name, cancellable, callback, user_data) bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusProxy *g_dbus_proxy_new_for_bus_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_for_bus_finish(res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_for_bus_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusProxy *g_dbus_proxy_new_for_bus_sync (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name,&
& object_path, interface_name, cancellable, error) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_for_bus_sync
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_proxy_get_connection (GDBusProxy *proxy);
function g_dbus_proxy_get_connection(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_connection
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusProxyFlags g_dbus_proxy_get_flags (GDBusProxy *proxy);
function g_dbus_proxy_get_flags(proxy) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_flags
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_proxy_get_name (GDBusProxy *proxy);
function g_dbus_proxy_get_name(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_proxy_get_name_owner (GDBusProxy *proxy);
function g_dbus_proxy_get_name_owner(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name_owner
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_proxy_get_object_path (GDBusProxy *proxy);
function g_dbus_proxy_get_object_path(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_object_path
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_proxy_get_interface_name (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_name(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_name
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_dbus_proxy_get_default_timeout (GDBusProxy *proxy);
function g_dbus_proxy_get_default_timeout(proxy) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_default_timeout
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_set_default_timeout (GDBusProxy *proxy, gint timeout_msec);
subroutine g_dbus_proxy_set_default_timeout(proxy, timeout_msec) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: proxy
  integer(c_int), value :: timeout_msec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceInfo *g_dbus_proxy_get_interface_info (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_info(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_info
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_set_interface_info (GDBusProxy *proxy, GDBusInterfaceInfo *info);
subroutine g_dbus_proxy_set_interface_info(proxy, info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_proxy_get_cached_property (GDBusProxy *proxy, const gchar *property_name);
function g_dbus_proxy_get_cached_property(proxy, property_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_proxy_get_cached_property
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_set_cached_property (GDBusProxy *proxy, const gchar *property_name, GVariant *value);
subroutine g_dbus_proxy_set_cached_property(proxy, property_name, value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar **g_dbus_proxy_get_cached_property_names (GDBusProxy *proxy);
function g_dbus_proxy_get_cached_property_names(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_cached_property_names
  type(c_ptr), value :: proxy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_call (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_call(proxy, method_name, parameters, flags,&
& timeout_msec, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_proxy_call_finish (GDBusProxy *proxy, GAsyncResult *res, GError **error);
function g_dbus_proxy_call_finish(proxy, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_call_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_proxy_call_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_proxy_call_sync(proxy, method_name, parameters, flags,&
& timeout_msec, cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_proxy_call_sync
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_proxy_call_with_unix_fd_list (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_call_with_unix_fd_list(proxy, method_name, parameters,&
& flags, timeout_msec, fd_list, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: fd_list
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_proxy_call_with_unix_fd_list_finish (GDBusProxy *proxy, GUnixFDList **out_fd_list, GAsyncResult *res, GError **error);
function g_dbus_proxy_call_with_unix_fd_list_finish(proxy, out_fd_list, res,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_proxy_call_with_unix_fd_list_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: out_fd_list
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_proxy_call_with_unix_fd_list_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GUnixFDList *fd_list, GUnixFDList **out_fd_list, GCancellable *cancellable, GError **error);
function g_dbus_proxy_call_with_unix_fd_list_sync(proxy, method_name,&
& parameters, flags, timeout_msec, fd_list, out_fd_list, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_proxy_call_with_unix_fd_list_sync
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: fd_list
  type(c_ptr), value :: out_fd_list
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdtlsclientconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_48
!GType g_dtls_client_connection_get_type (void) G_GNUC_CONST;
function g_dtls_client_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dtls_client_connection_get_type
end function

! GLIB_AVAILABLE_IN_2_48
!GDatagramBased *g_dtls_client_connection_new (GDatagramBased *base_socket, GSocketConnectable *server_identity, GError **error);
function g_dtls_client_connection_new(base_socket, server_identity, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_client_connection_new
  type(c_ptr), value :: base_socket
  type(c_ptr), value :: server_identity
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!GTlsCertificateFlags g_dtls_client_connection_get_validation_flags (GDtlsClientConnection *conn);
function g_dtls_client_connection_get_validation_flags(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_client_connection_get_validation_flags
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_client_connection_set_validation_flags (GDtlsClientConnection *conn, GTlsCertificateFlags flags);
subroutine g_dtls_client_connection_set_validation_flags(conn, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_48
!GSocketConnectable *g_dtls_client_connection_get_server_identity (GDtlsClientConnection *conn);
function g_dtls_client_connection_get_server_identity(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_client_connection_get_server_identity
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_client_connection_set_server_identity (GDtlsClientConnection *conn, GSocketConnectable *identity);
subroutine g_dtls_client_connection_set_server_identity(conn, identity) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: identity
end subroutine

! GLIB_AVAILABLE_IN_2_48
!GList * g_dtls_client_connection_get_accepted_cas (GDtlsClientConnection *conn);
function g_dtls_client_connection_get_accepted_cas(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_client_connection_get_accepted_cas
  type(c_ptr), value :: conn
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimpleaction.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_simple_action_get_type (void) G_GNUC_CONST;
function g_simple_action_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_action_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSimpleAction * g_simple_action_new (const gchar *name, const GVariantType *parameter_type);
function g_simple_action_new(name, parameter_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_simple_action_new
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: parameter_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSimpleAction * g_simple_action_new_stateful (const gchar *name, const GVariantType *parameter_type, GVariant *state);
function g_simple_action_new_stateful(name, parameter_type, state) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_simple_action_new_stateful
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: parameter_type
  type(c_ptr), value :: state
end function

! GLIB_AVAILABLE_IN_ALL
!void g_simple_action_set_enabled (GSimpleAction *simple, gboolean enabled);
subroutine g_simple_action_set_enabled(simple, enabled) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: enabled
end subroutine

! GLIB_AVAILABLE_IN_2_30
!void g_simple_action_set_state (GSimpleAction *simple, GVariant *value);
subroutine g_simple_action_set_state(simple, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_2_44
!void g_simple_action_set_state_hint (GSimpleAction *simple, GVariant *state_hint);
subroutine g_simple_action_set_state_hint(simple, state_hint) bind(c)
  import :: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: state_hint
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsettingsbackend.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_settings_backend_get_type (void);
function g_settings_backend_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_settings_backend_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_changed (GSettingsBackend *backend, const gchar *key, gpointer origin_tag);
subroutine g_settings_backend_changed(backend, key, origin_tag) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: origin_tag
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_path_changed (GSettingsBackend *backend, const gchar *path, gpointer origin_tag);
subroutine g_settings_backend_path_changed(backend, path, origin_tag) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: origin_tag
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_flatten_tree (GTree *tree, gchar **path, const gchar ***keys, GVariant ***values);
subroutine g_settings_backend_flatten_tree(tree, path, keys, values) bind(c)
  import :: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), dimension(*) :: path
  type(c_ptr), dimension(*) :: keys
  type(c_ptr), value :: values
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_keys_changed (GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag);
subroutine g_settings_backend_keys_changed(backend, path, items, origin_tag)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: items
  type(c_ptr), value :: origin_tag
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_path_writable_changed (GSettingsBackend *backend, const gchar *path);
subroutine g_settings_backend_path_writable_changed(backend, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_writable_changed (GSettingsBackend *backend, const gchar *key);
subroutine g_settings_backend_writable_changed(backend, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_settings_backend_changed_tree (GSettingsBackend *backend, GTree *tree, gpointer origin_tag);
subroutine g_settings_backend_changed_tree(backend, tree, origin_tag) bind(c)
  import :: c_ptr
  type(c_ptr), value :: backend
  type(c_ptr), value :: tree
  type(c_ptr), value :: origin_tag
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSettingsBackend * g_settings_backend_get_default (void);
function g_settings_backend_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_settings_backend_get_default
end function

! GLIB_AVAILABLE_IN_ALL
!GSettingsBackend * g_keyfile_settings_backend_new (const gchar *filename, const gchar *root_path, const gchar *root_group);
function g_keyfile_settings_backend_new(filename, root_path, root_group)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_keyfile_settings_backend_new
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: root_path
  character(kind=c_char), dimension(*) :: root_group
end function

! GLIB_AVAILABLE_IN_ALL
!GSettingsBackend * g_null_settings_backend_new (void);
function g_null_settings_backend_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_null_settings_backend_new
end function

! GLIB_AVAILABLE_IN_ALL
!GSettingsBackend * g_memory_settings_backend_new (void);
function g_memory_settings_backend_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_memory_settings_backend_new
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpowerprofilemonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_70
!GPowerProfileMonitor *g_power_profile_monitor_dup_default (void);
function g_power_profile_monitor_dup_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_power_profile_monitor_dup_default
end function

! GLIB_AVAILABLE_IN_2_70
!gboolean g_power_profile_monitor_get_power_saver_enabled (GPowerProfileMonitor *monitor);
function g_power_profile_monitor_get_power_saver_enabled(monitor) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_power_profile_monitor_get_power_saver_enabled
  type(c_ptr), value :: monitor
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsinteraction.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_interaction_get_type (void) G_GNUC_CONST;
function g_tls_interaction_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_interaction_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsInteractionResult g_tls_interaction_invoke_ask_password (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
function g_tls_interaction_invoke_ask_password(interaction, password,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_invoke_ask_password
  type(c_ptr), value :: interaction
  type(c_ptr), value :: password
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsInteractionResult g_tls_interaction_ask_password (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GError **error);
function g_tls_interaction_ask_password(interaction, password, cancellable,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_ask_password
  type(c_ptr), value :: interaction
  type(c_ptr), value :: password
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_interaction_ask_password_async (GTlsInteraction *interaction, GTlsPassword *password, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_interaction_ask_password_async(interaction, password,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: interaction
  type(c_ptr), value :: password
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsInteractionResult g_tls_interaction_ask_password_finish (GTlsInteraction *interaction, GAsyncResult *result, GError **error);
function g_tls_interaction_ask_password_finish(interaction, result, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_ask_password_finish
  type(c_ptr), value :: interaction
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!GTlsInteractionResult g_tls_interaction_invoke_request_certificate (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
function g_tls_interaction_invoke_request_certificate(interaction, connection,&
& flags, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_invoke_request_certificate
  type(c_ptr), value :: interaction
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!GTlsInteractionResult g_tls_interaction_request_certificate (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GError **error);
function g_tls_interaction_request_certificate(interaction, connection, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_request_certificate
  type(c_ptr), value :: interaction
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!void g_tls_interaction_request_certificate_async (GTlsInteraction *interaction, GTlsConnection *connection, GTlsCertificateRequestFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_interaction_request_certificate_async(interaction, connection,&
& flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: interaction
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!GTlsInteractionResult g_tls_interaction_request_certificate_finish (GTlsInteraction *interaction, GAsyncResult *result, GError **error);
function g_tls_interaction_request_certificate_finish(interaction, result,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_interaction_request_certificate_finish
  type(c_ptr), value :: interaction
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/giotypes.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_interface_skeleton_get_type (void) G_GNUC_CONST;
function g_dbus_interface_skeleton_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_interface_skeleton_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceSkeletonFlags g_dbus_interface_skeleton_get_flags (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_flags(interface_) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_interface_skeleton_get_flags
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_skeleton_set_flags (GDBusInterfaceSkeleton *interface_, GDBusInterfaceSkeletonFlags flags);
subroutine g_dbus_interface_skeleton_set_flags(interface_, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: interface_
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceInfo *g_dbus_interface_skeleton_get_info (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_info(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_info
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusInterfaceVTable *g_dbus_interface_skeleton_get_vtable (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_vtable(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_vtable
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_interface_skeleton_get_properties (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_properties(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_properties
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_skeleton_flush (GDBusInterfaceSkeleton *interface_);
subroutine g_dbus_interface_skeleton_flush(interface_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: interface_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_interface_skeleton_export (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection, const gchar *object_path, GError **error);
function g_dbus_interface_skeleton_export(interface_, connection, object_path,&
& error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_interface_skeleton_export
  type(c_ptr), value :: interface_
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_skeleton_unexport (GDBusInterfaceSkeleton *interface_);
subroutine g_dbus_interface_skeleton_unexport(interface_) bind(c)
  import :: c_ptr
  type(c_ptr), value :: interface_
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_interface_skeleton_unexport_from_connection (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
subroutine g_dbus_interface_skeleton_unexport_from_connection(interface_,&
& connection) bind(c)
  import :: c_ptr
  type(c_ptr), value :: interface_
  type(c_ptr), value :: connection
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_interface_skeleton_get_connection (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_connection(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_connection
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_dbus_interface_skeleton_get_connections (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_connections(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_connections
  type(c_ptr), value :: interface_
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_interface_skeleton_has_connection (GDBusInterfaceSkeleton *interface_, GDBusConnection *connection);
function g_dbus_interface_skeleton_has_connection(interface_, connection)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_interface_skeleton_has_connection
  type(c_ptr), value :: interface_
  type(c_ptr), value :: connection
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_interface_skeleton_get_object_path (GDBusInterfaceSkeleton *interface_);
function g_dbus_interface_skeleton_get_object_path(interface_) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_interface_skeleton_get_object_path
  type(c_ptr), value :: interface_
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtask.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_36
!GType g_task_get_type (void) G_GNUC_CONST;
function g_task_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_task_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GTask *g_task_new (gpointer source_object, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer callback_data);
function g_task_new(source_object, cancellable, callback, callback_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_task_new
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: callback_data
end function

! GLIB_AVAILABLE_IN_2_36
!void g_task_report_error (gpointer source_object, GAsyncReadyCallback callback, gpointer callback_data, gpointer source_tag, GError *error);
subroutine g_task_report_error(source_object, callback, callback_data,&
& source_tag, error) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: callback_data
  type(c_ptr), value :: source_tag
  type(c_ptr), value :: error
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_set_task_data (GTask *task, gpointer task_data, GDestroyNotify task_data_destroy);
subroutine g_task_set_task_data(task, task_data, task_data_destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: task
  type(c_ptr), value :: task_data
  type(c_funptr), value :: task_data_destroy
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_set_priority (GTask *task, gint priority);
subroutine g_task_set_priority(task, priority) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: task
  integer(c_int), value :: priority
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_set_check_cancellable (GTask *task, gboolean check_cancellable);
subroutine g_task_set_check_cancellable(task, check_cancellable) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: task
  integer(c_int), value :: check_cancellable
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_set_source_tag (GTask *task, gpointer source_tag);
subroutine g_task_set_source_tag(task, source_tag) bind(c)
  import :: c_ptr
  type(c_ptr), value :: task
  type(c_ptr), value :: source_tag
end subroutine

! GLIB_AVAILABLE_IN_2_60
!void g_task_set_name (GTask *task, const gchar *name);
subroutine g_task_set_name(task, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: task
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_2_36
!gpointer g_task_get_source_object (GTask *task);
function g_task_get_source_object(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_source_object
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gpointer g_task_get_task_data (GTask *task);
function g_task_get_task_data(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_task_data
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gint g_task_get_priority (GTask *task);
function g_task_get_priority(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_get_priority
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!GMainContext *g_task_get_context (GTask *task);
function g_task_get_context(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_context
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!GCancellable *g_task_get_cancellable (GTask *task);
function g_task_get_cancellable(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_cancellable
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_get_check_cancellable (GTask *task);
function g_task_get_check_cancellable(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_get_check_cancellable
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gpointer g_task_get_source_tag (GTask *task);
function g_task_get_source_tag(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_source_tag
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_60
!const gchar *g_task_get_name (GTask *task);
function g_task_get_name(task) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_get_name
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_is_valid (gpointer result, gpointer source_object);
function g_task_is_valid(result, source_object) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_is_valid
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
end function

! GLIB_AVAILABLE_IN_2_36
!void g_task_run_in_thread (GTask *task, GTaskThreadFunc task_func);
subroutine g_task_run_in_thread(task, task_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: task
  type(c_funptr), value :: task_func
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_run_in_thread_sync (GTask *task, GTaskThreadFunc task_func);
subroutine g_task_run_in_thread_sync(task, task_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: task
  type(c_funptr), value :: task_func
end subroutine

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_set_return_on_cancel (GTask *task, gboolean return_on_cancel);
function g_task_set_return_on_cancel(task, return_on_cancel) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_set_return_on_cancel
  type(c_ptr), value :: task
  integer(c_int), value :: return_on_cancel
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_get_return_on_cancel (GTask *task);
function g_task_get_return_on_cancel(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_get_return_on_cancel
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!void g_task_attach_source (GTask *task, GSource *source, GSourceFunc callback);
subroutine g_task_attach_source(task, source, callback) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: task
  type(c_ptr), value :: source
  type(c_funptr), value :: callback
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_return_pointer (GTask *task, gpointer result, GDestroyNotify result_destroy);
subroutine g_task_return_pointer(task, result, result_destroy) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: task
  type(c_ptr), value :: result
  type(c_funptr), value :: result_destroy
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_return_boolean (GTask *task, gboolean result);
subroutine g_task_return_boolean(task, result) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: task
  integer(c_int), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_return_int (GTask *task, gssize result);
subroutine g_task_return_int(task, result) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: task
  integer(c_size_t), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_task_return_error (GTask *task, GError *error);
subroutine g_task_return_error(task, error) bind(c)
  import :: c_ptr
  type(c_ptr), value :: task
  type(c_ptr), value :: error
end subroutine

! GLIB_AVAILABLE_IN_2_64
!void g_task_return_value (GTask *task, GValue *result);
subroutine g_task_return_value(task, result) bind(c)
  import :: c_ptr
  type(c_ptr), value :: task
  type(c_ptr), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_return_error_if_cancelled (GTask *task);
function g_task_return_error_if_cancelled(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_return_error_if_cancelled
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_36
!gpointer g_task_propagate_pointer (GTask *task, GError **error);
function g_task_propagate_pointer(task, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_task_propagate_pointer
  type(c_ptr), value :: task
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_propagate_boolean (GTask *task, GError **error);
function g_task_propagate_boolean(task, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_propagate_boolean
  type(c_ptr), value :: task
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_36
!gssize g_task_propagate_int (GTask *task, GError **error);
function g_task_propagate_int(task, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_task_propagate_int
  type(c_ptr), value :: task
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_64
!gboolean g_task_propagate_value (GTask *task, GValue *value, GError **error);
function g_task_propagate_value(task, value, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_propagate_value
  type(c_ptr), value :: task
  type(c_ptr), value :: value
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_36
!gboolean g_task_had_error (GTask *task);
function g_task_had_error(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_had_error
  type(c_ptr), value :: task
end function

! GLIB_AVAILABLE_IN_2_44
!gboolean g_task_get_completed (GTask *task);
function g_task_get_completed(task) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_task_get_completed
  type(c_ptr), value :: task
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gcredentials.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_credentials_get_type (void) G_GNUC_CONST;
function g_credentials_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_credentials_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GCredentials *g_credentials_new (void);
function g_credentials_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_credentials_new
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_credentials_to_string (GCredentials *credentials);
function g_credentials_to_string(credentials) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_credentials_to_string
  type(c_ptr), value :: credentials
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_credentials_get_native (GCredentials *credentials, GCredentialsType native_type);
function g_credentials_get_native(credentials, native_type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_credentials_get_native
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_credentials_set_native (GCredentials *credentials, GCredentialsType native_type, gpointer native);
subroutine g_credentials_set_native(credentials, native_type, native) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
  type(c_ptr), value :: native
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_credentials_is_same_user (GCredentials *credentials, GCredentials *other_credentials, GError **error);
function g_credentials_is_same_user(credentials, other_credentials, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_credentials_is_same_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: other_credentials
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!uid_t g_credentials_get_unix_user (GCredentials *credentials, GError **error);
function g_credentials_get_unix_user(credentials, error) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_credentials_get_unix_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_credentials_set_unix_user (GCredentials *credentials, uid_t uid, GError **error);
function g_credentials_set_unix_user(credentials, uid, error) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_credentials_set_unix_user
  type(c_ptr), value :: credentials
  integer(c_int32_t), value :: uid
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdtlsserverconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_48
!GType g_dtls_server_connection_get_type (void) G_GNUC_CONST;
function g_dtls_server_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dtls_server_connection_get_type
end function

! GLIB_AVAILABLE_IN_2_48
!GDatagramBased *g_dtls_server_connection_new (GDatagramBased *base_socket, GTlsCertificate *certificate, GError **error);
function g_dtls_server_connection_new(base_socket, certificate, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_server_connection_new
  type(c_ptr), value :: base_socket
  type(c_ptr), value :: certificate
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileoutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_output_stream_get_type (void) G_GNUC_CONST;
function g_file_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_output_stream_query_info (GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_output_stream_query_info(stream, attributes, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_output_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_output_stream_query_info_async (GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_output_stream_query_info_async(stream, attributes,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_output_stream_query_info_finish (GFileOutputStream *stream, GAsyncResult *result, GError **error);
function g_file_output_stream_query_info_finish(stream, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_output_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_output_stream_get_etag (GFileOutputStream *stream);
function g_file_output_stream_get_etag(stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_output_stream_get_etag
  type(c_ptr), value :: stream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdebugcontrollerdbus.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_72
!GDebugControllerDBus *g_debug_controller_dbus_new (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_debug_controller_dbus_new(connection, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_debug_controller_dbus_new
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_72
!void g_debug_controller_dbus_stop (GDebugControllerDBus *self);
subroutine g_debug_controller_dbus_stop(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsrvtarget.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_srv_target_get_type (void) G_GNUC_CONST;
function g_srv_target_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_srv_target_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSrvTarget *g_srv_target_new (const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
function g_srv_target_new(hostname, port, priority, weight) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_srv_target_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
  integer(c_int16_t), value :: priority
  integer(c_int16_t), value :: weight
end function

! GLIB_AVAILABLE_IN_ALL
!GSrvTarget *g_srv_target_copy (GSrvTarget *target);
function g_srv_target_copy(target) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_srv_target_copy
  type(c_ptr), value :: target
end function

! GLIB_AVAILABLE_IN_ALL
!void g_srv_target_free (GSrvTarget *target);
subroutine g_srv_target_free(target) bind(c)
  import :: c_ptr
  type(c_ptr), value :: target
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_srv_target_get_hostname (GSrvTarget *target);
function g_srv_target_get_hostname(target) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_srv_target_get_hostname
  type(c_ptr), value :: target
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_srv_target_get_port (GSrvTarget *target);
function g_srv_target_get_port(target) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_port
  type(c_ptr), value :: target
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_srv_target_get_priority (GSrvTarget *target);
function g_srv_target_get_priority(target) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_priority
  type(c_ptr), value :: target
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_srv_target_get_weight (GSrvTarget *target);
function g_srv_target_get_weight(target) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_weight
  type(c_ptr), value :: target
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_srv_target_list_sort (GList *targets);
function g_srv_target_list_sort(targets) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_srv_target_list_sort
  type(c_ptr), value :: targets
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/giomodule.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_30
!GIOModuleScope * g_io_module_scope_new (GIOModuleScopeFlags flags);
function g_io_module_scope_new(flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_io_module_scope_new
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_2_30
!void g_io_module_scope_free (GIOModuleScope *scope);
subroutine g_io_module_scope_free(scope) bind(c)
  import :: c_ptr
  type(c_ptr), value :: scope
end subroutine

! GLIB_AVAILABLE_IN_2_30
!void g_io_module_scope_block (GIOModuleScope *scope, const gchar *basename);
subroutine g_io_module_scope_block(scope, basename) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: scope
  character(kind=c_char), dimension(*) :: basename
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_io_module_get_type (void) G_GNUC_CONST;
function g_io_module_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_io_module_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIOModule *g_io_module_new (const gchar *filename);
function g_io_module_new(filename) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_module_new
  character(kind=c_char), dimension(*) :: filename
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_modules_scan_all_in_directory (const char *dirname);
subroutine g_io_modules_scan_all_in_directory(dirname) bind(c)
  import :: c_char
  character(kind=c_char), dimension(*) :: dirname
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList *g_io_modules_load_all_in_directory (const gchar *dirname);
function g_io_modules_load_all_in_directory(dirname) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_modules_load_all_in_directory
  character(kind=c_char), dimension(*) :: dirname
end function

! GLIB_AVAILABLE_IN_2_30
!void g_io_modules_scan_all_in_directory_with_scope (const gchar *dirname, GIOModuleScope *scope);
subroutine g_io_modules_scan_all_in_directory_with_scope(dirname, scope)&
& bind(c)
  import :: c_char, c_ptr
  character(kind=c_char), dimension(*) :: dirname
  type(c_ptr), value :: scope
end subroutine

! GLIB_AVAILABLE_IN_2_30
!GList *g_io_modules_load_all_in_directory_with_scope (const gchar *dirname, GIOModuleScope *scope);
function g_io_modules_load_all_in_directory_with_scope(dirname, scope) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_modules_load_all_in_directory_with_scope
  character(kind=c_char), dimension(*) :: dirname
  type(c_ptr), value :: scope
end function

! GLIB_AVAILABLE_IN_ALL
!GIOExtensionPoint *g_io_extension_point_register (const char *name);
function g_io_extension_point_register(name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_register
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GIOExtensionPoint *g_io_extension_point_lookup (const char *name);
function g_io_extension_point_lookup(name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_lookup
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_extension_point_set_required_type (GIOExtensionPoint *extension_point, GType type);
subroutine g_io_extension_point_set_required_type(extension_point, type)&
& bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: extension_point
  integer(c_size_t), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_io_extension_point_get_required_type (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_required_type(extension_point) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_point_get_required_type
  type(c_ptr), value :: extension_point
end function

! GLIB_AVAILABLE_IN_ALL
!GList *g_io_extension_point_get_extensions (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_extensions(extension_point) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_extension_point_get_extensions
  type(c_ptr), value :: extension_point
end function

! GLIB_AVAILABLE_IN_ALL
!GIOExtension * g_io_extension_point_get_extension_by_name (GIOExtensionPoint *extension_point, const char *name);
function g_io_extension_point_get_extension_by_name(extension_point, name)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_get_extension_by_name
  type(c_ptr), value :: extension_point
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GIOExtension * g_io_extension_point_implement (const char *extension_point_name, GType type, const char *extension_name, gint priority);
function g_io_extension_point_implement(extension_point_name, type,&
& extension_name, priority) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_io_extension_point_implement
  character(kind=c_char), dimension(*) :: extension_point_name
  integer(c_size_t), value :: type
  character(kind=c_char), dimension(*) :: extension_name
  integer(c_int), value :: priority
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_io_extension_get_type (GIOExtension *extension);
function g_io_extension_get_type(extension) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_get_type
  type(c_ptr), value :: extension
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_io_extension_get_name (GIOExtension *extension);
function g_io_extension_get_name(extension) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_extension_get_name
  type(c_ptr), value :: extension
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_io_extension_get_priority (GIOExtension *extension);
function g_io_extension_get_priority(extension) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_io_extension_get_priority
  type(c_ptr), value :: extension
end function

! GLIB_AVAILABLE_IN_ALL
!GTypeClass* g_io_extension_ref_class (GIOExtension *extension);
function g_io_extension_ref_class(extension) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_extension_ref_class
  type(c_ptr), value :: extension
end function

! GLIB_AVAILABLE_IN_ALL
!void g_io_module_load (GIOModule *module);
subroutine g_io_module_load(module) bind(c)
  import :: c_ptr
  type(c_ptr), value :: module
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_io_module_unload (GIOModule *module);
subroutine g_io_module_unload(module) bind(c)
  import :: c_ptr
  type(c_ptr), value :: module
end subroutine

! GLIB_AVAILABLE_IN_ALL
!char **g_io_module_query (void);
function g_io_module_query() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_io_module_query
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/ginetaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_inet_address_get_type (void) G_GNUC_CONST;
function g_inet_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_inet_address_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GInetAddress * g_inet_address_new_from_string (const gchar *string);
function g_inet_address_new_from_string(string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_inet_address_new_from_string
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!GInetAddress * g_inet_address_new_from_bytes (const guint8 *bytes, GSocketFamily family);
function g_inet_address_new_from_bytes(bytes, family) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_from_bytes
  type(c_ptr), value :: bytes
  integer(c_int), value :: family
end function

! GLIB_AVAILABLE_IN_ALL
!GInetAddress * g_inet_address_new_loopback (GSocketFamily family);
function g_inet_address_new_loopback(family) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_loopback
  integer(c_int), value :: family
end function

! GLIB_AVAILABLE_IN_ALL
!GInetAddress * g_inet_address_new_any (GSocketFamily family);
function g_inet_address_new_any(family) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_any
  integer(c_int), value :: family
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_equal (GInetAddress *address, GInetAddress *other_address);
function g_inet_address_equal(address, other_address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_equal
  type(c_ptr), value :: address
  type(c_ptr), value :: other_address
end function

! GLIB_AVAILABLE_IN_ALL
!gchar * g_inet_address_to_string (GInetAddress *address);
function g_inet_address_to_string(address) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_inet_address_to_string
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!const guint8 * g_inet_address_to_bytes (GInetAddress *address);
function g_inet_address_to_bytes(address) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_inet_address_to_bytes
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_inet_address_get_native_size (GInetAddress *address);
function g_inet_address_get_native_size(address) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_inet_address_get_native_size
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketFamily g_inet_address_get_family (GInetAddress *address);
function g_inet_address_get_family(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_family
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_any (GInetAddress *address);
function g_inet_address_get_is_any(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_any
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_loopback (GInetAddress *address);
function g_inet_address_get_is_loopback(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_loopback
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_link_local (GInetAddress *address);
function g_inet_address_get_is_link_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_link_local
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_site_local (GInetAddress *address);
function g_inet_address_get_is_site_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_site_local
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_multicast (GInetAddress *address);
function g_inet_address_get_is_multicast(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_multicast
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_mc_global (GInetAddress *address);
function g_inet_address_get_is_mc_global(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_global
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_mc_link_local (GInetAddress *address);
function g_inet_address_get_is_mc_link_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_link_local
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_mc_node_local (GInetAddress *address);
function g_inet_address_get_is_mc_node_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_node_local
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_mc_org_local (GInetAddress *address);
function g_inet_address_get_is_mc_org_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_org_local
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_inet_address_get_is_mc_site_local (GInetAddress *address);
function g_inet_address_get_is_mc_site_local(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_site_local
  type(c_ptr), value :: address
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gvfs.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_vfs_get_type (void) G_GNUC_CONST;
function g_vfs_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_vfs_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_vfs_is_active (GVfs *vfs);
function g_vfs_is_active(vfs) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_vfs_is_active
  type(c_ptr), value :: vfs
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_vfs_get_file_for_path (GVfs *vfs, const char *path);
function g_vfs_get_file_for_path(vfs, path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_path
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_vfs_get_file_for_uri (GVfs *vfs, const char *uri);
function g_vfs_get_file_for_uri(vfs, uri) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_uri
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: uri
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar* const * g_vfs_get_supported_uri_schemes (GVfs *vfs);
function g_vfs_get_supported_uri_schemes(vfs) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_vfs_get_supported_uri_schemes
  type(c_ptr), value :: vfs
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_vfs_parse_name (GVfs *vfs, const char *parse_name);
function g_vfs_parse_name(vfs, parse_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_vfs_parse_name
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: parse_name
end function

! GLIB_AVAILABLE_IN_ALL
!GVfs * g_vfs_get_default (void);
function g_vfs_get_default() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_vfs_get_default
end function

! GLIB_AVAILABLE_IN_ALL
!GVfs * g_vfs_get_local (void);
function g_vfs_get_local() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_vfs_get_local
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_vfs_register_uri_scheme (GVfs *vfs, const char *scheme, GVfsFileLookupFunc uri_func, gpointer uri_data, GDestroyNotify uri_destroy, GVfsFileLookupFunc parse_name_func, gpointer parse_name_data, GDestroyNotify parse_name_destroy);
function g_vfs_register_uri_scheme(vfs, scheme, uri_func, uri_data,&
& uri_destroy, parse_name_func, parse_name_data, parse_name_destroy) bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_vfs_register_uri_scheme
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: scheme
  type(c_funptr), value :: uri_func
  type(c_ptr), value :: uri_data
  type(c_funptr), value :: uri_destroy
  type(c_funptr), value :: parse_name_func
  type(c_ptr), value :: parse_name_data
  type(c_funptr), value :: parse_name_destroy
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_vfs_unregister_uri_scheme (GVfs *vfs, const char *scheme);
function g_vfs_unregister_uri_scheme(vfs, scheme) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_vfs_unregister_uri_scheme
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: scheme
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gio.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gio/gconverteroutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_converter_output_stream_get_type (void) G_GNUC_CONST;
function g_converter_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_converter_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GOutputStream *g_converter_output_stream_new (GOutputStream *base_stream, GConverter *converter);
function g_converter_output_stream_new(base_stream, converter) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_converter_output_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GLIB_AVAILABLE_IN_ALL
!GConverter *g_converter_output_stream_get_converter (GConverterOutputStream *converter_stream);
function g_converter_output_stream_get_converter(converter_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_converter_output_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gpollableoutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_pollable_output_stream_get_type (void) G_GNUC_CONST;
function g_pollable_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_pollable_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pollable_output_stream_can_poll (GPollableOutputStream *stream);
function g_pollable_output_stream_can_poll(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pollable_output_stream_can_poll
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_pollable_output_stream_is_writable (GPollableOutputStream *stream);
function g_pollable_output_stream_is_writable(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_pollable_output_stream_is_writable
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!GSource *g_pollable_output_stream_create_source (GPollableOutputStream *stream, GCancellable *cancellable);
function g_pollable_output_stream_create_source(stream, cancellable) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_pollable_output_stream_create_source
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_pollable_output_stream_write_nonblocking (GPollableOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_pollable_output_stream_write_nonblocking(stream, buffer, count,&
& cancellable, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_pollable_output_stream_write_nonblocking
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!GPollableReturn g_pollable_output_stream_writev_nonblocking (GPollableOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_pollable_output_stream_writev_nonblocking(stream, vectors,&
& n_vectors, bytes_written, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_pollable_output_stream_writev_nonblocking
  type(c_ptr), value :: stream
  type(c_ptr), value :: vectors
  integer(c_size_t), value :: n_vectors
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gthreadedsocketservice.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_threaded_socket_service_get_type (void);
function g_threaded_socket_service_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_threaded_socket_service_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketService * g_threaded_socket_service_new (int max_threads);
function g_threaded_socket_service_new(max_threads) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_threaded_socket_service_new
  integer(c_int), value :: max_threads
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsocketaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_socket_address_get_type (void) G_GNUC_CONST;
function g_socket_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_socket_address_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketFamily g_socket_address_get_family (GSocketAddress *address);
function g_socket_address_get_family(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_socket_address_get_family
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress * g_socket_address_new_from_native (gpointer native, gsize len);
function g_socket_address_new_from_native(native, len) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_socket_address_new_from_native
  type(c_ptr), value :: native
  integer(c_size_t), value :: len
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_socket_address_to_native (GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
function g_socket_address_to_native(address, dest, destlen, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_socket_address_to_native
  type(c_ptr), value :: address
  type(c_ptr), value :: dest
  integer(c_size_t), value :: destlen
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_socket_address_get_native_size (GSocketAddress *address);
function g_socket_address_get_native_size(address) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_address_get_native_size
  type(c_ptr), value :: address
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusnamewatching.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!guint g_bus_watch_name (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name(bus_type, name, flags, name_appeared_handler,&
& name_vanished_handler, user_data, user_data_free_func) bind(c)
  import :: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_watch_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_watch_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name_on_connection(connection, name, flags,&
& name_appeared_handler, name_vanished_handler, user_data, user_data_free_func)&
& bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_watch_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_watch_name_with_closures (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_with_closures(bus_type, name, flags,&
& name_appeared_closure, name_vanished_closure) bind(c)
  import :: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_watch_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_bus_watch_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_on_connection_with_closures(connection, name, flags,&
& name_appeared_closure, name_vanished_closure) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_watch_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! GLIB_AVAILABLE_IN_ALL
!void g_bus_unwatch_name (guint watcher_id);
subroutine g_bus_unwatch_name(watcher_id) bind(c)
  import :: c_int
  integer(c_int), value :: watcher_id
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/ginetaddressmask.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_32
!GType g_inet_address_mask_get_type (void) G_GNUC_CONST;
function g_inet_address_mask_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_inet_address_mask_get_type
end function

! GLIB_AVAILABLE_IN_2_32
!GInetAddressMask *g_inet_address_mask_new (GInetAddress *addr, guint length, GError **error);
function g_inet_address_mask_new(addr, length, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_inet_address_mask_new
  type(c_ptr), value :: addr
  integer(c_int), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!GInetAddressMask *g_inet_address_mask_new_from_string (const gchar *mask_string, GError **error);
function g_inet_address_mask_new_from_string(mask_string, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_inet_address_mask_new_from_string
  character(kind=c_char), dimension(*) :: mask_string
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!gchar *g_inet_address_mask_to_string (GInetAddressMask *mask);
function g_inet_address_mask_to_string(mask) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_inet_address_mask_to_string
  type(c_ptr), value :: mask
end function

! GLIB_AVAILABLE_IN_2_32
!GSocketFamily g_inet_address_mask_get_family (GInetAddressMask *mask);
function g_inet_address_mask_get_family(mask) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_mask_get_family
  type(c_ptr), value :: mask
end function

! GLIB_AVAILABLE_IN_2_32
!GInetAddress *g_inet_address_mask_get_address (GInetAddressMask *mask);
function g_inet_address_mask_get_address(mask) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_inet_address_mask_get_address
  type(c_ptr), value :: mask
end function

! GLIB_AVAILABLE_IN_2_32
!guint g_inet_address_mask_get_length (GInetAddressMask *mask);
function g_inet_address_mask_get_length(mask) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_mask_get_length
  type(c_ptr), value :: mask
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_inet_address_mask_matches (GInetAddressMask *mask, GInetAddress *address);
function g_inet_address_mask_matches(mask, address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_mask_matches
  type(c_ptr), value :: mask
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_2_32
!gboolean g_inet_address_mask_equal (GInetAddressMask *mask, GInetAddressMask *mask2);
function g_inet_address_mask_equal(mask, mask2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_inet_address_mask_equal
  type(c_ptr), value :: mask
  type(c_ptr), value :: mask2
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdebugcontroller.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_72
!gboolean g_debug_controller_get_debug_enabled (GDebugController *self);
function g_debug_controller_get_debug_enabled(self) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_debug_controller_get_debug_enabled
  type(c_ptr), value :: self
end function

! GLIB_AVAILABLE_IN_2_72
!void g_debug_controller_set_debug_enabled (GDebugController *self, gboolean debug_enabled);
subroutine g_debug_controller_set_debug_enabled(self, debug_enabled) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: debug_enabled
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gsimpleproxyresolver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_36
!GType g_simple_proxy_resolver_get_type (void) G_GNUC_CONST;
function g_simple_proxy_resolver_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_simple_proxy_resolver_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GProxyResolver *g_simple_proxy_resolver_new (const gchar *default_proxy, gchar **ignore_hosts);
function g_simple_proxy_resolver_new(default_proxy, ignore_hosts) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_simple_proxy_resolver_new
  character(kind=c_char), dimension(*) :: default_proxy
  type(c_ptr), dimension(*) :: ignore_hosts
end function

! GLIB_AVAILABLE_IN_2_36
!void g_simple_proxy_resolver_set_default_proxy (GSimpleProxyResolver *resolver, const gchar *default_proxy);
subroutine g_simple_proxy_resolver_set_default_proxy(resolver, default_proxy)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: default_proxy
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_simple_proxy_resolver_set_ignore_hosts (GSimpleProxyResolver *resolver, gchar **ignore_hosts);
subroutine g_simple_proxy_resolver_set_ignore_hosts(resolver, ignore_hosts)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: resolver
  type(c_ptr), dimension(*) :: ignore_hosts
end subroutine

! GLIB_AVAILABLE_IN_2_36
!void g_simple_proxy_resolver_set_uri_proxy (GSimpleProxyResolver *resolver, const gchar *uri_scheme, const gchar *proxy);
subroutine g_simple_proxy_resolver_set_uri_proxy(resolver, uri_scheme, proxy)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri_scheme
  character(kind=c_char), dimension(*) :: proxy
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdrive.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_drive_get_type (void) G_GNUC_CONST;
function g_drive_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_drive_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_drive_get_name (GDrive *drive);
function g_drive_get_name(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_get_name
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_drive_get_icon (GDrive *drive);
function g_drive_get_icon(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_get_icon
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_drive_get_symbolic_icon (GDrive *drive);
function g_drive_get_symbolic_icon(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_get_symbolic_icon
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_has_volumes (GDrive *drive);
function g_drive_has_volumes(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_has_volumes
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!GList * g_drive_get_volumes (GDrive *drive);
function g_drive_get_volumes(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_get_volumes
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_2_50
!gboolean g_drive_is_removable (GDrive *drive);
function g_drive_is_removable(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_is_removable
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_is_media_removable (GDrive *drive);
function g_drive_is_media_removable(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_is_media_removable
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_has_media (GDrive *drive);
function g_drive_has_media(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_has_media
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_is_media_check_automatic (GDrive *drive);
function g_drive_is_media_check_automatic(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_is_media_check_automatic
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_can_poll_for_media (GDrive *drive);
function g_drive_can_poll_for_media(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_can_poll_for_media
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_can_eject (GDrive *drive);
function g_drive_can_eject(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_can_eject
  type(c_ptr), value :: drive
end function

! GLIB_DEPRECATED_FOR(g_drive_eject_with_operation)
!void g_drive_eject (GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject(drive, flags, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_drive_eject_with_operation_finish)
!gboolean g_drive_eject_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_finish(drive, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_eject_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_drive_poll_for_media (GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_poll_for_media(drive, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: drive
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_poll_for_media_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_poll_for_media_finish(drive, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_poll_for_media_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_drive_get_identifier (GDrive *drive, const char *kind);
function g_drive_get_identifier(drive, kind) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_drive_get_identifier
  type(c_ptr), value :: drive
  character(kind=c_char), dimension(*) :: kind
end function

! GLIB_AVAILABLE_IN_ALL
!char ** g_drive_enumerate_identifiers (GDrive *drive);
function g_drive_enumerate_identifiers(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_enumerate_identifiers
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!GDriveStartStopType g_drive_get_start_stop_type (GDrive *drive);
function g_drive_get_start_stop_type(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_get_start_stop_type
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_can_start (GDrive *drive);
function g_drive_can_start(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_can_start
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_can_start_degraded (GDrive *drive);
function g_drive_can_start_degraded(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_can_start_degraded
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!void g_drive_start (GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_start(drive, flags, mount_operation, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_start_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_start_finish(drive, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_start_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_can_stop (GDrive *drive);
function g_drive_can_stop(drive) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_can_stop
  type(c_ptr), value :: drive
end function

! GLIB_AVAILABLE_IN_ALL
!void g_drive_stop (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_stop(drive, flags, mount_operation, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_stop_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_stop_finish(drive, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_stop_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_drive_eject_with_operation (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject_with_operation(drive, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_drive_eject_with_operation_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_with_operation_finish(drive, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_drive_eject_with_operation_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!const gchar *g_drive_get_sort_key (GDrive *drive);
function g_drive_get_sort_key(drive) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_drive_get_sort_key
  type(c_ptr), value :: drive
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gioerror.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_io_error_quark (void);
function g_io_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_io_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GIOErrorEnum g_io_error_from_errno (gint err_no);
function g_io_error_from_errno(err_no) bind(c)
  import :: c_int
  integer(c_int) :: g_io_error_from_errno
  integer(c_int), value :: err_no
end function

! GLIB_AVAILABLE_IN_ALL
!GIOErrorEnum g_io_error_from_win32_error (gint error_code);
function g_io_error_from_win32_error(error_code) bind(c)
  import :: c_int
  integer(c_int) :: g_io_error_from_win32_error
  integer(c_int), value :: error_code
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/goutputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_output_stream_get_type (void) G_GNUC_CONST;
function g_output_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_output_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_output_stream_write (GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_output_stream_write(stream, buffer, count, cancellable, error)&
& bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_output_stream_write_all(stream, buffer, count, bytes_written,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_output_stream_write_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!gboolean g_output_stream_writev (GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_output_stream_writev(stream, vectors, n_vectors, bytes_written,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_output_stream_writev
  type(c_ptr), value :: stream
  type(c_ptr), value :: vectors
  integer(c_size_t), value :: n_vectors
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!gboolean g_output_stream_writev_all (GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_output_stream_writev_all(stream, vectors, n_vectors, bytes_written,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_output_stream_writev_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: vectors
  integer(c_size_t), value :: n_vectors
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_40
!gboolean g_output_stream_vprintf (GOutputStream *stream, gsize *bytes_written, GCancellable *cancellable, GError **error, const gchar *format, va_list args) G_GNUC_PRINTF (5, 0);
function g_output_stream_vprintf(stream, bytes_written, cancellable, error,&
& format, args) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_output_stream_vprintf
  type(c_ptr), value :: stream
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_2_34
!gssize g_output_stream_write_bytes (GOutputStream *stream, GBytes *bytes, GCancellable *cancellable, GError **error);
function g_output_stream_write_bytes(stream, bytes, cancellable, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write_bytes
  type(c_ptr), value :: stream
  type(c_ptr), value :: bytes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gssize g_output_stream_splice (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
function g_output_stream_splice(stream, source, flags, cancellable, error)&
& bind(c)
  import :: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_output_stream_splice
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_flush (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_flush(stream, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_flush
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_close (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_close(stream, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_output_stream_write_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_write_async(stream, buffer, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gssize g_output_stream_write_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_write_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_44
!void g_output_stream_write_all_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_write_all_async(stream, buffer, count, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_44
!gboolean g_output_stream_write_all_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
function g_output_stream_write_all_finish(stream, result, bytes_written, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_write_all_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!void g_output_stream_writev_async (GOutputStream *stream, const GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_writev_async(stream, vectors, n_vectors,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: vectors
  integer(c_size_t), value :: n_vectors
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_60
!gboolean g_output_stream_writev_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
function g_output_stream_writev_finish(stream, result, bytes_written, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_writev_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!void g_output_stream_writev_all_async (GOutputStream *stream, GOutputVector *vectors, gsize n_vectors, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_writev_all_async(stream, vectors, n_vectors,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: vectors
  integer(c_size_t), value :: n_vectors
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_60
!gboolean g_output_stream_writev_all_finish (GOutputStream *stream, GAsyncResult *result, gsize *bytes_written, GError **error);
function g_output_stream_writev_all_finish(stream, result, bytes_written,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_writev_all_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!void g_output_stream_write_bytes_async (GOutputStream *stream, GBytes *bytes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_write_bytes_async(stream, bytes, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: bytes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_34
!gssize g_output_stream_write_bytes_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_write_bytes_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write_bytes_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_output_stream_splice_async (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_splice_async(stream, source, flags, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gssize g_output_stream_splice_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_splice_finish(stream, result, error) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_splice_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_output_stream_flush_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_flush_async(stream, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_flush_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_flush_finish(stream, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_flush_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_output_stream_close_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_close_async(stream, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_close_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_close_finish(stream, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_is_closed (GOutputStream *stream);
function g_output_stream_is_closed(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_is_closed
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_is_closing (GOutputStream *stream);
function g_output_stream_is_closing(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_is_closing
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_has_pending (GOutputStream *stream);
function g_output_stream_has_pending(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_has_pending
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_output_stream_set_pending (GOutputStream *stream, GError **error);
function g_output_stream_set_pending(stream, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_output_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_output_stream_clear_pending (GOutputStream *stream);
subroutine g_output_stream_clear_pending(stream) bind(c)
  import :: c_ptr
  type(c_ptr), value :: stream
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnetworkaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_network_address_get_type (void) G_GNUC_CONST;
function g_network_address_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_network_address_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnectable *g_network_address_new (const gchar *hostname, guint16 port);
function g_network_address_new(hostname, port) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
end function

! GLIB_AVAILABLE_IN_2_44
!GSocketConnectable *g_network_address_new_loopback (guint16 port);
function g_network_address_new_loopback(port) bind(c)
  import :: c_ptr, c_int16_t
  type(c_ptr) :: g_network_address_new_loopback
  integer(c_int16_t), value :: port
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnectable *g_network_address_parse (const gchar *host_and_port, guint16 default_port, GError **error);
function g_network_address_parse(host_and_port, default_port, error) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnectable *g_network_address_parse_uri (const gchar *uri, guint16 default_port, GError **error);
function g_network_address_parse_uri(uri, default_port, error) bind(c)
  import :: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse_uri
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_address_get_hostname (GNetworkAddress *addr);
function g_network_address_get_hostname(addr) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_address_get_hostname
  type(c_ptr), value :: addr
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_network_address_get_port (GNetworkAddress *addr);
function g_network_address_get_port(addr) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_network_address_get_port
  type(c_ptr), value :: addr
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_network_address_get_scheme (GNetworkAddress *addr);
function g_network_address_get_scheme(addr) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_network_address_get_scheme
  type(c_ptr), value :: addr
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gcharsetconverter.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_charset_converter_get_type (void) G_GNUC_CONST;
function g_charset_converter_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_charset_converter_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GCharsetConverter *g_charset_converter_new (const gchar *to_charset, const gchar *from_charset, GError **error);
function g_charset_converter_new(to_charset, from_charset, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_charset_converter_new
  character(kind=c_char), dimension(*) :: to_charset
  character(kind=c_char), dimension(*) :: from_charset
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_charset_converter_set_use_fallback (GCharsetConverter *converter, gboolean use_fallback);
subroutine g_charset_converter_set_use_fallback(converter, use_fallback)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: converter
  integer(c_int), value :: use_fallback
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_charset_converter_get_use_fallback (GCharsetConverter *converter);
function g_charset_converter_get_use_fallback(converter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_charset_converter_get_use_fallback
  type(c_ptr), value :: converter
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_charset_converter_get_num_fallbacks (GCharsetConverter *converter);
function g_charset_converter_get_num_fallbacks(converter) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_charset_converter_get_num_fallbacks
  type(c_ptr), value :: converter
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtcpconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tcp_connection_get_type (void) G_GNUC_CONST;
function g_tcp_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tcp_connection_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tcp_connection_set_graceful_disconnect (GTcpConnection *connection, gboolean graceful_disconnect);
subroutine g_tcp_connection_set_graceful_disconnect(connection,&
& graceful_disconnect) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: graceful_disconnect
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_tcp_connection_get_graceful_disconnect (GTcpConnection *connection);
function g_tcp_connection_get_graceful_disconnect(connection) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tcp_connection_get_graceful_disconnect
  type(c_ptr), value :: connection
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/glistmodel.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_44
!GType g_list_model_get_item_type (GListModel *list);
function g_list_model_get_item_type(list) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_list_model_get_item_type
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_2_44
!guint g_list_model_get_n_items (GListModel *list);
function g_list_model_get_n_items(list) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_list_model_get_n_items
  type(c_ptr), value :: list
end function

! GLIB_AVAILABLE_IN_2_44
!gpointer g_list_model_get_item (GListModel *list, guint position);
function g_list_model_get_item(list, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_model_get_item
  type(c_ptr), value :: list
  integer(c_int), value :: position
end function

! GLIB_AVAILABLE_IN_2_44
!GObject * g_list_model_get_object (GListModel *list, guint position);
function g_list_model_get_object(list, position) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_list_model_get_object
  type(c_ptr), value :: list
  integer(c_int), value :: position
end function

! GLIB_AVAILABLE_IN_2_44
!void g_list_model_items_changed (GListModel *list, guint position, guint removed, guint added);
subroutine g_list_model_items_changed(list, position, removed, added) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: position
  integer(c_int), value :: removed
  integer(c_int), value :: added
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdtlsconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_48
!GType g_dtls_connection_get_type (void) G_GNUC_CONST;
function g_dtls_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dtls_connection_get_type
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_set_database (GDtlsConnection *conn, GTlsDatabase *database);
subroutine g_dtls_connection_set_database(conn, database) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: database
end subroutine

! GLIB_AVAILABLE_IN_2_48
!GTlsDatabase *g_dtls_connection_get_database (GDtlsConnection *conn);
function g_dtls_connection_get_database(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_database
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_set_certificate (GDtlsConnection *conn, GTlsCertificate *certificate);
subroutine g_dtls_connection_set_certificate(conn, certificate) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: certificate
end subroutine

! GLIB_AVAILABLE_IN_2_48
!GTlsCertificate *g_dtls_connection_get_certificate (GDtlsConnection *conn);
function g_dtls_connection_get_certificate(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_certificate
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_set_interaction (GDtlsConnection *conn, GTlsInteraction *interaction);
subroutine g_dtls_connection_set_interaction(conn, interaction) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: interaction
end subroutine

! GLIB_AVAILABLE_IN_2_48
!GTlsInteraction *g_dtls_connection_get_interaction (GDtlsConnection *conn);
function g_dtls_connection_get_interaction(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_interaction
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!GTlsCertificate *g_dtls_connection_get_peer_certificate (GDtlsConnection *conn);
function g_dtls_connection_get_peer_certificate(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_peer_certificate
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!GTlsCertificateFlags g_dtls_connection_get_peer_certificate_errors (GDtlsConnection *conn);
function g_dtls_connection_get_peer_certificate_errors(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_get_peer_certificate_errors
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_set_require_close_notify (GDtlsConnection *conn, gboolean require_close_notify);
subroutine g_dtls_connection_set_require_close_notify(conn,&
& require_close_notify) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: require_close_notify
end subroutine

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_get_require_close_notify (GDtlsConnection *conn);
function g_dtls_connection_get_require_close_notify(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_get_require_close_notify
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_handshake (GDtlsConnection *conn, GCancellable *cancellable, GError **error);
function g_dtls_connection_handshake(conn, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_handshake
  type(c_ptr), value :: conn
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_handshake_async (GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dtls_connection_handshake_async(conn, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: conn
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_handshake_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
function g_dtls_connection_handshake_finish(conn, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_handshake_finish
  type(c_ptr), value :: conn
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_shutdown (GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, GCancellable *cancellable, GError **error);
function g_dtls_connection_shutdown(conn, shutdown_read, shutdown_write,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_shutdown
  type(c_ptr), value :: conn
  integer(c_int), value :: shutdown_read
  integer(c_int), value :: shutdown_write
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_shutdown_async (GDtlsConnection *conn, gboolean shutdown_read, gboolean shutdown_write, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dtls_connection_shutdown_async(conn, shutdown_read,&
& shutdown_write, io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: conn
  integer(c_int), value :: shutdown_read
  integer(c_int), value :: shutdown_write
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_shutdown_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
function g_dtls_connection_shutdown_finish(conn, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_shutdown_finish
  type(c_ptr), value :: conn
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_close (GDtlsConnection *conn, GCancellable *cancellable, GError **error);
function g_dtls_connection_close(conn, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_close
  type(c_ptr), value :: conn
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!void g_dtls_connection_close_async (GDtlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dtls_connection_close_async(conn, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: conn
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_close_finish (GDtlsConnection *conn, GAsyncResult *result, GError **error);
function g_dtls_connection_close_finish(conn, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_close_finish
  type(c_ptr), value :: conn
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_48
!gboolean g_dtls_connection_emit_accept_certificate (GDtlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
function g_dtls_connection_emit_accept_certificate(conn, peer_cert, errors)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_emit_accept_certificate
  type(c_ptr), value :: conn
  type(c_ptr), value :: peer_cert
  integer(c_int), value :: errors
end function

! GLIB_AVAILABLE_IN_2_60
!void g_dtls_connection_set_advertised_protocols (GDtlsConnection *conn, const gchar * const *protocols);
subroutine g_dtls_connection_set_advertised_protocols(conn, protocols) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: conn
  character(kind=c_char), dimension(*) :: protocols
end subroutine

! GLIB_AVAILABLE_IN_2_60
!const gchar * g_dtls_connection_get_negotiated_protocol (GDtlsConnection *conn);
function g_dtls_connection_get_negotiated_protocol(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_negotiated_protocol
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_dtls_connection_get_channel_binding_data (GDtlsConnection *conn, GTlsChannelBindingType type, GByteArray *data, GError **error);
function g_dtls_connection_get_channel_binding_data(conn, type, data, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_get_channel_binding_data
  type(c_ptr), value :: conn
  integer(c_int), value :: type
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_70
!GTlsProtocolVersion g_dtls_connection_get_protocol_version (GDtlsConnection *conn);
function g_dtls_connection_get_protocol_version(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dtls_connection_get_protocol_version
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_70
!gchar * g_dtls_connection_get_ciphersuite_name (GDtlsConnection *conn);
function g_dtls_connection_get_ciphersuite_name(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dtls_connection_get_ciphersuite_name
  type(c_ptr), value :: conn
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gasyncresult.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_async_result_get_type (void) G_GNUC_CONST;
function g_async_result_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_async_result_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_async_result_get_user_data (GAsyncResult *res);
function g_async_result_get_user_data(res) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_result_get_user_data
  type(c_ptr), value :: res
end function

! GLIB_AVAILABLE_IN_ALL
!GObject *g_async_result_get_source_object (GAsyncResult *res);
function g_async_result_get_source_object(res) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_async_result_get_source_object
  type(c_ptr), value :: res
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_async_result_legacy_propagate_error (GAsyncResult *res, GError **error);
function g_async_result_legacy_propagate_error(res, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_result_legacy_propagate_error
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_async_result_is_tagged (GAsyncResult *res, gpointer source_tag);
function g_async_result_is_tagged(res, source_tag) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_async_result_is_tagged
  type(c_ptr), value :: res
  type(c_ptr), value :: source_tag
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gzlibcompressor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_zlib_compressor_get_type (void) G_GNUC_CONST;
function g_zlib_compressor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_zlib_compressor_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GZlibCompressor *g_zlib_compressor_new (GZlibCompressorFormat format, int level);
function g_zlib_compressor_new(format, level) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_zlib_compressor_new
  integer(c_int), value :: format
  integer(c_int), value :: level
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_zlib_compressor_get_file_info (GZlibCompressor *compressor);
function g_zlib_compressor_get_file_info(compressor) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_zlib_compressor_get_file_info
  type(c_ptr), value :: compressor
end function

! GLIB_AVAILABLE_IN_ALL
!void g_zlib_compressor_set_file_info (GZlibCompressor *compressor, GFileInfo *file_info);
subroutine g_zlib_compressor_set_file_info(compressor, file_info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: compressor
  type(c_ptr), value :: file_info
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_manager_server_get_type (void) G_GNUC_CONST;
function g_dbus_object_manager_server_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_manager_server_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectManagerServer *g_dbus_object_manager_server_new (const gchar *object_path);
function g_dbus_object_manager_server_new(object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_manager_server_new
  character(kind=c_char), dimension(*) :: object_path
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_object_manager_server_get_connection (GDBusObjectManagerServer *manager);
function g_dbus_object_manager_server_get_connection(manager) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_manager_server_get_connection
  type(c_ptr), value :: manager
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_manager_server_set_connection (GDBusObjectManagerServer *manager, GDBusConnection *connection);
subroutine g_dbus_object_manager_server_set_connection(manager, connection)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: manager
  type(c_ptr), value :: connection
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_manager_server_export (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
subroutine g_dbus_object_manager_server_export(manager, object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: manager
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_object_manager_server_export_uniquely (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
subroutine g_dbus_object_manager_server_export_uniquely(manager, object)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: manager
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_object_manager_server_is_exported (GDBusObjectManagerServer *manager, GDBusObjectSkeleton *object);
function g_dbus_object_manager_server_is_exported(manager, object) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_object_manager_server_is_exported
  type(c_ptr), value :: manager
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_object_manager_server_unexport (GDBusObjectManagerServer *manager, const gchar *object_path);
function g_dbus_object_manager_server_unexport(manager, object_path) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_object_manager_server_unexport
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: object_path
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusobjectproxy.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_object_proxy_get_type (void) G_GNUC_CONST;
function g_dbus_object_proxy_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_object_proxy_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusObjectProxy *g_dbus_object_proxy_new (GDBusConnection *connection, const gchar *object_path);
function g_dbus_object_proxy_new(connection, object_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_object_proxy_new
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusConnection *g_dbus_object_proxy_get_connection (GDBusObjectProxy *proxy);
function g_dbus_object_proxy_get_connection(proxy) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_object_proxy_get_connection
  type(c_ptr), value :: proxy
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileinputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_input_stream_get_type (void) G_GNUC_CONST;
function g_file_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_input_stream_query_info (GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_input_stream_query_info(stream, attributes, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_input_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_input_stream_query_info_async (GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_input_stream_query_info_async(stream, attributes,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInfo *g_file_input_stream_query_info_finish (GFileInputStream *stream, GAsyncResult *result, GError **error);
function g_file_input_stream_query_info_finish(stream, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_input_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbuserror.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GQuark g_dbus_error_quark (void);
function g_dbus_error_quark() bind(c)
  import :: c_int32_t
  integer(c_int32_t) :: g_dbus_error_quark
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_error_is_remote_error (const GError *error);
function g_dbus_error_is_remote_error(error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_error_is_remote_error
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_error_get_remote_error (const GError *error);
function g_dbus_error_get_remote_error(error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_error_get_remote_error
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_error_strip_remote_error (GError *error);
function g_dbus_error_strip_remote_error(error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_error_strip_remote_error
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_error_register_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_register_error(error_domain, error_code, dbus_error_name)&
& bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_dbus_error_register_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_error_unregister_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_unregister_error(error_domain, error_code,&
& dbus_error_name) bind(c)
  import :: c_int, c_int32_t, c_char
  integer(c_int) :: g_dbus_error_unregister_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_error_register_error_domain (const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
subroutine g_dbus_error_register_error_domain(error_domain_quark_name,&
& quark_volatile, entries, num_entries) bind(c)
  import :: c_char, c_ptr, c_int
  character(kind=c_char), dimension(*) :: error_domain_quark_name
  type(c_ptr), value :: quark_volatile
  integer(c_int), value :: entries
  integer(c_int), value :: num_entries
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GError *g_dbus_error_new_for_dbus_error (const gchar *dbus_error_name, const gchar *dbus_error_message);
function g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_error_new_for_dbus_error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_error_set_dbus_error_valist (GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args) G_GNUC_PRINTF(4, 0);
subroutine g_dbus_error_set_dbus_error_valist(error, dbus_error_name,&
& dbus_error_message, format, var_args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_error_encode_gerror (const GError *error);
function g_dbus_error_encode_gerror(error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_error_encode_gerror
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusutils.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_guid (const gchar *string);
function g_dbus_is_guid(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_guid
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gchar *g_dbus_generate_guid (void);
function g_dbus_generate_guid() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_generate_guid
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_name (const gchar *string);
function g_dbus_is_name(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_name
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_unique_name (const gchar *string);
function g_dbus_is_unique_name(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_unique_name
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_member_name (const gchar *string);
function g_dbus_is_member_name(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_member_name
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_is_interface_name (const gchar *string);
function g_dbus_is_interface_name(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_interface_name
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_2_70
!gboolean g_dbus_is_error_name (const gchar *string);
function g_dbus_is_error_name(string) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_dbus_is_error_name
  character(kind=c_char), dimension(*) :: string
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_gvariant_to_gvalue (GVariant *value, GValue *out_gvalue);
subroutine g_dbus_gvariant_to_gvalue(value, out_gvalue) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: out_gvalue
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant *g_dbus_gvalue_to_gvariant (const GValue *gvalue, const GVariantType *type);
function g_dbus_gvalue_to_gvariant(gvalue, type) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_gvalue_to_gvariant
  type(c_ptr), value :: gvalue
  type(c_ptr), value :: type
end function

! GLIB_AVAILABLE_IN_2_68
!gchar *g_dbus_escape_object_path_bytestring (const guint8 *bytes);
function g_dbus_escape_object_path_bytestring(bytes) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_escape_object_path_bytestring
  type(c_ptr), value :: bytes
end function

! GLIB_AVAILABLE_IN_2_68
!gchar *g_dbus_escape_object_path (const gchar *s);
function g_dbus_escape_object_path(s) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_escape_object_path
  character(kind=c_char), dimension(*) :: s
end function

! GLIB_AVAILABLE_IN_2_68
!guint8 *g_dbus_unescape_object_path (const gchar *s);
function g_dbus_unescape_object_path(s) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_dbus_unescape_object_path
  character(kind=c_char), dimension(*) :: s
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gvolume.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_volume_get_type (void) G_GNUC_CONST;
function g_volume_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_volume_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_volume_get_name (GVolume *volume);
function g_volume_get_name(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_name
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_volume_get_icon (GVolume *volume);
function g_volume_get_icon(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_icon
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_volume_get_symbolic_icon (GVolume *volume);
function g_volume_get_symbolic_icon(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_symbolic_icon
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_volume_get_uuid (GVolume *volume);
function g_volume_get_uuid(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_uuid
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!GDrive * g_volume_get_drive (GVolume *volume);
function g_volume_get_drive(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_drive
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!GMount * g_volume_get_mount (GVolume *volume);
function g_volume_get_mount(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_mount
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_volume_can_mount (GVolume *volume);
function g_volume_can_mount(volume) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_can_mount
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_volume_can_eject (GVolume *volume);
function g_volume_can_eject(volume) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_can_eject
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_volume_should_automount (GVolume *volume);
function g_volume_should_automount(volume) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_should_automount
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!void g_volume_mount (GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_mount(volume, flags, mount_operation, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_volume_mount_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_mount_finish(volume, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_mount_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_FOR(g_volume_eject_with_operation)
!void g_volume_eject (GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject(volume, flags, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_volume_eject_with_operation_finish)
!gboolean g_volume_eject_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_finish(volume, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_eject_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_volume_get_identifier (GVolume *volume, const char *kind);
function g_volume_get_identifier(volume, kind) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_volume_get_identifier
  type(c_ptr), value :: volume
  character(kind=c_char), dimension(*) :: kind
end function

! GLIB_AVAILABLE_IN_ALL
!char ** g_volume_enumerate_identifiers (GVolume *volume);
function g_volume_enumerate_identifiers(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_enumerate_identifiers
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_volume_get_activation_root (GVolume *volume);
function g_volume_get_activation_root(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_activation_root
  type(c_ptr), value :: volume
end function

! GLIB_AVAILABLE_IN_ALL
!void g_volume_eject_with_operation (GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject_with_operation(volume, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_volume_eject_with_operation_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_with_operation_finish(volume, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_volume_eject_with_operation_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_32
!const gchar *g_volume_get_sort_key (GVolume *volume);
function g_volume_get_sort_key(volume) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_volume_get_sort_key
  type(c_ptr), value :: volume
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gunixsocketaddress.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_unix_socket_address_new (const gchar *path);
function g_unix_socket_address_new(path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_unix_socket_address_new
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_DEPRECATED_FOR(g_unix_socket_address_new_with_type)
!GSocketAddress *g_unix_socket_address_new_abstract (const gchar *path, gint path_len);
function g_unix_socket_address_new_abstract(path, path_len) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_unix_socket_address_new_abstract
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: path_len
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketAddress *g_unix_socket_address_new_with_type (const gchar *path, gint path_len, GUnixSocketAddressType type);
function g_unix_socket_address_new_with_type(path, path_len, type) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_unix_socket_address_new_with_type
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: path_len
  integer(c_int), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_unix_socket_address_get_path (GUnixSocketAddress *address);
function g_unix_socket_address_get_path(address) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_unix_socket_address_get_path
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gsize g_unix_socket_address_get_path_len (GUnixSocketAddress *address);
function g_unix_socket_address_get_path_len(address) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_unix_socket_address_get_path_len
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!GUnixSocketAddressType g_unix_socket_address_get_address_type (GUnixSocketAddress *address);
function g_unix_socket_address_get_address_type(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_socket_address_get_address_type
  type(c_ptr), value :: address
end function

! GLIB_DEPRECATED
!gboolean g_unix_socket_address_get_is_abstract (GUnixSocketAddress *address);
function g_unix_socket_address_get_is_abstract(address) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_unix_socket_address_get_is_abstract
  type(c_ptr), value :: address
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_unix_socket_address_abstract_names_supported (void);
function g_unix_socket_address_abstract_names_supported() bind(c)
  import :: c_int
  integer(c_int) :: g_unix_socket_address_abstract_names_supported
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsdatabase.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_database_get_type (void) G_GNUC_CONST;
function g_tls_database_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_database_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificateFlags g_tls_database_verify_chain (GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GError **error);
function g_tls_database_verify_chain(self, chain, purpose, identity,&
& interaction, flags, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_tls_database_verify_chain
  type(c_ptr), value :: self
  type(c_ptr), value :: chain
  character(kind=c_char), dimension(*) :: purpose
  type(c_ptr), value :: identity
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_database_verify_chain_async (GTlsDatabase *self, GTlsCertificate *chain, const gchar *purpose, GSocketConnectable *identity, GTlsInteraction *interaction, GTlsDatabaseVerifyFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_database_verify_chain_async(self, chain, purpose, identity,&
& interaction, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: self
  type(c_ptr), value :: chain
  character(kind=c_char), dimension(*) :: purpose
  type(c_ptr), value :: identity
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificateFlags g_tls_database_verify_chain_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
function g_tls_database_verify_chain_finish(self, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_database_verify_chain_finish
  type(c_ptr), value :: self
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_tls_database_create_certificate_handle (GTlsDatabase *self, GTlsCertificate *certificate);
function g_tls_database_create_certificate_handle(self, certificate) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_database_create_certificate_handle
  type(c_ptr), value :: self
  type(c_ptr), value :: certificate
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate* g_tls_database_lookup_certificate_for_handle (GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
function g_tls_database_lookup_certificate_for_handle(self, handle,&
& interaction, flags, cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_tls_database_lookup_certificate_for_handle
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: handle
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_database_lookup_certificate_for_handle_async (GTlsDatabase *self, const gchar *handle, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_database_lookup_certificate_for_handle_async(self, handle,&
& interaction, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: handle
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate* g_tls_database_lookup_certificate_for_handle_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
function g_tls_database_lookup_certificate_for_handle_finish(self, result,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_database_lookup_certificate_for_handle_finish
  type(c_ptr), value :: self
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate* g_tls_database_lookup_certificate_issuer (GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
function g_tls_database_lookup_certificate_issuer(self, certificate,&
& interaction, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_tls_database_lookup_certificate_issuer
  type(c_ptr), value :: self
  type(c_ptr), value :: certificate
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_database_lookup_certificate_issuer_async (GTlsDatabase *self, GTlsCertificate *certificate, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_database_lookup_certificate_issuer_async(self, certificate,&
& interaction, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: self
  type(c_ptr), value :: certificate
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTlsCertificate* g_tls_database_lookup_certificate_issuer_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
function g_tls_database_lookup_certificate_issuer_finish(self, result, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_database_lookup_certificate_issuer_finish
  type(c_ptr), value :: self
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_tls_database_lookup_certificates_issued_by (GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GError **error);
function g_tls_database_lookup_certificates_issued_by(self, issuer_raw_dn,&
& interaction, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_tls_database_lookup_certificates_issued_by
  type(c_ptr), value :: self
  type(c_ptr), value :: issuer_raw_dn
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_database_lookup_certificates_issued_by_async (GTlsDatabase *self, GByteArray *issuer_raw_dn, GTlsInteraction *interaction, GTlsDatabaseLookupFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_database_lookup_certificates_issued_by_async(self,&
& issuer_raw_dn, interaction, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: self
  type(c_ptr), value :: issuer_raw_dn
  type(c_ptr), value :: interaction
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList* g_tls_database_lookup_certificates_issued_by_finish (GTlsDatabase *self, GAsyncResult *result, GError **error);
function g_tls_database_lookup_certificates_issued_by_finish(self, result,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_database_lookup_certificates_issued_by_finish
  type(c_ptr), value :: self
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtcpwrapperconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tcp_wrapper_connection_get_type (void) G_GNUC_CONST;
function g_tcp_wrapper_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tcp_wrapper_connection_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GSocketConnection *g_tcp_wrapper_connection_new (GIOStream *base_io_stream, GSocket *socket);
function g_tcp_wrapper_connection_new(base_io_stream, socket) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tcp_wrapper_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: socket
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream *g_tcp_wrapper_connection_get_base_io_stream (GTcpWrapperConnection *conn);
function g_tcp_wrapper_connection_get_base_io_stream(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tcp_wrapper_connection_get_base_io_stream
  type(c_ptr), value :: conn
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gtlsclientconnection.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_tls_client_connection_get_type (void) G_GNUC_CONST;
function g_tls_client_connection_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tls_client_connection_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIOStream * g_tls_client_connection_new (GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error);
function g_tls_client_connection_new(base_io_stream, server_identity, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_client_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: server_identity
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_72
!GTlsCertificateFlags g_tls_client_connection_get_validation_flags (GTlsClientConnection *conn);
function g_tls_client_connection_get_validation_flags(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_client_connection_get_validation_flags
  type(c_ptr), value :: conn
end function

! GLIB_DEPRECATED_IN_2_72
!void g_tls_client_connection_set_validation_flags (GTlsClientConnection *conn, GTlsCertificateFlags flags);
subroutine g_tls_client_connection_set_validation_flags(conn, flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GSocketConnectable *g_tls_client_connection_get_server_identity (GTlsClientConnection *conn);
function g_tls_client_connection_get_server_identity(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_client_connection_get_server_identity
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_ALL
!void g_tls_client_connection_set_server_identity (GTlsClientConnection *conn, GSocketConnectable *identity);
subroutine g_tls_client_connection_set_server_identity(conn, identity) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: identity
end subroutine

! GLIB_DEPRECATED_IN_2_56
!gboolean g_tls_client_connection_get_use_ssl3 (GTlsClientConnection *conn);
function g_tls_client_connection_get_use_ssl3(conn) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_tls_client_connection_get_use_ssl3
  type(c_ptr), value :: conn
end function

! GLIB_DEPRECATED_IN_2_56
!void g_tls_client_connection_set_use_ssl3 (GTlsClientConnection *conn, gboolean use_ssl3);
subroutine g_tls_client_connection_set_use_ssl3(conn, use_ssl3) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: use_ssl3
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GList * g_tls_client_connection_get_accepted_cas (GTlsClientConnection *conn);
function g_tls_client_connection_get_accepted_cas(conn) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_tls_client_connection_get_accepted_cas
  type(c_ptr), value :: conn
end function

! GLIB_AVAILABLE_IN_2_46
!void g_tls_client_connection_copy_session_state (GTlsClientConnection *conn, GTlsClientConnection *source);
subroutine g_tls_client_connection_copy_session_state(conn, source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: source
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdbusserver.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_dbus_server_get_type (void) G_GNUC_CONST;
function g_dbus_server_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_dbus_server_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusServer *g_dbus_server_new_sync (const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_server_new_sync(address, flags, guid, observer, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_server_new_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: guid
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_server_get_client_address (GDBusServer *server);
function g_dbus_server_get_client_address(server) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_server_get_client_address
  type(c_ptr), value :: server
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar *g_dbus_server_get_guid (GDBusServer *server);
function g_dbus_server_get_guid(server) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_dbus_server_get_guid
  type(c_ptr), value :: server
end function

! GLIB_AVAILABLE_IN_ALL
!GDBusServerFlags g_dbus_server_get_flags (GDBusServer *server);
function g_dbus_server_get_flags(server) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_server_get_flags
  type(c_ptr), value :: server
end function

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_server_start (GDBusServer *server);
subroutine g_dbus_server_start(server) bind(c)
  import :: c_ptr
  type(c_ptr), value :: server
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_dbus_server_stop (GDBusServer *server);
subroutine g_dbus_server_stop(server) bind(c)
  import :: c_ptr
  type(c_ptr), value :: server
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_dbus_server_is_active (GDBusServer *server);
function g_dbus_server_is_active(server) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_dbus_server_is_active
  type(c_ptr), value :: server
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gdatainputstream.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_data_input_stream_get_type (void) G_GNUC_CONST;
function g_data_input_stream_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_data_input_stream_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GDataInputStream * g_data_input_stream_new (GInputStream *base_stream);
function g_data_input_stream_new(base_stream) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_new
  type(c_ptr), value :: base_stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_data_input_stream_set_byte_order (GDataInputStream *stream, GDataStreamByteOrder order);
subroutine g_data_input_stream_set_byte_order(stream, order) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDataStreamByteOrder g_data_input_stream_get_byte_order (GDataInputStream *stream);
function g_data_input_stream_get_byte_order(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_byte_order
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!void g_data_input_stream_set_newline_type (GDataInputStream *stream, GDataStreamNewlineType type);
subroutine g_data_input_stream_set_newline_type(stream, type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GDataStreamNewlineType g_data_input_stream_get_newline_type (GDataInputStream *stream);
function g_data_input_stream_get_newline_type(stream) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_newline_type
  type(c_ptr), value :: stream
end function

! GLIB_AVAILABLE_IN_ALL
!guchar g_data_input_stream_read_byte (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_byte(stream, cancellable, error) bind(c)
  import :: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_data_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint16 g_data_input_stream_read_int16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int16(stream, cancellable, error) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_int16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint16 g_data_input_stream_read_uint16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint16(stream, cancellable, error) bind(c)
  import :: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_uint16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_data_input_stream_read_int32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int32(stream, cancellable, error) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_int32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint32 g_data_input_stream_read_uint32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint32(stream, cancellable, error) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_uint32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_data_input_stream_read_int64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int64(stream, cancellable, error) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_int64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!guint64 g_data_input_stream_read_uint64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint64(stream, cancellable, error) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_uint64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_data_input_stream_read_line (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_line(stream, length, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line
  type(c_ptr), value :: stream
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!char * g_data_input_stream_read_line_utf8 (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_line_utf8(stream, length, cancellable, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line_utf8
  type(c_ptr), value :: stream
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_data_input_stream_read_line_async (GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_line_async(stream, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!char * g_data_input_stream_read_line_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_line_finish(stream, result, length, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_30
!char * g_data_input_stream_read_line_finish_utf8(GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_line_finish_utf8(stream, result, length,&
& error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line_finish_utf8
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto)
!char * g_data_input_stream_read_until (GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_until(stream, stop_chars, length,&
& cancellable, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_data_input_stream_read_until
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto_async)
!void g_data_input_stream_read_until_async (GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_until_async(stream, stop_chars,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_IN_2_56_FOR (g_data_input_stream_read_upto_finish)
!char * g_data_input_stream_read_until_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_until_finish(stream, result, length, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_until_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_data_input_stream_read_upto (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len,&
& length, cancellable, error) bind(c)
  import :: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_data_input_stream_read_upto
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_data_input_stream_read_upto_async (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_upto_async(stream, stop_chars,&
& stop_chars_len, io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!char * g_data_input_stream_read_upto_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_upto_finish(stream, result, length, error)&
& bind(c)
  import :: c_ptr
  type(c_ptr) :: g_data_input_stream_read_upto_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gemblem.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_emblem_get_type (void) G_GNUC_CONST;
function g_emblem_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_emblem_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GEmblem *g_emblem_new (GIcon *icon);
function g_emblem_new(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_emblem_new
  type(c_ptr), value :: icon
end function

! GLIB_AVAILABLE_IN_ALL
!GEmblem *g_emblem_new_with_origin (GIcon *icon, GEmblemOrigin origin);
function g_emblem_new_with_origin(icon, origin) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_emblem_new_with_origin
  type(c_ptr), value :: icon
  integer(c_int), value :: origin
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon *g_emblem_get_icon (GEmblem *emblem);
function g_emblem_get_icon(emblem) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_emblem_get_icon
  type(c_ptr), value :: emblem
end function

! GLIB_AVAILABLE_IN_ALL
!GEmblemOrigin g_emblem_get_origin (GEmblem *emblem);
function g_emblem_get_origin(emblem) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_emblem_get_origin
  type(c_ptr), value :: emblem
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileinfo.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_info_get_type (void) G_GNUC_CONST;
function g_file_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_info_new (void);
function g_file_info_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_new
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_info_dup (GFileInfo *other);
function g_file_info_dup(other) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_dup
  type(c_ptr), value :: other
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_copy_into (GFileInfo *src_info, GFileInfo *dest_info);
subroutine g_file_info_copy_into(src_info, dest_info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: src_info
  type(c_ptr), value :: dest_info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_has_attribute (GFileInfo *info, const char *attribute);
function g_file_info_has_attribute(info, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_has_attribute
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_has_namespace (GFileInfo *info, const char *name_space);
function g_file_info_has_namespace(info, name_space) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_has_namespace
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! GLIB_AVAILABLE_IN_ALL
!char ** g_file_info_list_attributes (GFileInfo *info, const char *name_space);
function g_file_info_list_attributes(info, name_space) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_list_attributes
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_get_attribute_data (GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
function g_file_info_get_attribute_data(info, attribute, type, value_pp,&
& status) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_data
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_pp
  integer(c_int), value :: status
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeType g_file_info_get_attribute_type (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_type(info, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_type
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_remove_attribute (GFileInfo *info, const char *attribute);
subroutine g_file_info_remove_attribute(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeStatus g_file_info_get_attribute_status (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_status(info, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_set_attribute_status (GFileInfo *info, const char *attribute, GFileAttributeStatus status);
function g_file_info_set_attribute_status(info, attribute, status) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_set_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: status
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_info_get_attribute_as_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_as_string(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_as_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_attribute_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_string(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_attribute_byte_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_byte_string(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_byte_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_get_attribute_boolean (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_boolean(info, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_boolean
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!guint32 g_file_info_get_attribute_uint32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint32(info, attribute) bind(c)
  import :: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_uint32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_file_info_get_attribute_int32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int32(info, attribute) bind(c)
  import :: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_int32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!guint64 g_file_info_get_attribute_uint64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint64(info, attribute) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_uint64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gint64 g_file_info_get_attribute_int64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int64(info, attribute) bind(c)
  import :: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_int64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!GObject * g_file_info_get_attribute_object (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_object(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_object
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!char ** g_file_info_get_attribute_stringv (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_stringv(info, attribute) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_stringv
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute (GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
subroutine g_file_info_set_attribute(info, attribute, type, value_p) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_string(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_byte_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_byte_string(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_boolean (GFileInfo *info, const char *attribute, gboolean attr_value);
subroutine g_file_info_set_attribute_boolean(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_uint32 (GFileInfo *info, const char *attribute, guint32 attr_value);
subroutine g_file_info_set_attribute_uint32(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_int32 (GFileInfo *info, const char *attribute, gint32 attr_value);
subroutine g_file_info_set_attribute_int32(info, attribute, attr_value) bind(c)
  import :: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_uint64 (GFileInfo *info, const char *attribute, guint64 attr_value);
subroutine g_file_info_set_attribute_uint64(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_int64 (GFileInfo *info, const char *attribute, gint64 attr_value);
subroutine g_file_info_set_attribute_int64(info, attribute, attr_value) bind(c)
  import :: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_object (GFileInfo *info, const char *attribute, GObject *attr_value);
subroutine g_file_info_set_attribute_object(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_stringv (GFileInfo *info, const char *attribute, char **attr_value);
subroutine g_file_info_set_attribute_stringv(info, attribute, attr_value)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), dimension(*) :: attr_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_clear_status (GFileInfo *info);
subroutine g_file_info_clear_status(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_2_36
!GDateTime * g_file_info_get_deletion_date (GFileInfo *info);
function g_file_info_get_deletion_date(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_deletion_date
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GFileType g_file_info_get_file_type (GFileInfo *info);
function g_file_info_get_file_type(info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_info_get_file_type
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_get_is_hidden (GFileInfo *info);
function g_file_info_get_is_hidden(info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_hidden
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_get_is_backup (GFileInfo *info);
function g_file_info_get_is_backup(info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_backup
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_info_get_is_symlink (GFileInfo *info);
function g_file_info_get_is_symlink(info) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_symlink
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_name (GFileInfo *info);
function g_file_info_get_name(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_name
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_display_name (GFileInfo *info);
function g_file_info_get_display_name(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_display_name
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_edit_name (GFileInfo *info);
function g_file_info_get_edit_name(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_edit_name
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_file_info_get_icon (GFileInfo *info);
function g_file_info_get_icon(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_icon
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_file_info_get_symbolic_icon (GFileInfo *info);
function g_file_info_get_symbolic_icon(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_symbolic_icon
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_content_type (GFileInfo *info);
function g_file_info_get_content_type(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_content_type
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!goffset g_file_info_get_size (GFileInfo *info);
function g_file_info_get_size(info) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_file_info_get_size
  type(c_ptr), value :: info
end function

! GLIB_DEPRECATED_IN_2_62_FOR(g_file_info_get_modification_date_time)
!void g_file_info_get_modification_time (GFileInfo *info, GTimeVal *result);
subroutine g_file_info_get_modification_time(info, result) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: result
end subroutine

! GLIB_AVAILABLE_IN_2_62
!GDateTime * g_file_info_get_modification_date_time (GFileInfo *info);
function g_file_info_get_modification_date_time(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_modification_date_time
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_2_70
!GDateTime * g_file_info_get_access_date_time (GFileInfo *info);
function g_file_info_get_access_date_time(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_access_date_time
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_2_70
!GDateTime * g_file_info_get_creation_date_time (GFileInfo *info);
function g_file_info_get_creation_date_time(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_creation_date_time
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_symlink_target (GFileInfo *info);
function g_file_info_get_symlink_target(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_symlink_target
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_info_get_etag (GFileInfo *info);
function g_file_info_get_etag(info) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_info_get_etag
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!gint32 g_file_info_get_sort_order (GFileInfo *info);
function g_file_info_get_sort_order(info) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_file_info_get_sort_order
  type(c_ptr), value :: info
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_attribute_mask (GFileInfo *info, GFileAttributeMatcher *mask);
subroutine g_file_info_set_attribute_mask(info, mask) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mask
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_unset_attribute_mask (GFileInfo *info);
subroutine g_file_info_unset_attribute_mask(info) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_file_type (GFileInfo *info, GFileType type);
subroutine g_file_info_set_file_type(info, type) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_is_hidden (GFileInfo *info, gboolean is_hidden);
subroutine g_file_info_set_is_hidden(info, is_hidden) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: is_hidden
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_is_symlink (GFileInfo *info, gboolean is_symlink);
subroutine g_file_info_set_is_symlink(info, is_symlink) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: is_symlink
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_name (GFileInfo *info, const char *name);
subroutine g_file_info_set_name(info, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_display_name (GFileInfo *info, const char *display_name);
subroutine g_file_info_set_display_name(info, display_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: display_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_edit_name (GFileInfo *info, const char *edit_name);
subroutine g_file_info_set_edit_name(info, edit_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: edit_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_icon (GFileInfo *info, GIcon *icon);
subroutine g_file_info_set_icon(info, icon) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: icon
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_symbolic_icon (GFileInfo *info, GIcon *icon);
subroutine g_file_info_set_symbolic_icon(info, icon) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: icon
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_content_type (GFileInfo *info, const char *content_type);
subroutine g_file_info_set_content_type(info, content_type) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_size (GFileInfo *info, goffset size);
subroutine g_file_info_set_size(info, size) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr), value :: info
  integer(c_int64_t), value :: size
end subroutine

! GLIB_DEPRECATED_IN_2_62_FOR(g_file_info_set_modification_date_time)
!void g_file_info_set_modification_time (GFileInfo *info, GTimeVal *mtime);
subroutine g_file_info_set_modification_time(info, mtime) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mtime
end subroutine

! GLIB_AVAILABLE_IN_2_62
!void g_file_info_set_modification_date_time (GFileInfo *info, GDateTime *mtime);
subroutine g_file_info_set_modification_date_time(info, mtime) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mtime
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_file_info_set_access_date_time (GFileInfo *info, GDateTime *atime);
subroutine g_file_info_set_access_date_time(info, atime) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: atime
end subroutine

! GLIB_AVAILABLE_IN_2_70
!void g_file_info_set_creation_date_time (GFileInfo *info, GDateTime *creation_time);
subroutine g_file_info_set_creation_date_time(info, creation_time) bind(c)
  import :: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: creation_time
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_symlink_target (GFileInfo *info, const char *symlink_target);
subroutine g_file_info_set_symlink_target(info, symlink_target) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: symlink_target
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_file_info_set_sort_order (GFileInfo *info, gint32 sort_order);
subroutine g_file_info_set_sort_order(info, sort_order) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: info
  integer(c_int32_t), value :: sort_order
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_file_attribute_matcher_get_type (void) G_GNUC_CONST;
function g_file_attribute_matcher_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_attribute_matcher_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeMatcher *g_file_attribute_matcher_new (const char *attributes);
function g_file_attribute_matcher_new(attributes) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_matcher_new
  character(kind=c_char), dimension(*) :: attributes
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeMatcher *g_file_attribute_matcher_ref (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_ref(matcher) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_ref
  type(c_ptr), value :: matcher
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_attribute_matcher_unref (GFileAttributeMatcher *matcher);
subroutine g_file_attribute_matcher_unref(matcher) bind(c)
  import :: c_ptr
  type(c_ptr), value :: matcher
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeMatcher *g_file_attribute_matcher_subtract (GFileAttributeMatcher *matcher, GFileAttributeMatcher *subtract);
function g_file_attribute_matcher_subtract(matcher, subtract) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_subtract
  type(c_ptr), value :: matcher
  type(c_ptr), value :: subtract
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_attribute_matcher_matches (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches(matcher, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_matches
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_attribute_matcher_matches_only (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches_only(matcher, attribute) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_matches_only
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_attribute_matcher_enumerate_namespace (GFileAttributeMatcher *matcher, const char *ns);
function g_file_attribute_matcher_enumerate_namespace(matcher, ns) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_enumerate_namespace
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: ns
end function

! GLIB_AVAILABLE_IN_ALL
!const char * g_file_attribute_matcher_enumerate_next (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_enumerate_next(matcher) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_enumerate_next
  type(c_ptr), value :: matcher
end function

! GLIB_AVAILABLE_IN_2_32
!char * g_file_attribute_matcher_to_string (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_to_string(matcher) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_to_string
  type(c_ptr), value :: matcher
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfileicon.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_icon_get_type (void) G_GNUC_CONST;
function g_file_icon_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_icon_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GIcon * g_file_icon_new (GFile *file);
function g_file_icon_new(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_icon_new
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_icon_get_file (GFileIcon *icon);
function g_file_icon_get_file(icon) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_icon_get_file
  type(c_ptr), value :: icon
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfile.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_file_get_type (void) G_GNUC_CONST;
function g_file_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_file_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_new_for_path (const char *path);
function g_file_new_for_path(path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_path
  character(kind=c_char), dimension(*) :: path
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_new_for_uri (const char *uri);
function g_file_new_for_uri(uri) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_uri
  character(kind=c_char), dimension(*) :: uri
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_new_for_commandline_arg (const char *arg);
function g_file_new_for_commandline_arg(arg) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_commandline_arg
  character(kind=c_char), dimension(*) :: arg
end function

! GLIB_AVAILABLE_IN_2_36
!GFile * g_file_new_for_commandline_arg_and_cwd (const gchar *arg, const gchar *cwd);
function g_file_new_for_commandline_arg_and_cwd(arg, cwd) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_commandline_arg_and_cwd
  character(kind=c_char), dimension(*) :: arg
  character(kind=c_char), dimension(*) :: cwd
end function

! GLIB_AVAILABLE_IN_2_32
!GFile * g_file_new_tmp (const char *tmpl, GFileIOStream **iostream, GError **error);
function g_file_new_tmp(tmpl, iostream, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_new_tmp
  character(kind=c_char), dimension(*) :: tmpl
  type(c_ptr), value :: iostream
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_parse_name (const char *parse_name);
function g_file_parse_name(parse_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_parse_name
  character(kind=c_char), dimension(*) :: parse_name
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_dup (GFile *file);
function g_file_dup(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_dup
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_file_hash (gconstpointer file);
function g_file_hash(file) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_hash
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_equal (GFile *file1, GFile *file2);
function g_file_equal(file1, file2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_equal
  type(c_ptr), value :: file1
  type(c_ptr), value :: file2
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_basename (GFile *file);
function g_file_get_basename(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_basename
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_path (GFile *file);
function g_file_get_path(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_path
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_2_56
!const char * g_file_peek_path (GFile *file);
function g_file_peek_path(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_peek_path
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_uri (GFile *file);
function g_file_get_uri(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_uri
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_parse_name (GFile *file);
function g_file_get_parse_name(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_parse_name
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_get_parent (GFile *file);
function g_file_get_parent(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_parent
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_has_parent (GFile *file, GFile *parent);
function g_file_has_parent(file, parent) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_has_parent
  type(c_ptr), value :: file
  type(c_ptr), value :: parent
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_get_child (GFile *file, const char *name);
function g_file_get_child(file, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_get_child
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_get_child_for_display_name (GFile *file, const char *display_name, GError **error);
function g_file_get_child_for_display_name(file, display_name, error) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_get_child_for_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_has_prefix (GFile *file, GFile *prefix);
function g_file_has_prefix(file, prefix) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_has_prefix
  type(c_ptr), value :: file
  type(c_ptr), value :: prefix
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_relative_path (GFile *parent, GFile *descendant);
function g_file_get_relative_path(parent, descendant) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_relative_path
  type(c_ptr), value :: parent
  type(c_ptr), value :: descendant
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_resolve_relative_path (GFile *file, const char *relative_path);
function g_file_resolve_relative_path(file, relative_path) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_resolve_relative_path
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: relative_path
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_is_native (GFile *file);
function g_file_is_native(file) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_is_native
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_has_uri_scheme (GFile *file, const char *uri_scheme);
function g_file_has_uri_scheme(file, uri_scheme) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_has_uri_scheme
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: uri_scheme
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_file_get_uri_scheme (GFile *file);
function g_file_get_uri_scheme(file) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_get_uri_scheme
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInputStream * g_file_read (GFile *file, GCancellable *cancellable, GError **error);
function g_file_read(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_read
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_read_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_read_async(file, io_priority, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInputStream * g_file_read_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_read_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_read_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_append_to (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_append_to(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_append_to
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_create (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_create
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_replace (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace(file, etag, make_backup, flags, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_replace
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_append_to_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_append_to_async(file, flags, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_append_to_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_append_to_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_append_to_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_create_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_async(file, flags, io_priority, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_create_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_create_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_replace_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_async(file, etag, make_backup, flags, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileOutputStream * g_file_replace_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_replace_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_open_readwrite (GFile *file, GCancellable *cancellable, GError **error);
function g_file_open_readwrite(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_open_readwrite
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_open_readwrite_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_open_readwrite_async(file, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_open_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_open_readwrite_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_open_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_create_readwrite (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create_readwrite(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_create_readwrite
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_create_readwrite_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_readwrite_async(file, flags, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_create_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_readwrite_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_create_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_replace_readwrite (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace_readwrite(file, etag, make_backup, flags, cancellable,&
& error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_replace_readwrite
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_replace_readwrite_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_readwrite_async(file, etag, make_backup, flags,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileIOStream * g_file_replace_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_readwrite_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_replace_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_query_exists (GFile *file, GCancellable *cancellable);
function g_file_query_exists(file, cancellable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_query_exists
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!GFileType g_file_query_file_type (GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
function g_file_query_file_type(file, flags, cancellable) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_query_file_type
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_query_info (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_query_info(file, attributes, flags, cancellable, error) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_query_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_query_info_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_info_async(file, attributes, flags, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_query_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_info_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_query_filesystem_info (GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_query_filesystem_info(file, attributes, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_query_filesystem_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_query_filesystem_info_async (GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_filesystem_info_async(file, attributes, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileInfo * g_file_query_filesystem_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_filesystem_info_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_filesystem_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GMount * g_file_find_enclosing_mount (GFile *file, GCancellable *cancellable, GError **error);
function g_file_find_enclosing_mount(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_find_enclosing_mount_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_find_enclosing_mount_async(file, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GMount * g_file_find_enclosing_mount_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_find_enclosing_mount_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileEnumerator * g_file_enumerate_children (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_enumerate_children(file, attributes, flags, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_enumerate_children
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_enumerate_children_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerate_children_async(file, attributes, flags,&
& io_priority, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFileEnumerator * g_file_enumerate_children_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_enumerate_children_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_enumerate_children_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_set_display_name (GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
function g_file_set_display_name(file, display_name, cancellable, error)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_file_set_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_set_display_name_async (GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_display_name_async(file, display_name, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_set_display_name_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_set_display_name_finish(file, res, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_set_display_name_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_delete (GFile *file, GCancellable *cancellable, GError **error);
function g_file_delete(file, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_delete
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_34
!void g_file_delete_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_delete_async(file, io_priority, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_34
!gboolean g_file_delete_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_delete_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_delete_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_trash (GFile *file, GCancellable *cancellable, GError **error);
function g_file_trash(file, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_trash
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!void g_file_trash_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_trash_async(file, io_priority, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_38
!gboolean g_file_trash_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_trash_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_trash_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_copy (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_copy(source, destination, flags, cancellable,&
& progress_callback, progress_callback_data, error) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_file_copy
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_copy_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_copy_async(source, destination, flags, io_priority,&
& cancellable, progress_callback, progress_callback_data, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_copy_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_copy_finish(file, res, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_copy_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_move (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_move(source, destination, flags, cancellable,&
& progress_callback, progress_callback_data, error) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_file_move
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_72
!void g_file_move_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_move_async(source, destination, flags, io_priority,&
& cancellable, progress_callback, progress_callback_data, callback, user_data)&
& bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_72
!gboolean g_file_move_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_move_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_move_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_make_directory (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory(file, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_make_directory
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!void g_file_make_directory_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_make_directory_async(file, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_38
!gboolean g_file_make_directory_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_make_directory_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_make_directory_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_make_directory_with_parents (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory_with_parents(file, cancellable, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_make_directory_with_parents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_make_symbolic_link (GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
function g_file_make_symbolic_link(file, symlink_value, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_make_symbolic_link
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: symlink_value
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeInfoList *g_file_query_settable_attributes (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_settable_attributes(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_settable_attributes
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileAttributeInfoList *g_file_query_writable_namespaces (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_writable_namespaces(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_writable_namespaces
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute (GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute(file, attribute, type, value_p, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attributes_from_info (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attributes_from_info(file, info, flags, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_set_attributes_from_info
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_set_attributes_async (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_attributes_async(file, info, flags, io_priority,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attributes_finish (GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
function g_file_set_attributes_finish(file, result, info, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_set_attributes_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: info
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_string(file, attribute, value, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_byte_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_byte_string(file, attribute, value, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute_byte_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_uint32 (GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint32(file, attribute, value, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char, c_int32_t
  integer(c_int) :: g_file_set_attribute_uint32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_int32 (GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int32(file, attribute, value, flags, cancellable,&
& error) bind(c)
  import :: c_int, c_ptr, c_char, c_int32_t
  integer(c_int) :: g_file_set_attribute_int32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_uint64 (GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint64(file, attribute, value, flags,&
& cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_file_set_attribute_uint64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_set_attribute_int64 (GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int64(file, attribute, value, flags, cancellable,&
& error) bind(c)
  import :: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_file_set_attribute_int64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_mount_enclosing_volume (GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_enclosing_volume(location, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: location
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_mount_enclosing_volume_finish (GFile *location, GAsyncResult *result, GError **error);
function g_file_mount_enclosing_volume_finish(location, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_mount_enclosing_volume_finish
  type(c_ptr), value :: location
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_mount_mountable (GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_mountable(file, flags, mount_operation, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GFile * g_file_mount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_mount_mountable_finish(file, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_mount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_FOR(g_file_unmount_mountable_with_operation)
!void g_file_unmount_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable(file, flags, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_file_unmount_mountable_with_operation_finish)
!gboolean g_file_unmount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_unmount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_unmount_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable_with_operation(file, flags,&
& mount_operation, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_unmount_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_with_operation_finish(file, result, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_unmount_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_DEPRECATED_FOR(g_file_eject_mountable_with_operation)
!void g_file_eject_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable(file, flags, cancellable, callback,&
& user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_DEPRECATED_FOR(g_file_eject_mountable_with_operation_finish)
!gboolean g_file_eject_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_eject_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_eject_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable_with_operation(file, flags, mount_operation,&
& cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_eject_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_with_operation_finish(file, result, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_eject_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_68
!char * g_file_build_attribute_list_for_copy (GFile *file, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
function g_file_build_attribute_list_for_copy(file, flags, cancellable, error)&
& bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_build_attribute_list_for_copy
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_copy_attributes (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
function g_file_copy_attributes(source, destination, flags, cancellable, error)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_copy_attributes
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileMonitor* g_file_monitor_directory (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_directory(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_directory
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileMonitor* g_file_monitor_file (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_file(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_file
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GFileMonitor* g_file_monitor (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor(file, flags, cancellable, error) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_file_monitor
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!gboolean g_file_measure_disk_usage (GFile *file, GFileMeasureFlags flags, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
function g_file_measure_disk_usage(file, flags, cancellable, progress_callback,&
& progress_data, disk_usage, num_dirs, num_files, error) bind(c)
  import :: c_int, c_ptr, c_funptr
  integer(c_int) :: g_file_measure_disk_usage
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_data
  type(c_ptr), value :: disk_usage
  type(c_ptr), value :: num_dirs
  type(c_ptr), value :: num_files
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_38
!void g_file_measure_disk_usage_async (GFile *file, GFileMeasureFlags flags, gint io_priority, GCancellable *cancellable, GFileMeasureProgressCallback progress_callback, gpointer progress_data, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_measure_disk_usage_async(file, flags, io_priority,&
& cancellable, progress_callback, progress_data, callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_data
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_38
!gboolean g_file_measure_disk_usage_finish (GFile *file, GAsyncResult *result, guint64 *disk_usage, guint64 *num_dirs, guint64 *num_files, GError **error);
function g_file_measure_disk_usage_finish(file, result, disk_usage, num_dirs,&
& num_files, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_measure_disk_usage_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: disk_usage
  type(c_ptr), value :: num_dirs
  type(c_ptr), value :: num_files
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_start_mountable (GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_start_mountable(file, flags, start_operation, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: start_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_start_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_start_mountable_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_start_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_stop_mountable (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_stop_mountable(file, flags, mount_operation, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_stop_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_stop_mountable_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_stop_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_poll_mountable (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_poll_mountable(file, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_poll_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_poll_mountable_finish(file, result, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_poll_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!GAppInfo *g_file_query_default_handler (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_default_handler(file, cancellable, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_default_handler
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_60
!void g_file_query_default_handler_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_default_handler_async(file, io_priority, cancellable,&
& callback, user_data) bind(c)
  import :: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_60
!GAppInfo *g_file_query_default_handler_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_query_default_handler_finish(file, result, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_query_default_handler_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_load_contents (GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents(file, cancellable, contents, length, etag_out,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_load_contents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_load_contents_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_contents_async(file, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_load_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents_finish(file, res, contents, length, etag_out,&
& error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_load_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_load_partial_contents_async (GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_partial_contents_async(file, cancellable,&
& read_more_callback, callback, user_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: read_more_callback
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_load_partial_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_partial_contents_finish(file, res, contents, length,&
& etag_out, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_load_partial_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_replace_contents (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
function g_file_replace_contents(file, contents, length, etag, make_backup,&
& flags, new_etag, cancellable, error) bind(c)
  import :: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_file_replace_contents
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), dimension(*) :: new_etag
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!void g_file_replace_contents_async (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_contents_async(file, contents, length, etag,&
& make_backup, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_40
!void g_file_replace_contents_bytes_async (GFile *file, GBytes *contents, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_contents_bytes_async(file, contents, etag,&
& make_backup, flags, cancellable, callback, user_data) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: contents
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_replace_contents_finish (GFile *file, GAsyncResult *res, char **new_etag, GError **error);
function g_file_replace_contents_finish(file, res, new_etag, error) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_replace_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: new_etag
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_file_supports_thread_contexts (GFile *file);
function g_file_supports_thread_contexts(file) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_file_supports_thread_contexts
  type(c_ptr), value :: file
end function

! GLIB_AVAILABLE_IN_2_56
!GBytes *g_file_load_bytes (GFile *file, GCancellable *cancellable, gchar **etag_out, GError **error);
function g_file_load_bytes(file, cancellable, etag_out, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_load_bytes
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! GLIB_AVAILABLE_IN_2_56
!void g_file_load_bytes_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_bytes_async(file, cancellable, callback, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GLIB_AVAILABLE_IN_2_56
!GBytes *g_file_load_bytes_finish (GFile *file, GAsyncResult *result, gchar **etag_out, GError **error);
function g_file_load_bytes_finish(file, result, etag_out, error) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_file_load_bytes_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gnativevolumemonitor.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_native_volume_monitor_get_type (void) G_GNUC_CONST;
function g_native_volume_monitor_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_native_volume_monitor_get_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gio/gfilenamecompleter.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_filename_completer_get_type (void) G_GNUC_CONST;
function g_filename_completer_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_filename_completer_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GFilenameCompleter *g_filename_completer_new (void);
function g_filename_completer_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_filename_completer_new
end function

! GLIB_AVAILABLE_IN_ALL
!char * g_filename_completer_get_completion_suffix (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completion_suffix(completer, initial_text)&
& bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completion_suffix
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! GLIB_AVAILABLE_IN_ALL
!char ** g_filename_completer_get_completions (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completions(completer, initial_text) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completions
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! GLIB_AVAILABLE_IN_ALL
!void g_filename_completer_set_dirs_only (GFilenameCompleter *completer, gboolean dirs_only);
subroutine g_filename_completer_set_dirs_only(completer, dirs_only) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: completer
  integer(c_int), value :: dirs_only
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gmarshal.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__VOID (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__VOIDv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__VOIDv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOOLEAN(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__BOOLEANv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__BOOLEANv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__CHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__CHARv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__CHARv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UCHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UCHAR(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UCHARv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__UCHARv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__INTv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__INTv(closure, return_value, instance, args,&
& marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UINTv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__UINTv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__LONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__LONGv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__LONGv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__ULONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ULONG(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__ULONGv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__ULONGv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__ENUMv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__ENUMv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLAGS(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__FLAGSv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__FLAGSv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__FLOAT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLOAT(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__FLOATv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__FLOATv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__DOUBLE(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__DOUBLEv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__DOUBLEv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__STRING(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__STRINGv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__STRINGv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__PARAM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__PARAM(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__PARAMv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__PARAMv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOXED(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__BOXEDv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__BOXEDv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__POINTER(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__POINTERv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__POINTERv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__OBJECT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__OBJECT(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__OBJECTv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__OBJECTv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__VARIANT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VARIANT(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__VARIANTv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__VARIANTv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_VOID__UINT_POINTERv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_VOID__UINT_POINTERv(closure, return_value,&
& instance, args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_BOOLEAN__FLAGSv(closure, return_value, instance,&
& args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_STRING__OBJECT_POINTERv(closure, return_value,&
& instance, args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value,&
& n_param_values, param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure *closure, GValue *return_value, gpointer instance, va_list args, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure, return_value,&
& instance, args, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gparamspecs.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_char (const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
function g_param_spec_char(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_char
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_uchar (const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
function g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_uchar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_boolean (const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags);
function g_param_spec_boolean(name, nick, blurb, default_value, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_boolean
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_int (const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
function g_param_spec_int(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_int
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_uint (const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
function g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_uint
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_long (const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
function g_param_spec_long(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_long
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_ulong (const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
function g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_ulong
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_int64 (const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
function g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_int64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_uint64 (const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
function g_param_spec_uint64(name, nick, blurb, minimum, maximum,&
& default_value, flags) bind(c)
  import :: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_uint64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_unichar (const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags);
function g_param_spec_unichar(name, nick, blurb, default_value, flags) bind(c)
  import :: c_ptr, c_char, c_int32_t, c_int
  type(c_ptr) :: g_param_spec_unichar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int32_t), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_enum (const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags);
function g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags)&
& bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_enum
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: enum_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_flags (const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags);
function g_param_spec_flags(name, nick, blurb, flags_type, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: flags_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_float (const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
function g_param_spec_float(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c)
  import :: c_ptr, c_char, c_float, c_int
  type(c_ptr) :: g_param_spec_float
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_float), value :: minimum
  real(c_float), value :: maximum
  real(c_float), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_double (const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
function g_param_spec_double(name, nick, blurb, minimum, maximum,&
& default_value, flags) bind(c)
  import :: c_ptr, c_char, c_double, c_int
  type(c_ptr) :: g_param_spec_double
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_double), value :: minimum
  real(c_double), value :: maximum
  real(c_double), value :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_string (const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags);
function g_param_spec_string(name, nick, blurb, default_value, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_string
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  character(kind=c_char), dimension(*) :: default_value
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_param (const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags);
function g_param_spec_param(name, nick, blurb, param_type, flags) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_param
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: param_type
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_boxed (const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags);
function g_param_spec_boxed(name, nick, blurb, boxed_type, flags) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_boxed
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: boxed_type
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_pointer (const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_pointer(name, nick, blurb, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_pointer
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_value_array (const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags);
function g_param_spec_value_array(name, nick, blurb, element_spec, flags)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_value_array
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: element_spec
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_object (const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags);
function g_param_spec_object(name, nick, blurb, object_type, flags) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_object
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: object_type
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_override (const gchar *name, GParamSpec *overridden);
function g_param_spec_override(name, overridden) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_param_spec_override
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: overridden
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_gtype (const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags);
function g_param_spec_gtype(name, nick, blurb, is_a_type, flags) bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_gtype
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: is_a_type
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_variant (const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags);
function g_param_spec_variant(name, nick, blurb, type, default_value, flags)&
& bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_variant
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: type
  type(c_ptr), value :: default_value
  integer(c_int), value :: flags
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gobject.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_initially_unowned_get_type (void);
function g_initially_unowned_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_initially_unowned_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_class_install_property (GObjectClass *oclass, guint property_id, GParamSpec *pspec);
subroutine g_object_class_install_property(oclass, property_id, pspec) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_object_class_find_property (GObjectClass *oclass, const gchar *property_name);
function g_object_class_find_property(oclass, property_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_object_class_find_property
  type(c_ptr), value :: oclass
  character(kind=c_char), dimension(*) :: property_name
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec**g_object_class_list_properties (GObjectClass *oclass, guint *n_properties);
function g_object_class_list_properties(oclass, n_properties) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_object_class_list_properties
  type(c_ptr), value :: oclass
  type(c_ptr), value :: n_properties
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_class_override_property (GObjectClass *oclass, guint property_id, const gchar *name);
subroutine g_object_class_override_property(oclass, property_id, name) bind(c)
  import :: c_ptr, c_int, c_char
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_class_install_properties (GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs);
subroutine g_object_class_install_properties(oclass, n_pspecs, pspecs) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: n_pspecs
  type(c_ptr), value :: pspecs
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_interface_install_property (gpointer g_iface, GParamSpec *pspec);
subroutine g_object_interface_install_property(g_iface, pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_object_interface_find_property (gpointer g_iface, const gchar *property_name);
function g_object_interface_find_property(g_iface, property_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_object_interface_find_property
  type(c_ptr), value :: g_iface
  character(kind=c_char), dimension(*) :: property_name
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec**g_object_interface_list_properties (gpointer g_iface, guint *n_properties_p);
function g_object_interface_list_properties(g_iface, n_properties_p) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_object_interface_list_properties
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: n_properties_p
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_object_get_type (void) G_GNUC_CONST;
function g_object_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_object_get_type
end function

! GLIB_DEPRECATED_IN_2_54_FOR(g_object_new_with_properties)
!gpointer g_object_newv (GType object_type, guint n_parameters, GParameter *parameters);
function g_object_newv(object_type, n_parameters, parameters) bind(c)
  import :: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_object_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
end function

! GLIB_AVAILABLE_IN_ALL
!GObject* g_object_new_valist (GType object_type, const gchar *first_property_name, va_list var_args);
function g_object_new_valist(object_type, first_property_name, var_args)&
& bind(c)
  import :: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_object_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_set_valist(object, first_property_name, var_args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_get_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_get_valist(object, first_property_name, var_args) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_property (GObject *object, const gchar *property_name, const GValue *value);
subroutine g_object_set_property(object, property_name, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_get_property (GObject *object, const gchar *property_name, GValue *value);
subroutine g_object_get_property(object, property_name, value) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_freeze_notify (GObject *object);
subroutine g_object_freeze_notify(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_notify (GObject *object, const gchar *property_name);
subroutine g_object_notify(object, property_name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_notify_by_pspec (GObject *object, GParamSpec *pspec);
subroutine g_object_notify_by_pspec(object, pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_thaw_notify (GObject *object);
subroutine g_object_thaw_notify(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_object_is_floating (gpointer object);
function g_object_is_floating(object) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_object_is_floating
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_ref_sink (gpointer object);
function g_object_ref_sink(object) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_object_ref_sink
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_2_70
!gpointer g_object_take_ref (gpointer object);
function g_object_take_ref(object) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_object_take_ref
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_ref (gpointer object);
function g_object_ref(object) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_object_ref
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_unref (gpointer object);
subroutine g_object_unref(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_weak_ref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_ref(object, notify, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_weak_unref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_unref(object, notify, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_add_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_add_weak_pointer(object, weak_pointer_location) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_remove_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_remove_weak_pointer(object, weak_pointer_location) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_add_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_add_toggle_ref(object, notify, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_remove_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_remove_toggle_ref(object, notify, data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_get_qdata (GObject *object, GQuark quark);
function g_object_get_qdata(object, quark) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_object_get_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_qdata (GObject *object, GQuark quark, gpointer data);
subroutine g_object_set_qdata(object, quark, data) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_qdata_full (GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_qdata_full(object, quark, data, destroy) bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_steal_qdata (GObject *object, GQuark quark);
function g_object_steal_qdata(object, quark) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_object_steal_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_2_34
!gpointer g_object_dup_qdata (GObject *object, GQuark quark, GDuplicateFunc dup_func, gpointer user_data);
function g_object_dup_qdata(object, quark, dup_func, user_data) bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr) :: g_object_dup_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_funptr), value :: dup_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_object_replace_qdata (GObject *object, GQuark quark, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
function g_object_replace_qdata(object, quark, oldval, newval, destroy,&
& old_destroy) bind(c)
  import :: c_int, c_ptr, c_int32_t, c_funptr
  integer(c_int) :: g_object_replace_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
  type(c_funptr), value :: destroy
  type(c_funptr), value :: old_destroy
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_get_data (GObject *object, const gchar *key);
function g_object_get_data(object, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_object_get_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_data (GObject *object, const gchar *key, gpointer data);
subroutine g_object_set_data(object, key, data) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_set_data_full (GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_data_full(object, key, data, destroy) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_object_steal_data (GObject *object, const gchar *key);
function g_object_steal_data(object, key) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_object_steal_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! GLIB_AVAILABLE_IN_2_34
!gpointer g_object_dup_data (GObject *object, const gchar *key, GDuplicateFunc dup_func, gpointer user_data);
function g_object_dup_data(object, key, dup_func, user_data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_object_dup_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_funptr), value :: dup_func
  type(c_ptr), value :: user_data
end function

! GLIB_AVAILABLE_IN_2_34
!gboolean g_object_replace_data (GObject *object, const gchar *key, gpointer oldval, gpointer newval, GDestroyNotify destroy, GDestroyNotify *old_destroy);
function g_object_replace_data(object, key, oldval, newval, destroy,&
& old_destroy) bind(c)
  import :: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_object_replace_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
  type(c_funptr), value :: destroy
  type(c_funptr), value :: old_destroy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_watch_closure (GObject *object, GClosure *closure);
subroutine g_object_watch_closure(object, closure) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_cclosure_new_object (GCallback callback_func, GObject *object);
function g_cclosure_new_object(callback_func, object) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_cclosure_new_object_swap (GCallback callback_func, GObject *object);
function g_cclosure_new_object_swap(callback_func, object) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_closure_new_object (guint sizeof_closure, GObject *object);
function g_closure_new_object(sizeof_closure, object) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_closure_new_object
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: object
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_object (GValue *value, gpointer v_object);
subroutine g_value_set_object(value, v_object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_get_object (const GValue *value);
function g_value_get_object(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_object
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_dup_object (const GValue *value);
function g_value_dup_object(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_dup_object
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_connect_object (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
function g_signal_connect_object(instance, detailed_signal, c_handler, gobject,&
& connect_flags) bind(c)
  import :: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_object
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: gobject
  integer(c_int), value :: connect_flags
end function

! GLIB_AVAILABLE_IN_ALL
!void g_object_force_floating (GObject *object);
subroutine g_object_force_floating(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_object_run_dispose (GObject *object);
subroutine g_object_run_dispose(object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_take_object (GValue *value, gpointer v_object);
subroutine g_value_take_object(value, v_object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

! GLIB_DEPRECATED_FOR(g_value_take_object)
!void g_value_set_object_take_ownership (GValue *value, gpointer v_object);
subroutine g_value_set_object_take_ownership(value, v_object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

! GLIB_DEPRECATED
!gsize g_object_compat_control (gsize what, gpointer data);
function g_object_compat_control(what, data) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_object_compat_control
  integer(c_size_t), value :: what
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_clear_object (GObject **object_ptr);
subroutine g_clear_object(object_ptr) bind(c)
  import :: c_ptr
  type(c_ptr), value :: object_ptr
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_weak_ref_init (GWeakRef *weak_ref, gpointer object);
subroutine g_weak_ref_init(weak_ref, object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: weak_ref
  type(c_ptr), value :: object
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_weak_ref_clear (GWeakRef *weak_ref);
subroutine g_weak_ref_clear(weak_ref) bind(c)
  import :: c_ptr
  type(c_ptr), value :: weak_ref
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_weak_ref_get (GWeakRef *weak_ref);
function g_weak_ref_get(weak_ref) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_weak_ref_get
  type(c_ptr), value :: weak_ref
end function

! GLIB_AVAILABLE_IN_ALL
!void g_weak_ref_set (GWeakRef *weak_ref, gpointer object);
subroutine g_weak_ref_set(weak_ref, object) bind(c)
  import :: c_ptr
  type(c_ptr), value :: weak_ref
  type(c_ptr), value :: object
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gsignalgroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_72
!GType g_signal_group_get_type (void) G_GNUC_CONST;
function g_signal_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_signal_group_get_type
end function

! GLIB_AVAILABLE_IN_2_72
!GSignalGroup *g_signal_group_new (GType target_type);
function g_signal_group_new(target_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_signal_group_new
  integer(c_size_t), value :: target_type
end function

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_set_target (GSignalGroup *self, gpointer target);
subroutine g_signal_group_set_target(self, target) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
  type(c_ptr), value :: target
end subroutine

! GLIB_AVAILABLE_IN_2_72
!gpointer g_signal_group_dup_target (GSignalGroup *self);
function g_signal_group_dup_target(self) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_signal_group_dup_target
  type(c_ptr), value :: self
end function

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_block (GSignalGroup *self);
subroutine g_signal_group_block(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_unblock (GSignalGroup *self);
subroutine g_signal_group_unblock(self) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_connect_object (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer object, GConnectFlags flags);
subroutine g_signal_group_connect_object(self, detailed_signal, c_handler,&
& object, flags) bind(c)
  import :: c_ptr, c_char, c_funptr, c_int
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: object
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_connect_data (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify notify, GConnectFlags flags);
subroutine g_signal_group_connect_data(self, detailed_signal, c_handler, data,&
& notify, flags) bind(c)
  import :: c_ptr, c_char, c_funptr, c_int
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_connect (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
subroutine g_signal_group_connect(self, detailed_signal, c_handler, data)&
& bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_connect_after (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
subroutine g_signal_group_connect_after(self, detailed_signal, c_handler, data)&
& bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_signal_group_connect_swapped (GSignalGroup *self, const gchar *detailed_signal, GCallback c_handler, gpointer data);
subroutine g_signal_group_connect_swapped(self, detailed_signal, c_handler,&
& data) bind(c)
  import :: c_ptr, c_char, c_funptr
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gobject-autocleanups.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gboxed.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gpointer g_boxed_copy (GType boxed_type, gconstpointer src_boxed);
function g_boxed_copy(boxed_type, src_boxed) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_boxed_copy
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: src_boxed
end function

! GLIB_AVAILABLE_IN_ALL
!void g_boxed_free (GType boxed_type, gpointer boxed);
subroutine g_boxed_free(boxed_type, boxed) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: boxed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed(value, v_boxed) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_static_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_static_boxed(value, v_boxed) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_take_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_take_boxed(value, v_boxed) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! GLIB_DEPRECATED_FOR(g_value_take_boxed)
!void g_value_set_boxed_take_ownership (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed_take_ownership(value, v_boxed) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_get_boxed (const GValue *value);
function g_value_get_boxed(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_boxed
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_dup_boxed (const GValue *value);
function g_value_dup_boxed(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_dup_boxed
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_boxed_type_register_static (const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
function g_boxed_type_register_static(name, boxed_copy, boxed_free) bind(c)
  import :: c_size_t, c_char, c_funptr
  integer(c_size_t) :: g_boxed_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: boxed_copy
  type(c_funptr), value :: boxed_free
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_closure_get_type (void) G_GNUC_CONST;
function g_closure_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_closure_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_value_get_type (void) G_GNUC_CONST;
function g_value_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_value_get_type
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gvaluetypes.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_32_FOR(g_value_set_schar)
!void g_value_set_char (GValue *value, gchar v_char);
subroutine g_value_set_char(value, v_char) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr), value :: value
  integer(kind=c_int8_t), value :: v_char
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(g_value_get_schar)
!gchar g_value_get_char (const GValue *value);
function g_value_get_char(value) bind(c)
  import :: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_value_get_char
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_schar (GValue *value, gint8 v_char);
subroutine g_value_set_schar(value, v_char) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr), value :: value
  integer(c_int8_t), value :: v_char
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint8 g_value_get_schar (const GValue *value);
function g_value_get_schar(value) bind(c)
  import :: c_int8_t, c_ptr
  integer(c_int8_t) :: g_value_get_schar
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_uchar (GValue *value, guchar v_uchar);
subroutine g_value_set_uchar(value, v_uchar) bind(c)
  import :: c_ptr, c_int8_t
  type(c_ptr), value :: value
  integer(kind=c_int8_t), value :: v_uchar
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guchar g_value_get_uchar (const GValue *value);
function g_value_get_uchar(value) bind(c)
  import :: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_value_get_uchar
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_boolean (GValue *value, gboolean v_boolean);
subroutine g_value_set_boolean(value, v_boolean) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_boolean
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_value_get_boolean (const GValue *value);
function g_value_get_boolean(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_get_boolean
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_int (GValue *value, gint v_int);
subroutine g_value_set_int(value, v_int) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_int
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_value_get_int (const GValue *value);
function g_value_get_int(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_get_int
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_uint (GValue *value, guint v_uint);
subroutine g_value_set_uint(value, v_uint) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_uint
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_value_get_uint (const GValue *value);
function g_value_get_uint(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_get_uint
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_long (GValue *value, glong v_long);
subroutine g_value_set_long(value, v_long) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_long
end subroutine

! GLIB_AVAILABLE_IN_ALL
!glong g_value_get_long (const GValue *value);
function g_value_get_long(value) bind(c)
  import :: c_long, c_ptr
  integer(c_long) :: g_value_get_long
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_ulong (GValue *value, gulong v_ulong);
subroutine g_value_set_ulong(value, v_ulong) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_ulong
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gulong g_value_get_ulong (const GValue *value);
function g_value_get_ulong(value) bind(c)
  import :: c_long, c_ptr
  integer(c_long) :: g_value_get_ulong
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_int64 (GValue *value, gint64 v_int64);
subroutine g_value_set_int64(value, v_int64) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_int64
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint64 g_value_get_int64 (const GValue *value);
function g_value_get_int64(value) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_int64
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_uint64 (GValue *value, guint64 v_uint64);
subroutine g_value_set_uint64(value, v_uint64) bind(c)
  import :: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_uint64
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint64 g_value_get_uint64 (const GValue *value);
function g_value_get_uint64(value) bind(c)
  import :: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_uint64
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_float (GValue *value, gfloat v_float);
subroutine g_value_set_float(value, v_float) bind(c)
  import :: c_ptr, c_float
  type(c_ptr), value :: value
  real(c_float), value :: v_float
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gfloat g_value_get_float (const GValue *value);
function g_value_get_float(value) bind(c)
  import :: c_float, c_ptr
  real(c_float) :: g_value_get_float
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_double (GValue *value, gdouble v_double);
subroutine g_value_set_double(value, v_double) bind(c)
  import :: c_ptr, c_double
  type(c_ptr), value :: value
  real(c_double), value :: v_double
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gdouble g_value_get_double (const GValue *value);
function g_value_get_double(value) bind(c)
  import :: c_double, c_ptr
  real(c_double) :: g_value_get_double
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_string (GValue *value, const gchar *v_string);
subroutine g_value_set_string(value, v_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_static_string (GValue *value, const gchar *v_string);
subroutine g_value_set_static_string(value, v_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! GLIB_AVAILABLE_IN_2_66
!void g_value_set_interned_string (GValue *value, const gchar *v_string);
subroutine g_value_set_interned_string(value, v_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_value_get_string (const GValue *value);
function g_value_get_string(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_string
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_value_dup_string (const GValue *value);
function g_value_dup_string(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_dup_string
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_pointer (GValue *value, gpointer v_pointer);
subroutine g_value_set_pointer(value, v_pointer) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_pointer
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_get_pointer (const GValue *value);
function g_value_get_pointer(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_pointer
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_gtype_get_type (void);
function g_gtype_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_gtype_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_gtype (GValue *value, GType v_gtype);
subroutine g_value_set_gtype(value, v_gtype) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: value
  integer(c_size_t), value :: v_gtype
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_value_get_gtype (const GValue *value);
function g_value_get_gtype(value) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t) :: g_value_get_gtype
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_variant (GValue *value, GVariant *variant);
subroutine g_value_set_variant(value, variant) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_take_variant (GValue *value, GVariant *variant);
subroutine g_value_take_variant(value, variant) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GVariant* g_value_get_variant (const GValue *value);
function g_value_get_variant(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_variant
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GVariant* g_value_dup_variant (const GValue *value);
function g_value_dup_variant(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_dup_variant
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_pointer_type_register_static (const gchar *name);
function g_pointer_type_register_static(name) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_pointer_type_register_static
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gchar* g_strdup_value_contents (const GValue *value);
function g_strdup_value_contents(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_strdup_value_contents
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_take_string (GValue *value, gchar *v_string);
subroutine g_value_take_string(value, v_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! GLIB_DEPRECATED_FOR(g_value_take_string)
!void g_value_set_string_take_ownership (GValue *value, gchar *v_string);
subroutine g_value_set_string_take_ownership(value, v_string) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gsignal.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!guint g_signal_newv (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types);
function g_signal_newv(signal_name, itype, signal_flags, class_closure,&
& accumulator, accu_data, c_marshaller, return_type, n_params, param_types)&
& bind(c)
  import :: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_newv
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_signal_new_valist (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args);
function g_signal_new_valist(signal_name, itype, signal_flags, class_closure,&
& accumulator, accu_data, c_marshaller, return_type, n_params, args) bind(c)
  import :: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_new_valist
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: args
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_emitv (const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value);
subroutine g_signal_emitv(instance_and_params, signal_id, detail, return_value)&
& bind(c)
  import :: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance_and_params
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: return_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_emit_valist (gpointer instance, guint signal_id, GQuark detail, va_list var_args);
subroutine g_signal_emit_valist(instance, signal_id, detail, var_args) bind(c)
  import :: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: var_args
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_signal_lookup (const gchar *name, GType itype);
function g_signal_lookup(name, itype) bind(c)
  import :: c_int, c_char, c_size_t
  integer(c_int) :: g_signal_lookup
  character(kind=c_char), dimension(*) :: name
  integer(c_size_t), value :: itype
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_signal_name (guint signal_id);
function g_signal_name(signal_id) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_signal_name
  integer(c_int), value :: signal_id
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_query (guint signal_id, GSignalQuery *query);
subroutine g_signal_query(signal_id, query) bind(c)
  import :: c_int, c_ptr
  integer(c_int), value :: signal_id
  type(c_ptr), value :: query
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint* g_signal_list_ids (GType itype, guint *n_ids);
function g_signal_list_ids(itype, n_ids) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_signal_list_ids
  integer(c_size_t), value :: itype
  type(c_ptr), value :: n_ids
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_signal_is_valid_name (const gchar *name);
function g_signal_is_valid_name(name) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_signal_is_valid_name
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_signal_parse_name (const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark);
function g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p,&
& force_detail_quark) bind(c)
  import :: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_signal_parse_name
  character(kind=c_char), dimension(*) :: detailed_signal
  integer(c_size_t), value :: itype
  type(c_ptr), value :: signal_id_p
  type(c_ptr), value :: detail_p
  integer(c_int), value :: force_detail_quark
end function

! GLIB_AVAILABLE_IN_ALL
!GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);
function g_signal_get_invocation_hint(instance) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_signal_get_invocation_hint
  type(c_ptr), value :: instance
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_stop_emission (gpointer instance, guint signal_id, GQuark detail);
subroutine g_signal_stop_emission(instance, signal_id, detail) bind(c)
  import :: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_stop_emission_by_name (gpointer instance, const gchar *detailed_signal);
subroutine g_signal_stop_emission_by_name(instance, detailed_signal) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_add_emission_hook (guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
function g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data,&
& data_destroy) bind(c)
  import :: c_long, c_int, c_int32_t, c_funptr, c_ptr
  integer(c_long) :: g_signal_add_emission_hook
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_funptr), value :: hook_func
  type(c_ptr), value :: hook_data
  type(c_funptr), value :: data_destroy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_remove_emission_hook (guint signal_id, gulong hook_id);
subroutine g_signal_remove_emission_hook(signal_id, hook_id) bind(c)
  import :: c_int, c_long
  integer(c_int), value :: signal_id
  integer(c_long), value :: hook_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_signal_has_handler_pending (gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
function g_signal_has_handler_pending(instance, signal_id, detail,&
& may_be_blocked) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_has_handler_pending
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  integer(c_int), value :: may_be_blocked
end function

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_connect_closure_by_id (gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after);
function g_signal_connect_closure_by_id(instance, signal_id, detail, closure,&
& after) bind(c)
  import :: c_long, c_ptr, c_int, c_int32_t
  integer(c_long) :: g_signal_connect_closure_by_id
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  integer(c_int), value :: after
end function

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_connect_closure (gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after);
function g_signal_connect_closure(instance, detailed_signal, closure, after)&
& bind(c)
  import :: c_long, c_ptr, c_char, c_int
  integer(c_long) :: g_signal_connect_closure
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_ptr), value :: closure
  integer(c_int), value :: after
end function

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_connect_data (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
function g_signal_connect_data(instance, detailed_signal, c_handler, data,&
& destroy_data, connect_flags) bind(c)
  import :: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_data
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_data
  integer(c_int), value :: connect_flags
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_handler_block (gpointer instance, gulong handler_id);
subroutine g_signal_handler_block(instance, handler_id) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_handler_unblock (gpointer instance, gulong handler_id);
subroutine g_signal_handler_unblock(instance, handler_id) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_handler_disconnect (gpointer instance, gulong handler_id);
subroutine g_signal_handler_disconnect(instance, handler_id) bind(c)
  import :: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_signal_handler_is_connected (gpointer instance, gulong handler_id);
function g_signal_handler_is_connected(instance, handler_id) bind(c)
  import :: c_int, c_ptr, c_long
  integer(c_int) :: g_signal_handler_is_connected
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end function

! GLIB_AVAILABLE_IN_ALL
!gulong g_signal_handler_find (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handler_find(instance, mask, signal_id, detail, closure,&
& func, data) bind(c)
  import :: c_long, c_ptr, c_int, c_int32_t
  integer(c_long) :: g_signal_handler_find
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_signal_handlers_block_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_block_matched(instance, mask, signal_id, detail,&
& closure, func, data) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_block_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_signal_handlers_unblock_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_unblock_matched(instance, mask, signal_id, detail,&
& closure, func, data) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_unblock_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_signal_handlers_disconnect_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_disconnect_matched(instance, mask, signal_id,&
& detail, closure, func, data) bind(c)
  import :: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_disconnect_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_2_62
!void g_clear_signal_handler (gulong *handler_id_ptr, gpointer instance);
subroutine g_clear_signal_handler(handler_id_ptr, instance) bind(c)
  import :: c_ptr
  type(c_ptr), value :: handler_id_ptr
  type(c_ptr), value :: instance
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_override_class_closure (guint signal_id, GType instance_type, GClosure *class_closure);
subroutine g_signal_override_class_closure(signal_id, instance_type,&
& class_closure) bind(c)
  import :: c_int, c_size_t, c_ptr
  integer(c_int), value :: signal_id
  integer(c_size_t), value :: instance_type
  type(c_ptr), value :: class_closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_override_class_handler (const gchar *signal_name, GType instance_type, GCallback class_handler);
subroutine g_signal_override_class_handler(signal_name, instance_type,&
& class_handler) bind(c)
  import :: c_char, c_size_t, c_funptr
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: instance_type
  type(c_funptr), value :: class_handler
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_signal_chain_from_overridden (const GValue *instance_and_params, GValue *return_value);
subroutine g_signal_chain_from_overridden(instance_and_params, return_value)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: instance_and_params
  type(c_ptr), value :: return_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
function g_signal_accumulator_true_handled(ihint, return_accu, handler_return,&
& dummy) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_signal_accumulator_true_handled
  type(c_ptr), value :: ihint
  type(c_ptr), value :: return_accu
  type(c_ptr), value :: handler_return
  type(c_ptr), value :: dummy
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_signal_accumulator_first_wins (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
function g_signal_accumulator_first_wins(ihint, return_accu, handler_return,&
& dummy) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_signal_accumulator_first_wins
  type(c_ptr), value :: ihint
  type(c_ptr), value :: return_accu
  type(c_ptr), value :: handler_return
  type(c_ptr), value :: dummy
end function

! GLIB_AVAILABLE_IN_ALL
!void g_signal_handlers_destroy (gpointer instance);
subroutine g_signal_handlers_destroy(instance) bind(c)
  import :: c_ptr
  type(c_ptr), value :: instance
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gtypeplugin.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_type_plugin_get_type (void) G_GNUC_CONST;
function g_type_plugin_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_plugin_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_plugin_use (GTypePlugin *plugin);
subroutine g_type_plugin_use(plugin) bind(c)
  import :: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_plugin_unuse (GTypePlugin *plugin);
subroutine g_type_plugin_unuse(plugin) bind(c)
  import :: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_plugin_complete_type_info (GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table);
subroutine g_type_plugin_complete_type_info(plugin, g_type, info, value_table)&
& bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: g_type
  type(c_ptr), value :: info
  type(c_ptr), value :: value_table
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_plugin_complete_interface_info (GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info);
subroutine g_type_plugin_complete_interface_info(plugin, instance_type,&
& interface_type, info) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gclosure.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GClosure* g_cclosure_new (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new(callback_func, user_data, destroy_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_cclosure_new_swap (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new_swap(callback_func, user_data, destroy_data) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_signal_type_cclosure_new (GType itype, guint struct_offset);
function g_signal_type_cclosure_new(itype, struct_offset) bind(c)
  import :: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_signal_type_cclosure_new
  integer(c_size_t), value :: itype
  integer(c_int), value :: struct_offset
end function

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_closure_ref (GClosure *closure);
function g_closure_ref(closure) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_closure_ref
  type(c_ptr), value :: closure
end function

! GLIB_AVAILABLE_IN_ALL
!void g_closure_sink (GClosure *closure);
subroutine g_closure_sink(closure) bind(c)
  import :: c_ptr
  type(c_ptr), value :: closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_unref (GClosure *closure);
subroutine g_closure_unref(closure) bind(c)
  import :: c_ptr
  type(c_ptr), value :: closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GClosure* g_closure_new_simple (guint sizeof_closure, gpointer data);
function g_closure_new_simple(sizeof_closure, data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_closure_new_simple
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: data
end function

! GLIB_AVAILABLE_IN_ALL
!void g_closure_add_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_finalize_notifier(closure, notify_data, notify_func)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_remove_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_finalize_notifier(closure, notify_data,&
& notify_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_add_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_invalidate_notifier(closure, notify_data, notify_func)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_remove_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_invalidate_notifier(closure, notify_data,&
& notify_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_add_marshal_guards (GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
subroutine g_closure_add_marshal_guards(closure, pre_marshal_data,&
& pre_marshal_notify, post_marshal_data, post_marshal_notify) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: pre_marshal_data
  type(c_funptr), value :: pre_marshal_notify
  type(c_ptr), value :: post_marshal_data
  type(c_funptr), value :: post_marshal_notify
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_set_marshal (GClosure *closure, GClosureMarshal marshal);
subroutine g_closure_set_marshal(closure, marshal) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_funptr), value :: marshal
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_set_meta_marshal (GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal);
subroutine g_closure_set_meta_marshal(closure, marshal_data, meta_marshal)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: marshal_data
  type(c_funptr), value :: meta_marshal
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_invalidate (GClosure *closure);
subroutine g_closure_invalidate(closure) bind(c)
  import :: c_ptr
  type(c_ptr), value :: closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_closure_invoke (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint);
subroutine g_closure_invoke(closure, return_value, n_param_values,&
& param_values, invocation_hint) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_generic (GClosure *closure, GValue *return_gvalue, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_generic(closure, return_gvalue, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_gvalue
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_cclosure_marshal_generic_va (GClosure *closure, GValue *return_value, gpointer instance, va_list args_list, gpointer marshal_data, int n_params, GType *param_types);
subroutine g_cclosure_marshal_generic_va(closure, return_value, instance,&
& args_list, marshal_data, n_params, param_types) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  type(c_ptr), value :: instance
  type(c_ptr), value :: args_list
  type(c_ptr), value :: marshal_data
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gvalue.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!union GValue* g_value_init (GValue *value, GType g_type);
function g_value_init(value, g_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_value_init
  type(c_ptr), value :: value
  integer(c_size_t), value :: g_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_copy (const GValue *src_value, GValue *dest_value);
subroutine g_value_copy(src_value, dest_value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GValue* g_value_reset (GValue *value);
function g_value_reset(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_reset
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_unset (GValue *value);
subroutine g_value_unset(value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_instance (GValue *value, gpointer instance);
subroutine g_value_set_instance(value, instance) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: instance
end subroutine

! GLIB_AVAILABLE_IN_2_42
!void g_value_init_from_instance (GValue *value, gpointer instance);
subroutine g_value_init_from_instance(value, instance) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: instance
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_value_fits_pointer (const GValue *value);
function g_value_fits_pointer(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_fits_pointer
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_value_peek_pointer (const GValue *value);
function g_value_peek_pointer(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_peek_pointer
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_value_type_compatible (GType src_type, GType dest_type);
function g_value_type_compatible(src_type, dest_type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_value_type_compatible
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_value_type_transformable (GType src_type, GType dest_type);
function g_value_type_transformable(src_type, dest_type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_value_type_transformable
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_value_transform (const GValue *src_value, GValue *dest_value);
function g_value_transform(src_value, dest_value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_transform
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_register_transform_func (GType src_type, GType dest_type, GValueTransform transform_func);
subroutine g_value_register_transform_func(src_type, dest_type, transform_func)&
& bind(c)
  import :: c_size_t, c_funptr
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
  type(c_funptr), value :: transform_func
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gbinding.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_binding_flags_get_type (void) G_GNUC_CONST;
function g_binding_flags_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_binding_flags_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_binding_get_type (void) G_GNUC_CONST;
function g_binding_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_binding_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GBindingFlags g_binding_get_flags (GBinding *binding);
function g_binding_get_flags(binding) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_binding_get_flags
  type(c_ptr), value :: binding
end function

! GLIB_DEPRECATED_IN_2_68_FOR(g_binding_dup_source)
!GObject * g_binding_get_source (GBinding *binding);
function g_binding_get_source(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_get_source
  type(c_ptr), value :: binding
end function

! GLIB_AVAILABLE_IN_2_68
!GObject * g_binding_dup_source (GBinding *binding);
function g_binding_dup_source(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_dup_source
  type(c_ptr), value :: binding
end function

! GLIB_DEPRECATED_IN_2_68_FOR(g_binding_dup_target)
!GObject * g_binding_get_target (GBinding *binding);
function g_binding_get_target(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_get_target
  type(c_ptr), value :: binding
end function

! GLIB_AVAILABLE_IN_2_68
!GObject * g_binding_dup_target (GBinding *binding);
function g_binding_dup_target(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_dup_target
  type(c_ptr), value :: binding
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_binding_get_source_property (GBinding *binding);
function g_binding_get_source_property(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_get_source_property
  type(c_ptr), value :: binding
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_binding_get_target_property (GBinding *binding);
function g_binding_get_target_property(binding) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_get_target_property
  type(c_ptr), value :: binding
end function

! GLIB_AVAILABLE_IN_2_38
!void g_binding_unbind (GBinding *binding);
subroutine g_binding_unbind(binding) bind(c)
  import :: c_ptr
  type(c_ptr), value :: binding
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GBinding *g_object_bind_property (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
function g_object_bind_property(source, source_property, target,&
& target_property, flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GBinding *g_object_bind_property_full (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
function g_object_bind_property_full(source, source_property, target,&
& target_property, flags, transform_to, transform_from, user_data, notify)&
& bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr) :: g_object_bind_property_full
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_funptr), value :: transform_to
  type(c_funptr), value :: transform_from
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GLIB_AVAILABLE_IN_ALL
!GBinding *g_object_bind_property_with_closures (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
function g_object_bind_property_with_closures(source, source_property, target,&
& target_property, flags, transform_to, transform_from) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property_with_closures
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_ptr), value :: transform_to
  type(c_ptr), value :: transform_from
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/genums.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GEnumValue* g_enum_get_value (GEnumClass *enum_class, gint value);
function g_enum_get_value(enum_class, value) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_enum_get_value
  type(c_ptr), value :: enum_class
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class, const gchar *name);
function g_enum_get_value_by_name(enum_class, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_name
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class, const gchar *nick);
function g_enum_get_value_by_nick(enum_class, nick) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_nick
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: nick
end function

! GLIB_AVAILABLE_IN_ALL
!GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class, guint value);
function g_flags_get_first_value(flags_class, value) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_flags_get_first_value
  type(c_ptr), value :: flags_class
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class, const gchar *name);
function g_flags_get_value_by_name(flags_class, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_name
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class, const gchar *nick);
function g_flags_get_value_by_nick(flags_class, nick) bind(c)
  import :: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_nick
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: nick
end function

! GLIB_AVAILABLE_IN_2_54
!gchar *g_enum_to_string (GType g_enum_type, gint value);
function g_enum_to_string(g_enum_type, value) bind(c)
  import :: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_enum_to_string
  integer(c_size_t), value :: g_enum_type
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_2_54
!gchar *g_flags_to_string (GType flags_type, guint value);
function g_flags_to_string(flags_type, value) bind(c)
  import :: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_flags_to_string
  integer(c_size_t), value :: flags_type
  integer(c_int), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_enum (GValue *value, gint v_enum);
subroutine g_value_set_enum(value, v_enum) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_enum
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gint g_value_get_enum (const GValue *value);
function g_value_get_enum(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_get_enum
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_flags (GValue *value, guint v_flags);
subroutine g_value_set_flags(value, v_flags) bind(c)
  import :: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_flags
end subroutine

! GLIB_AVAILABLE_IN_ALL
!guint g_value_get_flags (const GValue *value);
function g_value_get_flags(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_value_get_flags
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_enum_register_static (const gchar *name, const GEnumValue *const_static_values);
function g_enum_register_static(name, const_static_values) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_enum_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_flags_register_static (const gchar *name, const GFlagsValue *const_static_values);
function g_flags_register_static(name, const_static_values) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_flags_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GLIB_AVAILABLE_IN_ALL
!void g_enum_complete_type_info (GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values);
subroutine g_enum_complete_type_info(g_enum_type, info, const_values) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: g_enum_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_flags_complete_type_info (GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values);
subroutine g_flags_complete_type_info(g_flags_type, info, const_values) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: g_flags_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gvaluecollector.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gtypemodule.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_module_use (GTypeModule *module);
function g_type_module_use(module) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_type_module_use
  type(c_ptr), value :: module
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_module_unuse (GTypeModule *module);
subroutine g_type_module_unuse(module) bind(c)
  import :: c_ptr
  type(c_ptr), value :: module
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_module_set_name (GTypeModule *module, const gchar *name);
subroutine g_type_module_set_name(module, name) bind(c)
  import :: c_ptr, c_char
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_type_module_register_type (GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags);
function g_type_module_register_type(module, parent_type, type_name, type_info,&
& flags) bind(c)
  import :: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_type_module_register_type
  type(c_ptr), value :: module
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: type_info
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_module_add_interface (GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info);
subroutine g_type_module_add_interface(module, instance_type, interface_type,&
& interface_info) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: module
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: interface_info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType g_type_module_register_enum (GTypeModule *module, const gchar *name, const GEnumValue *const_static_values);
function g_type_module_register_enum(module, name, const_static_values) bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_enum
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_module_register_flags (GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values);
function g_type_module_register_flags(module, name, const_static_values)&
& bind(c)
  import :: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_flags
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gparam.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_ref (GParamSpec *pspec);
function g_param_spec_ref(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_ref
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_unref (GParamSpec *pspec);
subroutine g_param_spec_unref(pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_sink (GParamSpec *pspec);
subroutine g_param_spec_sink(pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
function g_param_spec_ref_sink(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_ref_sink
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_param_spec_get_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_get_qdata(pspec, quark) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_get_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_set_qdata (GParamSpec *pspec, GQuark quark, gpointer data);
subroutine g_param_spec_set_qdata(pspec, quark, data) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_set_qdata_full (GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_param_spec_set_qdata_full(pspec, quark, data, destroy) bind(c)
  import :: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_param_spec_steal_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_steal_qdata(pspec, quark) bind(c)
  import :: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_steal_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);
function g_param_spec_get_redirect_target(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_get_redirect_target
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!void g_param_value_set_default (GParamSpec *pspec, GValue *value);
subroutine g_param_value_set_default(pspec, value) bind(c)
  import :: c_ptr
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gboolean g_param_value_defaults (GParamSpec *pspec, const GValue *value);
function g_param_value_defaults(pspec, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_param_value_defaults
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_param_value_validate (GParamSpec *pspec, GValue *value);
function g_param_value_validate(pspec, value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_param_value_validate
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_param_value_convert (GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation);
function g_param_value_convert(pspec, src_value, dest_value, strict_validation)&
& bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_param_value_convert
  type(c_ptr), value :: pspec
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
  integer(c_int), value :: strict_validation
end function

! GLIB_AVAILABLE_IN_ALL
!gint g_param_values_cmp (GParamSpec *pspec, const GValue *value1, const GValue *value2);
function g_param_values_cmp(pspec, value1, value2) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_param_values_cmp
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value1
  type(c_ptr), value :: value2
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_param_spec_get_name (GParamSpec *pspec);
function g_param_spec_get_name(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_get_name
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_param_spec_get_nick (GParamSpec *pspec);
function g_param_spec_get_nick(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_get_nick
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_param_spec_get_blurb (GParamSpec *pspec);
function g_param_spec_get_blurb(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_get_blurb
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_set_param (GValue *value, GParamSpec *param);
subroutine g_value_set_param(value, param) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_value_get_param (const GValue *value);
function g_value_get_param(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_get_param
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_value_dup_param (const GValue *value);
function g_value_dup_param(value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_dup_param
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!void g_value_take_param (GValue *value, GParamSpec *param);
subroutine g_value_take_param(value, param) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

! GLIB_DEPRECATED_FOR(g_value_take_param)
!void g_value_set_param_take_ownership (GValue *value, GParamSpec *param);
subroutine g_value_set_param_take_ownership(value, param) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

! GLIB_AVAILABLE_IN_2_36
!const GValue * g_param_spec_get_default_value (GParamSpec *pspec);
function g_param_spec_get_default_value(pspec) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_param_spec_get_default_value
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_2_46
!GQuark g_param_spec_get_name_quark (GParamSpec *pspec);
function g_param_spec_get_name_quark(pspec) bind(c)
  import :: c_int32_t, c_ptr
  integer(c_int32_t) :: g_param_spec_get_name_quark
  type(c_ptr), value :: pspec
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_param_type_register_static (const gchar *name, const GParamSpecTypeInfo *pspec_info);
function g_param_type_register_static(name, pspec_info) bind(c)
  import :: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_param_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: pspec_info
end function

! GLIB_AVAILABLE_IN_2_66
!gboolean g_param_spec_is_valid_name (const gchar *name);
function g_param_spec_is_valid_name(name) bind(c)
  import :: c_int, c_char
  integer(c_int) :: g_param_spec_is_valid_name
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_param_spec_internal (GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_internal(param_type, name, nick, blurb, flags) bind(c)
  import :: c_ptr, c_size_t, c_char, c_int
  type(c_ptr) :: g_param_spec_internal
  integer(c_size_t), value :: param_type
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
function g_param_spec_pool_new(type_prefixing) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_param_spec_pool_new
  integer(c_int), value :: type_prefixing
end function

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_pool_insert (GParamSpecPool *pool, GParamSpec *pspec, GType owner_type);
subroutine g_param_spec_pool_insert(pool, pspec, owner_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
  integer(c_size_t), value :: owner_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_param_spec_pool_remove (GParamSpecPool *pool, GParamSpec *pspec);
subroutine g_param_spec_pool_remove(pool, pspec) bind(c)
  import :: c_ptr
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors);
function g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors)&
& bind(c)
  import :: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_pool_lookup
  type(c_ptr), value :: pool
  character(kind=c_char), dimension(*) :: param_name
  integer(c_size_t), value :: owner_type
  integer(c_int), value :: walk_ancestors
end function

! GLIB_AVAILABLE_IN_ALL
!GList* g_param_spec_pool_list_owned (GParamSpecPool *pool, GType owner_type);
function g_param_spec_pool_list_owned(pool, owner_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list_owned
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
end function

! GLIB_AVAILABLE_IN_ALL
!GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p);
function g_param_spec_pool_list(pool, owner_type, n_pspecs_p) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
  type(c_ptr), value :: n_pspecs_p
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gsourceclosure.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!void g_source_set_closure (GSource *source, GClosure *closure);
subroutine g_source_set_closure(source, closure) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: closure
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_source_set_dummy_callback (GSource *source);
subroutine g_source_set_dummy_callback(source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: source
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/glib-types.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_ALL
!GType g_date_get_type (void) G_GNUC_CONST;
function g_date_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_date_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_strv_get_type (void) G_GNUC_CONST;
function g_strv_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_strv_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_gstring_get_type (void) G_GNUC_CONST;
function g_gstring_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_gstring_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_hash_table_get_type (void) G_GNUC_CONST;
function g_hash_table_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_hash_table_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_array_get_type (void) G_GNUC_CONST;
function g_array_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_array_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_byte_array_get_type (void) G_GNUC_CONST;
function g_byte_array_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_byte_array_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_ptr_array_get_type (void) G_GNUC_CONST;
function g_ptr_array_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_ptr_array_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_bytes_get_type (void) G_GNUC_CONST;
function g_bytes_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_bytes_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_variant_type_get_gtype (void) G_GNUC_CONST;
function g_variant_type_get_gtype() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_variant_type_get_gtype
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_regex_get_type (void) G_GNUC_CONST;
function g_regex_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_regex_get_type
end function

! GLIB_AVAILABLE_IN_2_30
!GType g_match_info_get_type (void) G_GNUC_CONST;
function g_match_info_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_match_info_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_error_get_type (void) G_GNUC_CONST;
function g_error_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_error_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_date_time_get_type (void) G_GNUC_CONST;
function g_date_time_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_date_time_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_time_zone_get_type (void) G_GNUC_CONST;
function g_time_zone_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_time_zone_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_io_channel_get_type (void) G_GNUC_CONST;
function g_io_channel_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_io_channel_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_io_condition_get_type (void) G_GNUC_CONST;
function g_io_condition_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_io_condition_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_variant_builder_get_type (void) G_GNUC_CONST;
function g_variant_builder_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_variant_builder_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GType g_variant_dict_get_type (void) G_GNUC_CONST;
function g_variant_dict_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_variant_dict_get_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_key_file_get_type (void) G_GNUC_CONST;
function g_key_file_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_key_file_get_type
end function

! GLIB_AVAILABLE_IN_2_30
!GType g_main_loop_get_type (void) G_GNUC_CONST;
function g_main_loop_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_main_loop_get_type
end function

! GLIB_AVAILABLE_IN_2_30
!GType g_main_context_get_type (void) G_GNUC_CONST;
function g_main_context_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_main_context_get_type
end function

! GLIB_AVAILABLE_IN_2_30
!GType g_source_get_type (void) G_GNUC_CONST;
function g_source_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_source_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GType g_pollfd_get_type (void) G_GNUC_CONST;
function g_pollfd_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_pollfd_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GType g_thread_get_type (void) G_GNUC_CONST;
function g_thread_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_thread_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GType g_checksum_get_type (void) G_GNUC_CONST;
function g_checksum_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_checksum_get_type
end function

! GLIB_AVAILABLE_IN_2_36
!GType g_markup_parse_context_get_type (void) G_GNUC_CONST;
function g_markup_parse_context_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_markup_parse_context_get_type
end function

! GLIB_AVAILABLE_IN_2_40
!GType g_mapped_file_get_type (void) G_GNUC_CONST;
function g_mapped_file_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_mapped_file_get_type
end function

! GLIB_AVAILABLE_IN_2_44
!GType g_option_group_get_type (void) G_GNUC_CONST;
function g_option_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_option_group_get_type
end function

! GLIB_AVAILABLE_IN_2_66
!GType g_uri_get_type (void) G_GNUC_CONST;
function g_uri_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_uri_get_type
end function

! GLIB_AVAILABLE_IN_2_68
!GType g_tree_get_type (void) G_GNUC_CONST;
function g_tree_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_tree_get_type
end function

! GLIB_AVAILABLE_IN_2_70
!GType g_pattern_spec_get_type (void) G_GNUC_CONST;
function g_pattern_spec_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_pattern_spec_get_type
end function

! GLIB_DEPRECATED_FOR('G_TYPE_VARIANT')
!GType g_variant_get_gtype (void) G_GNUC_CONST;
function g_variant_get_gtype() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_variant_get_gtype
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gbindinggroup.h
!--------------------------------------------------
! GLIB_AVAILABLE_IN_2_72
!GType g_binding_group_get_type (void) G_GNUC_CONST;
function g_binding_group_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_binding_group_get_type
end function

! GLIB_AVAILABLE_IN_2_72
!GBindingGroup *g_binding_group_new (void);
function g_binding_group_new() bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_group_new
end function

! GLIB_AVAILABLE_IN_2_72
!gpointer g_binding_group_dup_source (GBindingGroup *self);
function g_binding_group_dup_source(self) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_binding_group_dup_source
  type(c_ptr), value :: self
end function

! GLIB_AVAILABLE_IN_2_72
!void g_binding_group_set_source (GBindingGroup *self, gpointer source);
subroutine g_binding_group_set_source(self, source) bind(c)
  import :: c_ptr
  type(c_ptr), value :: self
  type(c_ptr), value :: source
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_binding_group_bind (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
subroutine g_binding_group_bind(self, source_property, target, target_property,&
& flags) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_binding_group_bind_full (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify user_data_destroy);
subroutine g_binding_group_bind_full(self, source_property, target,&
& target_property, flags, transform_to, transform_from, user_data,&
& user_data_destroy) bind(c)
  import :: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_funptr), value :: transform_to
  type(c_funptr), value :: transform_from
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_destroy
end subroutine

! GLIB_AVAILABLE_IN_2_72
!void g_binding_group_bind_with_closures (GBindingGroup *self, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
subroutine g_binding_group_bind_with_closures(self, source_property, target,&
& target_property, flags, transform_to, transform_from) bind(c)
  import :: c_ptr, c_char, c_int
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_ptr), value :: transform_to
  type(c_ptr), value :: transform_from
end subroutine

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gobjectnotifyqueue.c
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gobject/glib-enumtypes.h
!--------------------------------------------------
!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gtype.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_36
!void g_type_init (void);
subroutine g_type_init() bind(c)
end subroutine

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_type_name (GType type);
function g_type_name(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_name
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GQuark g_type_qname (GType type);
function g_type_qname(type) bind(c)
  import :: c_int32_t, c_size_t
  integer(c_int32_t) :: g_type_qname
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_from_name (const gchar *name);
function g_type_from_name(name) bind(c)
  import :: c_size_t, c_char
  integer(c_size_t) :: g_type_from_name
  character(kind=c_char), dimension(*) :: name
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_parent (GType type);
function g_type_parent(type) bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_parent
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!guint g_type_depth (GType type);
function g_type_depth(type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_depth
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_next_base (GType leaf_type, GType root_type);
function g_type_next_base(leaf_type, root_type) bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_next_base
  integer(c_size_t), value :: leaf_type
  integer(c_size_t), value :: root_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_is_a (GType type, GType is_a_type);
function g_type_is_a(type, is_a_type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_is_a
  integer(c_size_t), value :: type
  integer(c_size_t), value :: is_a_type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_class_ref (GType type);
function g_type_class_ref(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_ref
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_class_peek (GType type);
function g_type_class_peek(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_class_peek_static (GType type);
function g_type_class_peek_static(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek_static
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_class_unref (gpointer g_class);
subroutine g_type_class_unref(g_class) bind(c)
  import :: c_ptr
  type(c_ptr), value :: g_class
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_class_peek_parent (gpointer g_class);
function g_type_class_peek_parent(g_class) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_type_class_peek_parent
  type(c_ptr), value :: g_class
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_interface_peek (gpointer instance_class, GType iface_type);
function g_type_interface_peek(instance_class, iface_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_peek
  type(c_ptr), value :: instance_class
  integer(c_size_t), value :: iface_type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_interface_peek_parent (gpointer g_iface);
function g_type_interface_peek_parent(g_iface) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_type_interface_peek_parent
  type(c_ptr), value :: g_iface
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_default_interface_ref (GType g_type);
function g_type_default_interface_ref(g_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_ref
  integer(c_size_t), value :: g_type
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_default_interface_peek (GType g_type);
function g_type_default_interface_peek(g_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_peek
  integer(c_size_t), value :: g_type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_default_interface_unref (gpointer g_iface);
subroutine g_type_default_interface_unref(g_iface) bind(c)
  import :: c_ptr
  type(c_ptr), value :: g_iface
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType* g_type_children (GType type, guint *n_children);
function g_type_children(type, n_children) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_children
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_children
end function

! GLIB_AVAILABLE_IN_ALL
!GType* g_type_interfaces (GType type, guint *n_interfaces);
function g_type_interfaces(type, n_interfaces) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_interfaces
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_interfaces
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_set_qdata (GType type, GQuark quark, gpointer data);
subroutine g_type_set_qdata(type, quark, data) bind(c)
  import :: c_size_t, c_int32_t, c_ptr
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_get_qdata (GType type, GQuark quark);
function g_type_get_qdata(type, quark) bind(c)
  import :: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_type_get_qdata
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_query (GType type, GTypeQuery *query);
subroutine g_type_query(type, query) bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: type
  type(c_ptr), value :: query
end subroutine

! GLIB_AVAILABLE_IN_2_44
!int g_type_get_instance_count (GType type);
function g_type_get_instance_count(type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_get_instance_count
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_register_static (GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags);
function g_type_register_static(parent_type, type_name, info, flags) bind(c)
  import :: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_static
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_register_static_simple (GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
function g_type_register_static_simple(parent_type, type_name, class_size,&
& class_init, instance_size, instance_init, flags) bind(c)
  import :: c_size_t, c_char, c_int, c_funptr
  integer(c_size_t) :: g_type_register_static_simple
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  integer(c_int), value :: class_size
  type(c_funptr), value :: class_init
  integer(c_int), value :: instance_size
  type(c_funptr), value :: instance_init
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_register_dynamic (GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags);
function g_type_register_dynamic(parent_type, type_name, plugin, flags) bind(c)
  import :: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_dynamic
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: plugin
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_register_fundamental (GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags);
function g_type_register_fundamental(type_id, type_name, info, finfo, flags)&
& bind(c)
  import :: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_fundamental
  integer(c_size_t), value :: type_id
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  type(c_ptr), value :: finfo
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_add_interface_static (GType instance_type, GType interface_type, const GInterfaceInfo *info);
subroutine g_type_add_interface_static(instance_type, interface_type, info)&
& bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_add_interface_dynamic (GType instance_type, GType interface_type, GTypePlugin *plugin);
subroutine g_type_add_interface_dynamic(instance_type, interface_type, plugin)&
& bind(c)
  import :: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: plugin
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_interface_add_prerequisite (GType interface_type, GType prerequisite_type);
subroutine g_type_interface_add_prerequisite(interface_type, prerequisite_type)&
& bind(c)
  import :: c_size_t
  integer(c_size_t), value :: interface_type
  integer(c_size_t), value :: prerequisite_type
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GType*g_type_interface_prerequisites (GType interface_type, guint *n_prerequisites);
function g_type_interface_prerequisites(interface_type, n_prerequisites)&
& bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_prerequisites
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: n_prerequisites
end function

! GLIB_AVAILABLE_IN_2_68
!GType g_type_interface_instantiatable_prerequisite (GType interface_type);
function g_type_interface_instantiatable_prerequisite(interface_type) bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_interface_instantiatable_prerequisite
  integer(c_size_t), value :: interface_type
end function

! GLIB_DEPRECATED_IN_2_58
!void g_type_class_add_private (gpointer g_class, gsize private_size);
subroutine g_type_class_add_private(g_class, private_size) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: private_size
end subroutine

! GLIB_AVAILABLE_IN_2_38
!gint g_type_add_instance_private (GType class_type, gsize private_size);
function g_type_add_instance_private(class_type, private_size) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_add_instance_private
  integer(c_size_t), value :: class_type
  integer(c_size_t), value :: private_size
end function

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_instance_get_private (GTypeInstance *instance, GType private_type);
function g_type_instance_get_private(instance, private_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_instance_get_private
  type(c_ptr), value :: instance
  integer(c_size_t), value :: private_type
end function

! GLIB_AVAILABLE_IN_2_38
!void g_type_class_adjust_private_offset (gpointer g_class, gint *private_size_or_offset);
subroutine g_type_class_adjust_private_offset(g_class, private_size_or_offset)&
& bind(c)
  import :: c_ptr
  type(c_ptr), value :: g_class
  type(c_ptr), value :: private_size_or_offset
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_add_class_private (GType class_type, gsize private_size);
subroutine g_type_add_class_private(class_type, private_size) bind(c)
  import :: c_size_t
  integer(c_size_t), value :: class_type
  integer(c_size_t), value :: private_size
end subroutine

! GLIB_AVAILABLE_IN_ALL
!gpointer g_type_class_get_private (GTypeClass *klass, GType private_type);
function g_type_class_get_private(klass, private_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_get_private
  type(c_ptr), value :: klass
  integer(c_size_t), value :: private_type
end function

! GLIB_AVAILABLE_IN_2_38
!gint g_type_class_get_instance_private_offset (gpointer g_class);
function g_type_class_get_instance_private_offset(g_class) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_type_class_get_instance_private_offset
  type(c_ptr), value :: g_class
end function

! GLIB_AVAILABLE_IN_2_34
!void g_type_ensure (GType type);
subroutine g_type_ensure(type) bind(c)
  import :: c_size_t
  integer(c_size_t), value :: type
end subroutine

! GLIB_AVAILABLE_IN_2_36
!guint g_type_get_type_registration_serial (void);
function g_type_get_type_registration_serial() bind(c)
  import :: c_int
  integer(c_int) :: g_type_get_type_registration_serial
end function

! GLIB_AVAILABLE_IN_ALL
!GTypePlugin* g_type_get_plugin (GType type);
function g_type_get_plugin(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_get_plugin
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!GTypePlugin* g_type_interface_get_plugin (GType instance_type, GType interface_type);
function g_type_interface_get_plugin(instance_type, interface_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_get_plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_fundamental_next (void);
function g_type_fundamental_next() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_fundamental_next
end function

! GLIB_AVAILABLE_IN_ALL
!GType g_type_fundamental (GType type_id);
function g_type_fundamental(type_id) bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_type_fundamental
  integer(c_size_t), value :: type_id
end function

! GLIB_AVAILABLE_IN_ALL
!GTypeInstance* g_type_create_instance (GType type);
function g_type_create_instance(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_create_instance
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!void g_type_free_instance (GTypeInstance *instance);
subroutine g_type_free_instance(instance) bind(c)
  import :: c_ptr
  type(c_ptr), value :: instance
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_add_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_add_class_cache_func(cache_data, cache_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_remove_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_remove_class_cache_func(cache_data, cache_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_class_unref_uncached (gpointer g_class);
subroutine g_type_class_unref_uncached(g_class) bind(c)
  import :: c_ptr
  type(c_ptr), value :: g_class
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_add_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_add_interface_check(check_data, check_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!void g_type_remove_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_remove_interface_check(check_data, check_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

! GLIB_AVAILABLE_IN_ALL
!GTypeValueTable* g_type_value_table_peek (GType type);
function g_type_value_table_peek(type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_value_table_peek
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_instance (GTypeInstance *instance) G_GNUC_PURE;
function g_type_check_instance(instance) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_type_check_instance
  type(c_ptr), value :: instance
end function

! GLIB_AVAILABLE_IN_ALL
!GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance, GType iface_type);
function g_type_check_instance_cast(instance, iface_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_instance_cast
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_instance_is_a (GTypeInstance *instance, GType iface_type) G_GNUC_PURE;
function g_type_check_instance_is_a(instance, iface_type) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_instance_is_a
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! GLIB_AVAILABLE_IN_2_42
!gboolean g_type_check_instance_is_fundamentally_a (GTypeInstance *instance, GType fundamental_type) G_GNUC_PURE;
function g_type_check_instance_is_fundamentally_a(instance, fundamental_type)&
& bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_instance_is_fundamentally_a
  type(c_ptr), value :: instance
  integer(c_size_t), value :: fundamental_type
end function

! GLIB_AVAILABLE_IN_ALL
!GTypeClass* g_type_check_class_cast (GTypeClass *g_class, GType is_a_type);
function g_type_check_class_cast(g_class, is_a_type) bind(c)
  import :: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_class_cast
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_class_is_a (GTypeClass *g_class, GType is_a_type) G_GNUC_PURE;
function g_type_check_class_is_a(g_class, is_a_type) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_class_is_a
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_is_value_type (GType type) G_GNUC_CONST;
function g_type_check_is_value_type(type) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_check_is_value_type
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_value (const GValue *value) G_GNUC_PURE;
function g_type_check_value(value) bind(c)
  import :: c_int, c_ptr
  integer(c_int) :: g_type_check_value
  type(c_ptr), value :: value
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_check_value_holds (const GValue *value, GType type) G_GNUC_PURE;
function g_type_check_value_holds(value, type) bind(c)
  import :: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_value_holds
  type(c_ptr), value :: value
  integer(c_size_t), value :: type
end function

! GLIB_AVAILABLE_IN_ALL
!gboolean g_type_test_flags (GType type, guint flags) G_GNUC_CONST;
function g_type_test_flags(type, flags) bind(c)
  import :: c_int, c_size_t
  integer(c_int) :: g_type_test_flags
  integer(c_size_t), value :: type
  integer(c_int), value :: flags
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_type_name_from_instance (GTypeInstance *instance);
function g_type_name_from_instance(instance) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_type_name_from_instance
  type(c_ptr), value :: instance
end function

! GLIB_AVAILABLE_IN_ALL
!const gchar * g_type_name_from_class (GTypeClass *g_class);
function g_type_name_from_class(g_class) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_type_name_from_class
  type(c_ptr), value :: g_class
end function

!--------------------------------------------------
! /usr/include/glib-2.0/gobject/gvaluearray.h
!--------------------------------------------------
! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GType g_value_array_get_type (void) G_GNUC_CONST;
function g_value_array_get_type() bind(c)
  import :: c_size_t
  integer(c_size_t) :: g_value_array_get_type
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValue* g_value_array_get_nth (GValueArray *value_array, guint index_);
function g_value_array_get_nth(value_array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_value_array_get_nth
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_new (guint n_prealloced);
function g_value_array_new(n_prealloced) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_value_array_new
  integer(c_int), value :: n_prealloced
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!void g_value_array_free (GValueArray *value_array);
subroutine g_value_array_free(value_array) bind(c)
  import :: c_ptr
  type(c_ptr), value :: value_array
end subroutine

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_copy (const GValueArray *value_array);
function g_value_array_copy(value_array) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_array_copy
  type(c_ptr), value :: value_array
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_prepend (GValueArray *value_array, const GValue *value);
function g_value_array_prepend(value_array, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_array_prepend
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_append (GValueArray *value_array, const GValue *value);
function g_value_array_append(value_array, value) bind(c)
  import :: c_ptr
  type(c_ptr) :: g_value_array_append
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_insert (GValueArray *value_array, guint index_, const GValue *value);
function g_value_array_insert(value_array, index_, value) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_value_array_insert
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
  type(c_ptr), value :: value
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_remove (GValueArray *value_array, guint index_);
function g_value_array_remove(value_array, index_) bind(c)
  import :: c_ptr, c_int
  type(c_ptr) :: g_value_array_remove
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_sort (GValueArray *value_array, GCompareFunc compare_func);
function g_value_array_sort(value_array, compare_func) bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
end function

! GLIB_DEPRECATED_IN_2_32_FOR(GArray)
!GValueArray* g_value_array_sort_with_data (GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data);
function g_value_array_sort_with_data(value_array, compare_func, user_data)&
& bind(c)
  import :: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort_with_data
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

end interface
end module g
